<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> TeX_baitu blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      


<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-20221214-通过Content-Type和文件头判断文件类型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-%E9%80%9A%E8%BF%87Content-Type%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"
    >20221214-通过Content-Type和文件头判断文件类型</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-%E9%80%9A%E8%BF%87Content-Type%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2022-12-14T12:43:46.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="通过Content-Type和文件头判断文件类型"><a href="#通过Content-Type和文件头判断文件类型" class="headerlink" title="通过Content-Type和文件头判断文件类型"></a>通过Content-Type和文件头判断文件类型</h1><h2 id="关于MIME"><a href="#关于MIME" class="headerlink" title="关于MIME"></a>关于MIME</h2><p><strong>MIME</strong>的全称是Multipurpose Internet Mail Extensions，即多用途互联网邮件扩展，尽管读起来有些拗口，但大多数人可能都知道，<br>这是HTTP协议中用来定义文档性质及格式的标准。<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6838">IETF RFC 6838</a>，对HTTP传输内容类型进行了全面定义。<br>而<strong>IANA</strong>(互联网号码分配机构)是负责管理所有标准MIME类型的官方机构。可以<a target="_blank" rel="noopener" href="https://www.iana.org/assignments/media-types/media-types.xhtml">在这里</a>)找到所有的标准MIME</p>
<p><strong>服务器通过MIME告知响应内容类型，而浏览器则通过MIME类型来确定如何处理文档；</strong><br><strong>因此为传输内容(文档、图片等)设置正确的MIME非常重要</strong>。</p>
<p>通常Server会在HTTP响应中设置<strong>Content-Type</strong>，如下面的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeHTTP/1.1 200 OKServer: Golfe2    Content-Length: 233Content-Type: application/htmlDate: Sun, 28 Dec 2018 02:55:19 GMT12345</span><br></pre></td></tr></table></figure>

<p>这表示服务端将返回html格式的文档，而同样客户端也可以在HTTP请求中设置<strong>Content-Type</strong>以告知服务器当前所发送内容的格式。<br>如下面的请求体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodePOST / HTTP/1.1Host: localhost:8000User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Connection: keep-aliveContent-Type: application/jsonContent-Length: 4651234567</span><br></pre></td></tr></table></figure>

<p>这表示客户端会发送application&#x2F;json格式的数据到服务端，同时应该注意到<strong>Accept</strong>请求头，这个选项用于告知服务器应该返回什么样的数据格式(由客户端接收并完成解析)。</p>
<p><strong>MIME的格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Codetype/subtype1</span><br></pre></td></tr></table></figure>

<p>这是一个两级的分类，比较容易理解，第一级分类通常包含：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>普通文本</td>
</tr>
<tr>
<td>image</td>
<td>某种图像</td>
</tr>
<tr>
<td>audio</td>
<td>某种音频文件</td>
</tr>
<tr>
<td>video</td>
<td>某种视频文件</td>
</tr>
<tr>
<td>application</td>
<td>应用数据</td>
</tr>
<tr>
<td>multi-part</td>
<td>复合内容</td>
</tr>
</tbody></table>
<p>而二级类型则非常多，以下是一些常用的MIME：</p>
<table>
<thead>
<tr>
<th>MIME</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>audio&#x2F;wav</td>
<td>wave音频流媒体文件</td>
</tr>
<tr>
<td>audio&#x2F;webm</td>
<td>webm 音频文件格式</td>
</tr>
<tr>
<td>audio&#x2F;ogg</td>
<td>ogg多媒体文件格式的音频文件</td>
</tr>
<tr>
<td>audio&#x2F;mpeg</td>
<td>mpeg多媒体文件格式的音频文件</td>
</tr>
<tr>
<td>image&#x2F;gif</td>
<td>gif图片</td>
</tr>
<tr>
<td>image&#x2F;jpeg</td>
<td>jpeg图片</td>
</tr>
<tr>
<td>image&#x2F;png</td>
<td>png图片</td>
</tr>
<tr>
<td>image&#x2F;svg+xml</td>
<td>svg矢量图片</td>
</tr>
<tr>
<td>application&#x2F;json</td>
<td>json格式</td>
</tr>
<tr>
<td>application&#x2F;xml</td>
<td>xml格式</td>
</tr>
<tr>
<td>application&#x2F;xhtml+xml</td>
<td>扩展html格式</td>
</tr>
<tr>
<td>application&#x2F;x-www-form-urlencoded</td>
<td>表单url内容编码</td>
</tr>
<tr>
<td>application&#x2F;octet-stream</td>
<td>二进制格式</td>
</tr>
<tr>
<td>application&#x2F;pdf</td>
<td>pdf文档</td>
</tr>
<tr>
<td>application&#x2F;atom+xml</td>
<td>atom订阅feed流</td>
</tr>
<tr>
<td>multipart&#x2F;form-data</td>
<td>多文档格式</td>
</tr>
<tr>
<td>text&#x2F;plain</td>
<td>普通文本</td>
</tr>
<tr>
<td>text&#x2F;html</td>
<td>html文档</td>
</tr>
<tr>
<td>text&#x2F;css</td>
<td>css文件</td>
</tr>
<tr>
<td>text&#x2F;javascript</td>
<td>javascript文件</td>
</tr>
<tr>
<td>text&#x2F;markdown</td>
<td>markdown文档</td>
</tr>
<tr>
<td>video&#x2F;mpeg</td>
<td>mpeg多媒体视频文件</td>
</tr>
<tr>
<td>video&#x2F;quicktime</td>
<td>mov多媒体视频文件</td>
</tr>
</tbody></table>
<h4 id="MIME-Type-与-Content-Type-的关系"><a href="#MIME-Type-与-Content-Type-的关系" class="headerlink" title="MIME Type 与 Content-Type 的关系"></a>MIME Type 与 Content-Type 的关系</h4><p>首先看看tomcat服务器中默认的web.xml中的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code&lt;!-- ===================== Default MIME Type Mappings =================== --&gt;&lt;!-- When serving static resources, Tomcat will automatically generate    --&gt;&lt;!-- a &quot;Content-Type&quot; header based on the resource&#x27;s filename extension, --&gt;&lt;!-- based on these mappings. Additional mappings can be added here (to --&gt;&lt;!-- apply to all web applications), or in your own application&#x27;s web.xml --&gt;&lt;!-- deployment descriptor.   --&gt;123456</span><br></pre></td></tr></table></figure>

<p>再看看apache服务器中mime.types的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeThis file controls what Internet media types are sent to the client forgiven file extension(s). Sending the correct media type to the clientis important so they know how to handle the content of the file.Extra types can either be added here or by using an AddType directivein your config files. For more information about Internet media types,please read RFC 2045, 2046, 2047, 2048, and 2077. The Internet media type registry is at http://www.iana.org/assignments/media-types/.123456</span><br></pre></td></tr></table></figure>

<p><strong>当web服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的MIME配置文件中找到对应的MIME Type，再根据MIME Type设置HTTP Response的Content-Type，然后浏览器根据Content-Type的值处理文件。</strong></p>
<p>也就是说, <strong>文件扩展名&#x3D;&gt;MIME Type&#x3D;&gt;Content-Type</strong></p>
<h2 id="通过文件头识别文件"><a href="#通过文件头识别文件" class="headerlink" title="通过文件头识别文件"></a>通过文件头识别文件</h2><p>不同的文件类型有不同的文件头, 而文件头部的几个字节被称为Magic Number, 通常用十六进制表示, 可用来判断文件类型.</p>
<p>比如png文件的文件头Magic Number是0x89504E开始的, java class文件Magic Number为Oxcafebabe</p>
<p>我们可以通过判断文件的文件头信息来判断文件的类型, 而且<strong>即使改变文件扩展名文件头信息也是不改变的</strong>.</p>
<p>通过java代码判断文件类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Javapublic class FileType &#123;    //默认判断文件头前三个字节内容    public static int CHECK_BYTES_NUMBER = 3;    public final static Map&lt;String, String&gt; FILE_TYPE_MAP = new HashMap&lt;String, String&gt;();    private FileType()&#123;&#125;    static&#123;        getAllFileType(); //初始化文件类型信息    &#125;    /**     * Discription:[getAllFileType,常见文件头信息]     */    private static void getAllFileType()    &#123;        FILE_TYPE_MAP.put(&quot;ffd8ffe000104a464946&quot;, &quot;jpg&quot;); //JPEG (jpg)        FILE_TYPE_MAP.put(&quot;89504e470d0a1a0a0000&quot;, &quot;png&quot;); //PNG (png)        FILE_TYPE_MAP.put(&quot;47494638396126026f01&quot;, &quot;gif&quot;); //GIF (gif)        FILE_TYPE_MAP.put(&quot;49492a00227105008037&quot;, &quot;tif&quot;); //TIFF (tif)        FILE_TYPE_MAP.put(&quot;424d228c010000000000&quot;, &quot;bmp&quot;); //16色位图(bmp)        FILE_TYPE_MAP.put(&quot;424d8240090000000000&quot;, &quot;bmp&quot;); //24位位图(bmp)        FILE_TYPE_MAP.put(&quot;424d8e1b030000000000&quot;, &quot;bmp&quot;); //256色位图(bmp)        FILE_TYPE_MAP.put(&quot;41433130313500000000&quot;, &quot;dwg&quot;); //CAD (dwg)        FILE_TYPE_MAP.put(&quot;3c21444f435459504520&quot;, &quot;html&quot;); //HTML (html)        FILE_TYPE_MAP.put(&quot;3c21646f637479706520&quot;, &quot;htm&quot;); //HTM (htm)        FILE_TYPE_MAP.put(&quot;48544d4c207b0d0a0942&quot;, &quot;css&quot;); //css        FILE_TYPE_MAP.put(&quot;696b2e71623d696b2e71&quot;, &quot;js&quot;); //js        FILE_TYPE_MAP.put(&quot;7b5c727466315c616e73&quot;, &quot;rtf&quot;); //Rich Text Format (rtf)        FILE_TYPE_MAP.put(&quot;38425053000100000000&quot;, &quot;psd&quot;); //Photoshop (psd)        FILE_TYPE_MAP.put(&quot;46726f6d3a203d3f6762&quot;, &quot;eml&quot;); //Email [Outlook Express 6] (eml)        FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;doc&quot;); //MS Excel 注意：word、msi 和 excel的文件头一样        FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;vsd&quot;); //Visio 绘图        FILE_TYPE_MAP.put(&quot;5374616E64617264204A&quot;, &quot;mdb&quot;); //MS Access (mdb)        FILE_TYPE_MAP.put(&quot;252150532D41646F6265&quot;, &quot;ps&quot;);        FILE_TYPE_MAP.put(&quot;255044462d312e350d0a&quot;, &quot;pdf&quot;); //Adobe Acrobat (pdf)        FILE_TYPE_MAP.put(&quot;2e524d46000000120001&quot;, &quot;rmvb&quot;); //rmvb/rm相同        FILE_TYPE_MAP.put(&quot;464c5601050000000900&quot;, &quot;flv&quot;); //flv与f4v相同        FILE_TYPE_MAP.put(&quot;00000020667479706d70&quot;, &quot;mp4&quot;);        FILE_TYPE_MAP.put(&quot;49443303000000002176&quot;, &quot;mp3&quot;);        FILE_TYPE_MAP.put(&quot;000001ba210001000180&quot;, &quot;mpg&quot;); //        FILE_TYPE_MAP.put(&quot;3026b2758e66cf11a6d9&quot;, &quot;wmv&quot;); //wmv与asf相同        FILE_TYPE_MAP.put(&quot;52494646e27807005741&quot;, &quot;wav&quot;); //Wave (wav)        FILE_TYPE_MAP.put(&quot;52494646d07d60074156&quot;, &quot;avi&quot;);        FILE_TYPE_MAP.put(&quot;4d546864000000060001&quot;, &quot;mid&quot;); //MIDI (mid)        FILE_TYPE_MAP.put(&quot;504b0304140000000800&quot;, &quot;zip&quot;);        FILE_TYPE_MAP.put(&quot;526172211a0700cf9073&quot;, &quot;rar&quot;);        FILE_TYPE_MAP.put(&quot;235468697320636f6e66&quot;, &quot;ini&quot;);        FILE_TYPE_MAP.put(&quot;504b03040a0000000000&quot;, &quot;jar&quot;);        FILE_TYPE_MAP.put(&quot;4d5a9000030000000400&quot;, &quot;exe&quot;);//可执行文件        FILE_TYPE_MAP.put(&quot;3c25402070616765206c&quot;, &quot;jsp&quot;);//jsp文件        FILE_TYPE_MAP.put(&quot;4d616e69666573742d56&quot;, &quot;mf&quot;);//MF文件        FILE_TYPE_MAP.put(&quot;3c3f786d6c2076657273&quot;, &quot;xml&quot;);//xml文件        FILE_TYPE_MAP.put(&quot;494e5345525420494e54&quot;, &quot;sql&quot;);//xml文件        FILE_TYPE_MAP.put(&quot;7061636b616765207765&quot;, &quot;java&quot;);//java文件        FILE_TYPE_MAP.put(&quot;406563686f206f66660d&quot;, &quot;bat&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;1f8b0800000000000000&quot;, &quot;gz&quot;);//gz文件        FILE_TYPE_MAP.put(&quot;6c6f67346a2e726f6f74&quot;, &quot;properties&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;cafebabe0000002e0041&quot;, &quot;class&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;49545346030000006000&quot;, &quot;chm&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;04000000010000001300&quot;, &quot;mxp&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;504b0304140006000800&quot;, &quot;docx&quot;);//docx文件        FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;wps&quot;);//WPS文字wps、表格et、演示dps都是一样的        FILE_TYPE_MAP.put(&quot;6431303a637265617465&quot;, &quot;torrent&quot;);        FILE_TYPE_MAP.put(&quot;6D6F6F76&quot;, &quot;mov&quot;); //Quicktime (mov)        FILE_TYPE_MAP.put(&quot;FF575043&quot;, &quot;wpd&quot;); //WordPerfect (wpd)        FILE_TYPE_MAP.put(&quot;CFAD12FEC5FD746F&quot;, &quot;dbx&quot;); //Outlook Express (dbx)        FILE_TYPE_MAP.put(&quot;2142444E&quot;, &quot;pst&quot;); //Outlook (pst)        FILE_TYPE_MAP.put(&quot;AC9EBD8F&quot;, &quot;qdf&quot;); //Quicken (qdf)        FILE_TYPE_MAP.put(&quot;E3828596&quot;, &quot;pwl&quot;); //Windows Password (pwl)        FILE_TYPE_MAP.put(&quot;2E7261FD&quot;, &quot;ram&quot;); //Real Audio (ram)    &#125;    /**     * 根据制定文件的文件头判断其文件类型     * @param filePaht     * @return     */    public static String getFileType(String filePaht)&#123;        String res = null;        try &#123;            FileInputStream is = new FileInputStream(filePaht);            getFileType(is);        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;        return res;    &#125;    public static String getFileType(InputStream in)&#123;        String res = null;        try &#123;            byte[] b = new byte[CHECK_BYTES_NUMBER];            in.read(b, 0, b.length);            String fileCode = bytesToHexString(b);//            System.out.println(fileCode);            //这种方法在字典的头代码不够位数的时候可以用但是速度相对慢一点            Iterator&lt;String&gt; keyIter = FILE_TYPE_MAP.keySet().iterator();            while(keyIter.hasNext())&#123;                String key = keyIter.next();                if(key.toLowerCase().startsWith(fileCode.toLowerCase()) || fileCode.toLowerCase().startsWith(key.toLowerCase()))&#123;                    res = FILE_TYPE_MAP.get(key);                    break;                &#125;            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return res;    &#125;    /**     * 得到上传文件的文件头     * @param src     * @return     */    public static String bytesToHexString(byte[] src) &#123;        StringBuilder stringBuilder = new StringBuilder();        if (src == null || src.length &lt;= 0) &#123;            return null;        &#125;        for (int i = 0; i &lt; src.length; i++) &#123;            int v = src[i] &amp; 0xFF;            String hv = Integer.toHexString(v);            if (hv.length() &lt; 2) &#123;                stringBuilder.append(0);            &#125;            stringBuilder.append(hv);        &#125;        return stringBuilder.toString();    &#125;    public static int getCheckBytesNumber() &#123;        return CHECK_BYTES_NUMBER;    &#125;    public static void setCheckBytesNumber(int checkBytesNumber) &#123;        CHECK_BYTES_NUMBER = checkBytesNumber;    &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150</span><br></pre></td></tr></table></figure>

<p>常见文件头表示如下:</p>
<p>255044PDF<br>526563 EML<br>D0CF11 PPT<br>4D5AEE COM<br>E93B03 COM<br>4D5A90 EXE<br>424D3E BMP<br>49492A TIF<br>384250 PSD<br>C5D0D3 EPS<br>0A0501 PCS<br>89504E PNG<br>060500 RAW<br>000002 TGA<br>60EA27 ARJ<br>526172 RAR<br>504B03 ZIP<br>495363 CAB<br>1F9D8C Z<br>524946 WAV<br>435753 SWF<br>3026B2 WMV<br>3026B2 WMA<br>2E524D RM<br>00000F MOV<br>000077 MOV<br>000001 MPA<br>FFFB50 MP3<br>234558 m3u<br>3C2144 HTM<br>FFFE3C XSL<br>3C3F78 XML<br>3C3F78 MSC<br>4C0000 LNK<br>495453 CHM<br>805343 scm<br>D0CF11 XLS<br>31BE00 WRI<br>00FFFF MDF<br>4D4544 MDS<br>5B436C CCD<br>00FFFF IMG<br>FFFFFF SUB<br>17A150 PCB<br>2A5052 ECO<br>526563 PPC<br>000100 DDB<br>42494C LDB<br>2A7665 SCH<br>2A2420 LIB<br>434841 FNT<br>7B5C72 RTF<br>7B5072 GTD<br>234445 PRG<br>000007 PJT<br>202020 BAS<br>000002 TAG<br>4D5A90 dll<br>4D5A90 OCX<br>4D5A50 DPL<br>3F5F03 HLP<br>4D5A90 OLB<br>4D5A90 IMM<br>4D5A90 IME<br>3F5F03 LHP<br>C22020 NLS<br>5B5769 CPX<br>4D5A16 DRV<br>5B4144 PBK<br>24536F PLL<br>4E4553 NES<br>87F53E GBC<br>00FFFF SMD<br>584245 XBE<br>005001 XMV<br>000100 TTF<br>484802 PDG<br>000100 TST<br>414331 dwg<br>D0CF11 max</p>
<p>另外还有一些重要的文件，<strong>没有固定的文件头</strong>，如下：</p>
<p><strong>TXT 没固定文件头定义</strong><br>TMP 没固定文件头定义<br>INI 没固定文件头定义<br>BIN 没固定文件头定义<br>DBF 没固定文件头定义<br>C 没没固定文件头定义<br>CPP 没固定文件头定义<br>H 没固定文件头定义<br>BAT 没固定文件头定义</p>
<p>还有一些不同的文件有相同的文件头，最典型的就是下面：</p>
<p>4D5A90 EXE<br>4D5A90 dll<br>4D5A90 OCX<br>4D5A90 OLB<br>4D5A90 IMM<br>4D5A90 IME</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>当我们需要实现上传文件的时候, 为了安全起见, 我们需要判断上传文件的格式, 防止将病毒木马等有害的文件上传到服务器上.</p>
<p>判断文件类型的三种方式</p>
<ul>
<li><p>通过文件后缀名</p>
<p>这个方法只要修改后缀名就可以了</p>
</li>
<li><p>通过Content-Type判断</p>
<p>但是Content-Type取决于文件类型, 文件类型取决于文件扩展名, 所以改变了文件扩展名就改变了Content-Type</p>
</li>
<li><p>通过文件头判断文件, 即使文件扩展名改变了文件头也不会改变</p>
</li>
</ul>
<p>文件上传的思路: 先判断Content-Type, Content-Type符合条件的再判断文件头信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java<span class="meta">@ResponseBody</span>    <span class="meta">@GetMapping(&quot;validate&quot;)</span>    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">validate</span><span class="params">(<span class="meta">@Validated(&#123;AllFiled.class&#125;)</span> UserInfo userInfo, BindingResult result)</span>&#123;<span class="comment">//        SpringValidatorAdapter adapter = (SpringValidatorAdapter)result;        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        if (result.hasErrors()) &#123;            List&lt;ObjectError&gt; list  = result.getAllErrors();            for (ObjectError error :                    list) &#123;                FieldError fieldError = (FieldError)error;                String defaultMessage = fieldError.getDefaultMessage();                String field = fieldError.getField();                map.put(field, defaultMessage);            &#125;        &#125;        return map;    &#125;//    consumes = &#123;//        MediaType.MULTIPART_FORM_DATA_VALUE &#125;, produces = MediaType.TEXT_PLAIN_VALUE    @PostMapping(value = &quot;file&quot;)    @ResponseBody    public String file(@RequestParam(&quot;username&quot;) String name, MultipartFile file) throws IOException &#123;        //获取文件名        String fileName = file.getOriginalFilename();        //获取表单提交文件使用的字段        String partName = file.getName();        //判断文件是否为空        boolean empty = file.isEmpty();        //获取ContentType        String contentType = file.getContentType();        //获取文件直接数        Long size = file.getSize();        //获取文件所有字节        byte[] bytes = file.getBytes();        //获取InputStream        InputStream in = file.getInputStream();        //根据文件头获取文件类型        String type = FileType.getFileType(in);                //业务.....        StringBuilder builder = new StringBuilder();        //存储文件        File root = new File(&quot;D:/temp&quot;);        if (!root.isDirectory()) &#123;            root.mkdirs();        &#125;        try &#123;            file.transferTo(new File(root, name));            return String.format(&quot;Upload to %s&quot;, fileName);        &#125; catch (IllegalStateException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return &quot;Upload Failed&quot;;    &#125;</span></span><br></pre></td></tr></table></figure>


 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221214-二维码版本与容量"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%89%88%E6%9C%AC%E4%B8%8E%E5%AE%B9%E9%87%8F/"
    >20221214-二维码版本与容量</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%89%88%E6%9C%AC%E4%B8%8E%E5%AE%B9%E9%87%8F/" class="article-date">
  <time datetime="2022-12-14T12:07:19.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>二维码 QR - 版本与容量</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>矩阵大小</th>
<th>纠错等级</th>
<th>八位字节</th>
<th>数字</th>
<th>字母数字</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>21</td>
<td>L</td>
<td>17</td>
<td>41</td>
<td>25</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>14</td>
<td>34</td>
<td>20</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>11</td>
<td>27</td>
<td>16</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>7</td>
<td>17</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>25</td>
<td>L</td>
<td>32</td>
<td>77</td>
<td>47</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>26</td>
<td>63</td>
<td>38</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>20</td>
<td>48</td>
<td>29</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>14</td>
<td>34</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>29</td>
<td>L</td>
<td>53</td>
<td>127</td>
<td>77</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>42</td>
<td>101</td>
<td>61</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>32</td>
<td>77</td>
<td>47</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>24</td>
<td>58</td>
<td>35</td>
</tr>
<tr>
<td>4</td>
<td>33</td>
<td>L</td>
<td>78</td>
<td>187</td>
<td>114</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>62</td>
<td>149</td>
<td>90</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>46</td>
<td>111</td>
<td>67</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>34</td>
<td>82</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td>37</td>
<td>L</td>
<td>106</td>
<td>255</td>
<td>154</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>84</td>
<td>202</td>
<td>122</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>60</td>
<td>144</td>
<td>87</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>44</td>
<td>106</td>
<td>64</td>
</tr>
<tr>
<td>6</td>
<td>41</td>
<td>L</td>
<td>134</td>
<td>322</td>
<td>195</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>106</td>
<td>255</td>
<td>154</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>74</td>
<td>178</td>
<td>108</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>58</td>
<td>139</td>
<td>84</td>
</tr>
<tr>
<td>7</td>
<td>45</td>
<td>L</td>
<td>154</td>
<td>370</td>
<td>224</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>122</td>
<td>293</td>
<td>178</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>86</td>
<td>207</td>
<td>125</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>64</td>
<td>154</td>
<td>93</td>
</tr>
<tr>
<td>8</td>
<td>49</td>
<td>L</td>
<td>192</td>
<td>461</td>
<td>279</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>152</td>
<td>365</td>
<td>221</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>108</td>
<td>259</td>
<td>157</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>84</td>
<td>202</td>
<td>122</td>
</tr>
<tr>
<td>9</td>
<td>53</td>
<td>L</td>
<td>230</td>
<td>552</td>
<td>335</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>180</td>
<td>432</td>
<td>262</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>130</td>
<td>312</td>
<td>189</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>98</td>
<td>235</td>
<td>143</td>
</tr>
<tr>
<td>10</td>
<td>57</td>
<td>L</td>
<td>271</td>
<td>652</td>
<td>395</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>213</td>
<td>513</td>
<td>311</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>151</td>
<td>364</td>
<td>221</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>119</td>
<td>288</td>
<td>174</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221214-PDF文本的基本结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-PDF%E6%96%87%E6%9C%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"
    >20221214-PDF文本的基本结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-PDF%E6%96%87%E6%9C%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2022-12-14T06:11:47.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>PDF 文件是可以有效随机存取和增量更新的，根据基本规则，一个PDF 文件由四部分组成</p>
<ol>
<li>header部分：占一行，标识PDF规范的版本；</li>
<li>body部分：包含PDF文件中的所有obj对象；</li>
<li>cross-reference table 部分：交叉引用表，包含文件中间接对象的信息；</li>
<li>trailer部分：包含交叉引用表和文件正文中某些特殊对象的位置；</li>
</ol>
<p>按照惯例，PDF 文件中的标记按行排列，每行的终止标记可以是回车、换行、或两者兼有，包含二进制数据的PDF 文件可以有任意长的行</p>
<p>为了提高PDF 文件的兼容性，不属于流对象的数据行限制为不超过255个字符，但有一个例外，签名字典的内容字符串不受行长度限制</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221214-PNG格式详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-PNG%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"
    >20221214-PNG格式详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-PNG%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-12-14T03:35:43.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>png 是20世纪90年代开始开发的图像文件存储格式，其目的是替代gif 和tiff 文件格式，同时增加一些gif 文件格式所不具备的特性，流式网络图形格式名称来源于非官方的  是一种位图文件存储格式，读成ping 。png 用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的alpha 通道，png 使用从LZ77 派生的无损数据压缩算法</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>使用调色板技术可支持256种颜色的彩色图像  必须的</p>
<p>流式读 写性，图像文件格式允许连续读出和写入图像数据 因此适于网络传播</p>
<p>逐次逼近显示，这种特性可使在通信链路上传输图像文件的同时就在终端上显示图像，把整个轮廓显示出来之后逐步显示图像的细节，也就是先用低分辨率显示图像，然后逐步提高它的分辨率  类似马赛克逐渐消除的过程</p>
<p>透明性，这个性能可使图像中某些部分不显示出来，用来创建一些有特色的图像</p>
<p>辅助信息，这个特性可用来在图像文件中存储一些文本注释信息  就是可以说一些废话</p>
<p>独立于计算机硬件环境</p>
<p>使用无损压缩</p>
<p>可在一个文件中存储多幅图像</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>png 图像格式文件由文件署名和数据块 组成</p>
<p>文件署名域</p>
<p>8字节的png 文件署名域用来识别该文件是不是png 文件，该域的值是 </p>
<p>十进制数  十六进制数<br>137 89<br>80  50<br>78  4e<br>71  47<br>13  0d<br>10  0a<br>26  1a<br>10  0a<br>这个文件署名就是在《利用文件头标志判断文件类型》中提到的文件头标志了，很简单。</p>
<p>数据块</p>
<p>这里有两种类型的数据块，一种是称为关键数据块，就是必须要有的块，另一种叫做辅助数据块</p>
<p>每个数据块都由下表所示的4个域组成</p>
<p>名称  字节数 说明<br>Length(长度)  4字节 指定数据块中数据域的长度，其长度不超过(231−1)(231−1)字节<br>Chunk Type Code(数据块类型码) 4字节 数据块类型码由ASCII字母(A-Z和a-z)组成<br>Chunk Data(数据块实际内容  可变长度  存储按照Chunk Type Code指定的数据<br>CRC(循环冗余检测  4字节 存储用来检测是否有错误的循环冗余码</p>
<p>其中CRC 域中的值是对chunk type code 域和chunk data 域中的数据进行计算得到的，可以看作一种校验码</p>
<p>关键数据块</p>
<p>关键数据块中的4个标准数据块是</p>
<p>文件头数据块 IHDR</p>
<p>它包含有png 文件中存储的图像数据的基本信息，并要作为第一个数据块出现在png 数据流中，而且一个png 数据流中只能有一个文件头数据块</p>
<p>文件头数据块由13字节，组成结构如下</p>
<table>
<thead>
<tr>
<th>域的名称</th>
<th>字节数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Width</td>
<td>4 bytes</td>
<td>图像宽度，以像素为单位</td>
</tr>
<tr>
<td>Height</td>
<td>4 bytes</td>
<td>图像高度，以像素为单位</td>
</tr>
<tr>
<td>Bit depth</td>
<td>1 byte</td>
<td>图像深度：索引彩色图像：1，2，4或8 ;灰度图像：1，2，4，8或16 ;真彩色图像：8或16</td>
</tr>
<tr>
<td>ColorType</td>
<td>1 byte</td>
<td>颜色类型：0：灰度图像, 1，2，4，8或16;2：真彩色图像，8或16;3：索引彩色图像，1，2，4或84：带α通道数据的灰度图像，8或16;6：带α通道数据的真彩色图像，8或16</td>
</tr>
<tr>
<td>Compression method</td>
<td>1 byte</td>
<td>压缩方法(LZ77派生算法)</td>
</tr>
<tr>
<td>Filter method</td>
<td>1 byte</td>
<td>滤波器方法</td>
</tr>
<tr>
<td>Interlace method</td>
<td>1 byte</td>
<td>隔行扫描方法：0：非隔行扫描;1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td>
</tr>
</tbody></table>
<p>调色板数据块PLTE</p>
<p>它包含有与索引彩色图像相关的彩色变换数据，它仅与索引彩色图像有关，而且要放在图像数据块之前，真彩色的png 数据流也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像，结构如下</p>
<p>|颜色|字节|意义|<br>|Red|1 byte | 0 &#x3D; 黑色, 255 &#x3D; 红|<br>|Green|1 byte | 0 &#x3D; 黑色, 255 &#x3D; 绿色|<br>|Blue|1 byte | 0 &#x3D; 黑色, 255 &#x3D; 蓝色|</p>
<p>PLTE 数据块是定义图像的调色板信息，PLTE 可以包含1-256 个调色板信息，每个调色板信息由3个字节组成，因此调色板数据块所包含的最大字节数为768 调色板的长度应该是3的倍数，否则，这将使一个非法的调色板</p>
<p>对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是 1 2 调色板的颜色数不能超过色深中规定的颜色数，否则，这将导致png 图像不合法</p>
<p>图像数据块 IDAT </p>
<p>它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块<br>IDAT 存放着图像真正的数据信息，因此，如果能够了解IDAT 的结构，我们就可以很方便的生成PNG 图像</p>
<p>图像结束数据IEND </p>
<p>它用来标记png 文件或者数据流已经结束，并且必须要放在文件的尾部</p>
<p>如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：</p>
<p>00 00 00 00 49 45 4E 44 AE 42 60 82</p>
<p>不难明白，由于数据块结构的定义，IEND 数据块的长度总是0 0000000除非认为加入信息，数据标识总是iend 因此，CRC码也总是AE 42 60 82</p>
<p>最后，除了表示数据块开始IHDR 必须放在最前面，表示png 文件结束的iend 数据块放在最后面，其他数据块的存放顺序没有限制</p>
<p>辅助数据块</p>
<p>比较杂 ，不需要全部了解透</p>
<p>PNG 文件格式规范指定的10个辅助数据块是</p>
<p>背景颜色数据块 bKGD</p>
<p>基色和白色度数块cHRM 所谓白色度是指当 R G B 最大值时在显示器上产生的白色度</p>
<p>图像gamma 数据块 gAMA</p>
<p>图像直方图数据块hIST<br>物理像素尺寸数据块 pHYs</p>
<p>样本有效位数据块 sBIT</p>
<p>文本信息数据块 tEXt<br>图像最后修改时间数据块 tIME<br>图像透明数据块 tRNS </p>
<p>压缩文本数据块 zTXt</p>
<h2 id="数据块摘要"><a href="#数据块摘要" class="headerlink" title="数据块摘要"></a>数据块摘要</h2><p>关键数据块，辅助数据块和专用公共数据块 综合下表中</p>
<table>
<thead>
<tr>
<th>数据块符号</th>
<th>数据块名称</th>
<th>多数据块</th>
<th>可选否</th>
<th>位置限制</th>
</tr>
</thead>
<tbody><tr>
<td>IHDR</td>
<td>文件头数据块</td>
<td>否</td>
<td>否</td>
<td>第一块</td>
</tr>
<tr>
<td>cHRM</td>
<td>基色和白色点数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE和IDAT之前</td>
</tr>
<tr>
<td>gAMA</td>
<td>图像γ数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE和IDAT之前</td>
</tr>
<tr>
<td>sBIT</td>
<td>样本有效位数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE和IDAT之前</td>
</tr>
<tr>
<td>PLTE</td>
<td>调色板数据块</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>bKGD</td>
<td>背景颜色数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE之后IDAT之前</td>
</tr>
<tr>
<td>hIST</td>
<td>图像直方图数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE之后IDAT之前</td>
</tr>
<tr>
<td>tRNS</td>
<td>图像透明数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE之后IDAT之前</td>
</tr>
<tr>
<td>oFFs</td>
<td>(专用公共数据块)</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>pHYs</td>
<td>物理像素尺寸数据块</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>sCAL</td>
<td>(专用公共数据块)</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>IDAT</td>
<td>图像数据块</td>
<td>是</td>
<td>否</td>
<td>与其他IDAT连续</td>
</tr>
<tr>
<td>tIME</td>
<td>图像最后修改时间数据块</td>
<td>否</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>tEXt</td>
<td>文本信息数据块</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>zTXt</td>
<td>压缩文本数据块</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>fRAc</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>gIFg</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>gIFt</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>gIFx</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>IEND</td>
<td>图像结束数据</td>
<td>否</td>
<td>否</td>
<td>最后一个数据块</td>
</tr>
</tbody></table>
<p>tEXt和zTXt数据块中的标准关键字：</p>
<p>关键字 说明<br>Title 图像名称或者标题<br>Author  图像作者名<br>Description 图像说明<br>Copyright 版权声明<br>CreationTime  原图创作时间<br>Software  创作图像使用的软件<br>Disclaimer  弃权<br>Warning 图像内容警告<br>Source  创作图像使用的设备<br>Comment 各种注释<br>一个例子</p>
<!-- http://qr61.cn/o8bjsz/qEp8BlI --> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-BMP格式结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-BMP%E6%A0%BC%E5%BC%8F%E7%BB%93%E6%9E%84/"
    >20221213-BMP格式结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-BMP%E6%A0%BC%E5%BC%8F%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2022-12-13T11:26:33.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>docs.microsoft.com&#x2F;zh-cn&#x2F;windows&#x2F;win32&#x2F;gdibitmap-storage</p>
<p>简介</p>
<p>bmp 图形文件是windows 采用的图形文件格式，在windows 环境下运行的所有图像处理软件都支持BMP 图像文件格式，windows 系统内部各图像绘制操作都是以BMP 为基础的</p>
<p>因此把这种BMP 图像文件格式称为设备相关位图 DDB 文件格式，<br>目的是为了人windows 能够在任何类型的显示设备上显示所存储的图像</p>
<p>bmp 位图文件默认的文件扩展名是bmp</p>
<p>BMP 格式结构</p>
<p>BMP 文件的数据按照从文件头开始的先后顺序分为四个部分</p>
<p>位图文件头，提供文件的格式 大小等信息</p>
<p>位图信息头 提供图像数据的尺寸，位平面数，压缩方式，颜色索引等信息</p>
<p>调色板 可选，如使用索引来表示图像，调色板就是索引与其对饮的颜色的映射表</p>
<p>位图数据 图像数据区</p>
<p>BMP图片文件数据表如下：</p>
<p>数据段名称<br>大小（byte）<br>开始地址<br>结束地址<br>位图文件头(bitmap-file header)<br>14<br>0000h<br>000Dh<br>位图信息头(bitmap-information header)<br>40<br>000Eh<br>0035h<br>调色板(color table)<br>由biBitCount决定<br>0036h<br>未知<br>图片点阵数据(bitmap data)<br>由图片大小和颜色定<br>未知<br>未知</p>
<p>三、BMP 文件头</p>
<p>BMP文件头结构体定义如下：<br>typedef struct tagBITMAPFILEHEADER<br>{<br>UINT16 bfType;        &#x2F;&#x2F;2Bytes，必须为”BM”，即0x424D 才是Windows位图文件<br>DWORD bfSize;         &#x2F;&#x2F;4Bytes，整个BMP文件的大小<br>UINT16 bfReserved1;  &#x2F;&#x2F;2Bytes，保留，为0<br>UINT16 bfReserved2;  &#x2F;&#x2F;2Bytes，保留，为0<br>DWORD bfOffBits;     &#x2F;&#x2F;4Bytes，文件起始位置到图像像素数据的字节偏移量<br>} BITMAPFILEHEADER;</p>
<p>BMP文件头数据表如下：</p>
<p>变量名<br>地址偏移<br>大小<br>作用说明<br>bfType<br>0000h<br>2Bytes<br>文件标识符，必须为”BM”，即0x424D 才是Windows位图文件<br>‘BM’：Windows 3.1x, 95, NT,…　　‘BA’：OS&#x2F;2 Bitmap Array　　‘CI’：OS&#x2F;2 Color Icon 　　<br>‘CP’：OS&#x2F;2 Color Pointer 　　‘IC’：OS&#x2F;2 Icon 　　<br>‘PT’：OS&#x2F;2 Pointer<br>因为OS&#x2F;2系统并没有被普及开，所以在编程时，你只需判断第一个标识“BM”就行<br>bfSize<br>0002h<br>4Bytes<br>整个BMP文件的大小（以位B为单位）<br>bfReserved1<br>0006h<br>2Bytes<br>保留，必须设置为0<br>bfReserved2<br>0008h<br>2Bytes<br>保留，必须设置为0<br>bfOffBits<br>000Ah<br>4Bytes<br>说明从文件头0000h开始到图像像素数据的字节偏移量（以字节Bytes为单位），以为位图的调色板长度根据位图格式不同而变化，可以用这个偏移量快速从文件中读取图像数据</p>
<p>四、BMP 信息头</p>
<p>BMP信息头结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tagBMP_INFOHEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD  biSize;    <span class="comment">//4Bytes，INFOHEADER结构体大小，存在其他版本I NFOHEADER，用作区分</span></span><br><span class="line">LONG   biWidth;    <span class="comment">//4Bytes，图像宽度（以像素为单位）</span></span><br><span class="line">LONG   biHeight;    <span class="comment">//4Bytes，图像高度，+：图像存储顺序为Bottom2Top，-：Top2Bottom</span></span><br><span class="line">WORD   biPlanes;    <span class="comment">//2Bytes，图像数据平面，BMP存储RGB数据，因此总为1</span></span><br><span class="line">WORD   biBitCount;         <span class="comment">//2Bytes，图像像素位数</span></span><br><span class="line">DWORD  biCompression;     <span class="comment">//4Bytes，0：不压缩，1：RLE8，2：RLE4</span></span><br><span class="line">DWORD  biSizeImage;       <span class="comment">//4Bytes，4字节对齐的图像数据大小</span></span><br><span class="line">LONG   biXPelsPerMeter;   <span class="comment">//4 Bytes，用象素/米表示的水平分辨率</span></span><br><span class="line">LONG   biYPelsPerMeter;   <span class="comment">//4 Bytes，用象素/米表示的垂直分辨率</span></span><br><span class="line">DWORD  biClrUsed;          <span class="comment">//4 Bytes，实际使用的调色板索引数，0：使用所有的调色板索引</span></span><br><span class="line">DWORD biClrImportant;     <span class="comment">//4 Bytes，重要的调色板索引数，0：所有的调色板索引都重要</span></span><br><span class="line">&#125;BMP_INFOHEADER;</span><br></pre></td></tr></table></figure>

<p>变量名<br>地址偏移<br>大小<br>作用说明<br>biSize<br>000Eh<br>4Bytes<br>BNP信息头即BMP_INFOHEADER结构体所需要的字节数（以字节为单位）<br>biWidth<br>0012h<br>4Bytes<br>说明图像的宽度（以像素为单位）<br>biHeight<br>0016h<br>4Bytes<br>说明图像的高度（以像素为单位）。这个值还有一个用处，指明图像是正向的位图还是倒向的位图，该值是正数说明图像是倒向的即图像存储是由下到上；该值是负数说明图像是倒向的即图像存储是由上到下。大多数BMP位图是倒向的位图，所以此值是正值。<br>biPlanes<br>001Ah<br>2Bytes<br>为目标设备说明位面数，其值总设置为1<br>biBitCount<br>001Ch<br>2Bytes<br>说明一个像素点占几位（以比特位&#x2F;像素位单位），其值可为1,4,8,16,24或32<br>biCompression<br>001Eh<br>4Bytes<br>说明图像数据的压缩类型，取值范围为：<br>0         BI_RGB 不压缩（最常用）<br>1         BI_RLE8 8比特游程编码（BLE），只用于8位位图<br>2         BI_RLE4 4比特游程编码（BLE），只用于4位位图<br>3         BI_BITFIELDS比特域（BLE），只用于16&#x2F;32位位图<br>4<br>biSizeImage<br>0022h<br>4Bytes<br>说明图像的大小，以字节为单位。当用BI_RGB格式时，总设置为0<br>biXPelsPerMeter<br>0026h<br>4Bytes<br>说明水平分辨率，用像素&#x2F;米表示，有符号整数<br>biYPelsPerMeter<br>002Ah<br>4Bytes<br>说明垂直分辨率，用像素&#x2F;米表示，有符号整数<br>biClrUsed<br>002Eh<br>4Bytes<br>说明位图实际使用的调色板索引数，0：使用所有的调色板索引<br>biClrImportant<br>0032h<br>4Bytes<br>说明对图像显示有重要影响的颜色索引的数目，如果是0，表示都重要。</p>
<p>BMP 调色板</p>
<p>BMP调色板结构体定义如下：<br>typedef struct _tagRGBQUAD<br>{<br>BYTE  rgbBlue;       &#x2F;&#x2F;指定蓝色强度<br>BYTE  rgbGreen;      &#x2F;&#x2F;指定绿色强度<br>BYTE  rgbRed;        &#x2F;&#x2F;指定红色强度<br> BYTE  rgbReserved;  &#x2F;&#x2F;保留，设置为0<br>} RGBQUAD;</p>
<p>1，4，8位图像才会使用调色板数据，16,24,32位图像不需要调色板数据，即调色板最多只需要256项（索引0 - 255）。<br>颜色表的大小根据所使用的颜色模式而定：2色图像为8字节；16色图像位64字节；256色图像为1024字节。其中，每4字节表示一种颜色，并以B（蓝色）、G（绿色）、R（红色）、alpha（32位位图的透明度值，一般不需要）。即首先4字节表示颜色号1的颜色，接下来表示颜色号2的颜色，依此类推。<br>颜色表中RGBQUAD结构数据的个数有biBitCount来确定，当biBitCount&#x3D;1,4,8时，分别有2,16,256个表项。<br>当biBitCount&#x3D;1时，为2色图像，BMP位图中有2个数据结构RGBQUAD，一个调色板占用4字节数据，所以2色图像的调色板长度为2<em>4为8字节。<br>当biBitCount&#x3D;4时，为16色图像，BMP位图中有16个数据结构RGBQUAD，一个调色板占用4字节数据，所以16像的调色板长度为16</em>4为64字节。<br>当biBitCount&#x3D;8时，为256色图像，BMP位图中有256个数据结构RGBQUAD，一个调色板占用4字节数据，所以256色图像的调色板长度为256*4为1024字节。<br>当biBitCount&#x3D;16，24或32时，没有颜色表。</p>
<p>BMP 图像数据区</p>
<p>位图数据记录了位图的每一个像素值，记录顺序是在扫描行内是从左到右,扫描行之间是从下到上。位图的一个像素值所占的字节数:<br>当biBitCount&#x3D;1时，8个像素占1个字节;<br>当biBitCount&#x3D;4时，2个像素占1个字节;<br>当biBitCount&#x3D;8时，1个像素占1个字节;<br>当biBitCount&#x3D;24时,1个像素占3个字节;<br>Windows规定一个扫描行所占的字节数必须是4的倍数(即以long为单位),不足的以0填充，<br>一个扫描行所占的字节数计算方法:</p>
<p>235.125<br>264 * 8  &#x3D; 2112  个像素<br>33 + 31<br>57 + 31</p>
<p>DataSizePerLine&#x3D; (biWidth* biBitCount+31)&#x2F;8;<br>&#x2F;&#x2F; 一个扫描行所占的字节数<br>DataSizePerLine&#x3D; DataSizePerLine&#x2F;4<em>4; &#x2F;&#x2F; 字节数必须是4的倍数<br>位图数据的大小(不压缩情况下):<br>DataSize&#x3D; DataSizePerLine</em> biHeight;</p>
<p>颜色表接下来位为位图文件的图像数据区，在此部分记录着每点像素对应的颜色号，其记录方式也随颜色模式而定，既2色图像每点占1位（8位为1字节）；16色图像每点占4位（半字节）；256色图像每点占8位（1字节）；真彩色图像每点占24位（3字节）。所以，整个数据区的大小也会随之变化。究其规律而言，可的出如下计算公式：图像数据信息大小&#x3D;（图像宽度<em>图像高度</em>记录像素的位数）&#x2F;8。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-USB协议简析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-USB%E5%8D%8F%E8%AE%AE%E7%AE%80%E6%9E%90/"
    >20221213-USB协议简析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-USB%E5%8D%8F%E8%AE%AE%E7%AE%80%E6%9E%90/" class="article-date">
  <time datetime="2022-12-13T07:41:21.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/431163780">https://zhuanlan.zhihu.com/p/431163780</a></p>
<p>USB 4将我的这种想法给部分实现，通过一种隧道技术的方式，将DP&#x2F;USB3&#x2F;PCIe信号集成到通信隧道里面去，接收端再通过数据包头来区分数据（这就有点像交换机里的数据分发，通过MAC地址或者报文帧头确定数据包目的地）。</p>
<p>因为硬件的局限性和可能的分发芯片性能功能问题，每个分发数据的协议速率是由各自的上限的，不能够动态调整每个接口的最大速度，</p>
<p>USB与I2C&#x2F;SPI&#x2F;UART类似，都是一种传输数据的协议规范，但USB主要设计是用于计算机与外接设备的数据交互和文件传输，这一点也正是它现在演变为相对高速的对外接口的原因，最高速的当然是PCIe。</p>
<p>特点</p>
<p>服务器交换机目前还是使用USB 2.0 居多</p>
<p>USB 3 开始和typeC 结合，将曾经的文件传输接口增加为文件加视频传输接口，并且视频一上来就是最新的DP 接口 </p>
<p>USB 4，这兄弟更猛，除了USB、DP，还额外增加了PCIe的功能，1 LANE支持到10Gbps，通过隧道技术来最大限度发挥物理带宽性能，这个还没有开始投向商用，应该还要一两年。</p>
<p>技术细节</p>
<p>USB 3.2 </p>
<p>就只有 type-C</p>
<p>pin location pin name function </p>
<p>USB2.0 数据信号4个，其实是两个，为了满足正反插需求所以正反都有</p>
<p>USB3.2 数据信号8个，包含两个通道的差分收发信号，VBUS 信号4个，GND 信号4个，一个8个信号处理电源<br>CC 信号两个，SBU 信号两个 </p>
<p>全称Configuration　Channel，分为CC1和CC2，在type C接口被引用，主要是为了解决正反插的信号交错问题和侦测插入的接口类型。</p>
<p>目前主要是在source端设计上拉电阻，sink端设计下拉电阻，通过不同电阻的配比来表示当前的设备类型和插入方式。具体方式比较复杂，参考type C spec里的两个截图，两个CC信号用来侦测正反插情况和设备信息。以后有机会调试CC信号再深入了解。</p>
<p>SBU信号是为USB 4.0 预留的，3.2里没有用到这个信号，不过这两个信号又在Alternate Mode（主要是DP）和Audio Adapter Accessory Mode里有使用，后面讲到这两个模式再具体分析。</p>
<p>信号完整性 </p>
<p>此时开始引入redriver 来解决信号完整性的问题</p>
<p>repeater 分为两种，redriver 和retimer</p>
<p>retimer 指的是这种器件包含有CDR 电路，可以重新编码信号，好处是不会引入一些高频抖动</p>
<p>Redriver 指的是器件使用模拟电路的方式来增强信号，不会对码流进行操作，中间会有均衡放大和发送的部分</p>
<p>一个链路中能够使用的repeater个数是没有限制的，只要总体的时延和抖动能够满足要求，但一般是sink和source端各自处理自己接口上的信号质量，能满足协议规范就可以了，如果是cable厂商，可能也需要在cable中集成一到两个repeater。</p>
<p>USB 4.0 </p>
<p>对于USB 4 来说，规定了一种可以同时传输三种通信协议的方式，但这是在芯片内部或者协议端实现的，物理层和逻辑层与所谓的通道互相独立，传输层和配置层需要针对通道方式做出改变</p>
<p>隧道技术采用了TMUS 来处理每一个交换功能，网上并不能看到太多有关这个技术的细节，但从上面的分析，有理由得出一下的猜测</p>
<p>TMUs位于芯片内部或者就是纯软件，与USB 4 协议是配套使用，在物理层和传输层没有体现<br>由第一点，如果device端是USB 4，则也需要集成TMU，如果只是三种协议中的一种，就要看host端是否有向下兼容的能力（USB3和DP是必须的，PCIe目前是可选）。<br>再来看下图就会对USB 4的整个拓扑有更多的了解。</p>
<p>简单来说，USB 4 host可以直接支持USB 3x，DP，PCIe的device；也可以通过USB Hub的方式去fan out直接输出USB 4隧道信号，让Hub来分发；更可以直接插入支持USB 4 的device来一根cable传输这三个协议的信号。</p>
<p>第一张图里有看到，不同的协议影响的是红圈中的设计，也即Adapter的选择；在USB 4的整个通信过程中，这些具体的协议是已经在比较上层的地方，所以对于不同协议的支持，需要做的有两点：</p>
<p>在USB 4 的block内有对应支持的协议种类的Adapter<br>在USB 4 与CPU更上层的连接中有对应的通信路径，例如PCIe需要有PCIe Switch或者链接到Root Port的Root Complex<br>当满足以上两点，从芯片对外提供的USB 4 interface上来看，它就可以支持所有的四种协议：USB 4，USB 3，DP，PCIe（目前只到Gen 1）,根据插入的设备类型做到向下兼容。</p>
<p>SBU 信号 </p>
<p>SBU 在usb4开始被引入，速度为1Mbps 有三个功能</p>
<p>配置USB4通道，进行初始化</p>
<p>和retimer进行交互，完成USB 4 Link TxFFE的握手<br>确保USB 4 通道的发送和retimer的上电或者wake up sequence的正确完成<br>与TMT3的兼容<br>Thunderbolt™ 3是Intel发布的Light Peak技术。Thunderbolt连接技术融合了PCI Express（PCI-E）数据传输技术和Display Port（DP）显示技术，可以同时对数据和视频信号进行传输。</p>
<p>具体细节不展开了，有一个点需要注意，当以兼容TMT3模式运行时，adapter需要在TBT3兼容的速度下运行，也即Gen 2 是10.3125Gbps，Gen 3 是20.625Gbps。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-数字芯片中使能信号的作用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-%E6%95%B0%E5%AD%97%E8%8A%AF%E7%89%87%E4%B8%AD%E4%BD%BF%E8%83%BD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/"
    >20221213-数字芯片中使能信号的作用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-%E6%95%B0%E5%AD%97%E8%8A%AF%E7%89%87%E4%B8%AD%E4%BD%BF%E8%83%BD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/" class="article-date">
  <time datetime="2022-12-13T07:18:15.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ol>
<li>什么是使能信号，</li>
</ol>
<p>所谓使能信号，英文叫enable 翻译成中文还有启用等意思</p>
<p>如图所示，当G1为低电平的时候，不管其它输入是什么。输出全为高电平。而当G2为高电平时（G2等于G2A与上G2B），不管其它输入是什么，输出也都一律为高电平。因此仅从功能上来判断，G1和G2就可以控制这颗芯片是不是被“启用”了。可以看出当G1为低或G2位高时，整个芯片的其它输入无论如何变化都不影响输出。简单的说就是整个芯片实际上没用发挥作用，功能没有“启用”。</p>
<ol start="2">
<li>为什么使能信号可以控制芯片的启用和停用</li>
</ol>
<p>全部都连到了最后一级的所有与非门上。我们知道一个与非门，如果有1个输入为0，那么这个与非门的输出就会是1。因此，如果不满足G1为高电平，G2A和G2B都为低电平这个条件，就会让所有输出全为1。而这时无论别的输入是什么，都不会让输出有任何改变。从这一点上来说，要启用这颗芯片的功能就必须满足G1为高电平，G2A和G2B都为低电平这个条件。否则，其它输入影响不了输出，芯片“译码”的功能就没有被“启用”。</p>
<ol start="3">
<li>为什么需要使能信号</li>
</ol>
<p>需要使能信号的主要原因是一个大型的数字系统中，通常都需要使用多个芯片&#x2F;电路单元来配合完成一个功能，而这些芯片并不是每时每刻都在工作，因此需要用使能信号来控制硬功启用那个芯片来工作</p>
<p>假设4bit的二进制编码从高到低依次是A3A2A1A0</p>
<p>将A2A1A0分别对应连接到两片74XX138上。而将A3连接到低位片的G2B上和高位片的G1上。</p>
<p>这样我们实际上把4bit的二进制数据划分为了2段</p>
<p>其中一段从0000到0111，另外一段从1000到1111。当现在A2A1A0为111时，低位片的Y7和高位片的Y7都有可能输出。而假设此时A3为0（此时输入为0111），那么低位片的所有使能信号均有效，而高位片的G1是无效的。那么此时低位片被启用而高位片未被启用。所以低位片的Y7输出为低而其它均为高，高位片的所有输出都是高。因此，0111被译码为了1111111101111111（输出低有效）。反之，A3为1（此时输入为1111）。则低位片的G2B无效而高位片所有的使能信号都有效。1111倍译码为0111111111111111</p>
<ol start="4">
<li>使能信号还有哪些用法</li>
</ol>
<p>使能信号的用途非常广泛，可以作为计算机系统中存储芯片选通信号，可以作为显式系统中的控制信号，但核心的一点就是使能信号控制了芯片的功能是否能被正常的启用，这在设计大型的数字系统中是非常重要的一环</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-RS485通讯基础及通讯应用详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-RS485%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%80%9A%E8%AE%AF%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"
    >20221213-RS485通讯基础及通讯应用详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-RS485%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%80%9A%E8%AE%AF%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-12-13T05:42:43.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/341845459">https://zhuanlan.zhihu.com/p/341845459</a></p>
<p>举例：plc向变频器从机1和变频器从机2传递数据，首先变频器从机1和变频器从机2设备之间必须通过电缆连接（硬件连接）。如果变频器从机1和变频器从机设备发送101010这样一串代码，那么变频器从机1就要在他的通讯端口产生如下图所示的高低电平的组合，通过电缆这个介质变频器从机2设备的通讯端口就会接收到A设备发出高低电平的组合，同时就会将接</p>
<h2 id="RS-485概述"><a href="#RS-485概述" class="headerlink" title="RS-485概述"></a>RS-485概述</h2><p>RS-485和RS-232一样，都是串行通信标准，现在的标准名称是TIA485&#x2F;EIA-485-A，但是人们会习惯称为RS-485标准，RS-485常用在工业、自动化、汽车和建筑物管理等领域。</p>
<p>RS-485总线弥补了RS-232通信距离短，速率低的缺点，RS-485的速率可高达10Mbit&#x2F;s，理论通讯距离可达1200米；RS-485和RS-232的单端传输不一样，是差分传输，使用一对双绞线，其中一根线定义为A，另一个定义为B。</p>
<p>双绞线</p>
<h2 id="RS-485物理层"><a href="#RS-485物理层" class="headerlink" title="RS-485物理层"></a>RS-485物理层</h2><p>RS-485的物理层负责在设备和物理传输介质之间传输原始数据。它处理电信号到数字数据的转换，同时定义电压、时序、数据速率等。</p>
<p>① 差分信号</p>
<p>长距离布线会有信号衰减，而且引入噪声和干扰的可能性更大，在线缆A和B上的表现就是电压幅度的变化，但是，采用差分线的好处就是，差值相减就会忽略掉干扰依旧能输出正常的信号，把这种差分接收器忽略两条信号线上相同电压的能力称为共模抑制。</p>
<p>标准规定了，逻辑1：+2V to +6V；逻辑0：-6V to -2V。</p>
<p>RS-485不需要使用特定的总线电压，只看最小差分电压，在较长的电缆长度上，接收器接收到的电压可能会降低到+&#x2F;- 200 mV，这对于RS-485仍然是完全可以接受的，这也是RS-485的优点之一。</p>
<p>很多收发器的标准达到甚至超过TIA&#x2F;EIA-485A规范，在实际使用中，以器件的SPEC参数为主，如下某收发器的负输入阈值最小也是-200mV。</p>
<p>② 信号定义</p>
<p>现在很多的RS-485转换器都是兼容RS-422的，所以看到很多转换器上面的信号都是T&#x2F;R+、T&#x2F;R-，即对应RS-485的A+和B-。</p>
<p>对于DB9针型的母头，RS-485有如下的接线定义示意，Pin6~Pin9为N&#x2F;A不接。</p>
<p>DB9 输出信号  RS-422全双工接线 RS-485半双工接线<br>1 T&#x2F;R+  发（A+） RS-485（A+）<br>2 T&#x2F;R-  发（B-） RS-485（B-）<br>3 RXD+  收（A+） 空<br>4 RXD-  收（B-） 空<br>5 GND 地线  地线</p>
<p>③ 拓扑结构</p>
<p>RS485有两线制和四线制两种接线，四线制只能实现点对点的通信方式，现很少采用，多采用的是两线制接线方式，这种接线方式为总线拓扑结构，在同一总线上最多可以挂接32个节点。</p>
<p>RS-485总线同I2C，也是主从模式，支持点对点单从机模式，也支持多从机模式，不支持多主机模式。</p>
<h2 id="RS-485收发器"><a href="#RS-485收发器" class="headerlink" title="RS-485收发器"></a>RS-485收发器</h2><p>RS-485是差分传输，如果用单片机控制RS-485接口的设备，需要用到收发器，这一点和CAN总线是类似的，如下是一个MCU控制一个RS-485的图示。</p>
<p>收发器内部是一个接收器（上半部分）加一个发送器（下半部分），下面简单说说收发器的原理，便于理解MCU是如何和485设备通信的。</p>
<p>RS-485收发器内部结构</p>
<p>其中：</p>
<p>A和B为总线；<br>R为接收器输入；<br>RE为接收器使能信号；<br>DE为发送器使能信号；<br>D为发送器输出；<br>对于使能信号，字母上面加一横的为低电平有效（如上图RE），不加的为高电平有效（如DE）。</p>
<p>对于发送器，有如下的真值表：</p>
<p>1、当驱动器使能引脚DE为逻辑高时，差分输出A和B遵循数据输入D处的逻辑状态。D处的逻辑高导致A转为高，B转为低。在这种情况下，定义为VOD&#x3D;VA-VB的差分输出电压为正。当D为低时，输出状态反转，B变高，A变低，VOD为负。</p>
<p>2、当DE低时，两个输出都变成高阻抗。在这种情况下，与D处的逻辑状态是不相关的。</p>
<p>发送器真值表</p>
<p>对于接收器，有如下的真值表：</p>
<p>1、当接收器使能引脚RE逻辑低时，接收器被激活。当定义为VID&#x3D;VA–VB的差分输入电压为正且高于正输入阈值VIT+时，接收机输出R变高。当VID为负且低于负输入阈值VIT-，接收机输出R变低。如果VID在VIT+和VIT-之间，则输出不确定。</p>
<p>2、当RE为逻辑高或悬空时，接收机输出为高阻抗，VID的大小和极性无关。</p>
<p>接收器真值表</p>
<h2 id="RS-485数据链路"><a href="#RS-485数据链路" class="headerlink" title="RS-485数据链路"></a>RS-485数据链路</h2><p>上面讲到的RS-485收发器的工作原理，下面简单描述RS-485的数据链路，可以先看一下通俗易懂的UART协议帧格式</p>
<p>主机发送给从机或者从机发送给主机，都会占用到A和B线，所以RS-485多用在半双工模式。</p>
<p>主机的GPIO会控制RS-485收发器的DE管脚，设置发送模式，从UART TXD线向RS-485收发器的数据（D或DI）线发送一个字节，收发器将在A和B线上将单端UART位流转换为差分位流，数据离开收发器后，主机立即将收发器的模式切换为接收模式。</p>
<p>从机和主机是类似的，从机控制RS-485收发器的&#x2F;RE管脚，设置为接收模式，接收主机发送的比特流，将其转换为单端信号，通过从机的UART RXD线接收，当从机准备好响应时，它按主机原来的方式进行发送，而主机变为接收。</p>
<h2 id="RS-232和RS-485转换"><a href="#RS-232和RS-485转换" class="headerlink" title="RS-232和RS-485转换"></a>RS-232和RS-485转换</h2><p>RS-232和RS-485之间可以转换，一个方法是RS-232转换成TTL，再由TTL转换为RS-485，当然也有芯片支持将RS-232直接转换成RS-485，网上有很多模块。</p>
<p>RS-232和RS-485转换模块</p>
<h2 id="RS-485和CAN的区别"><a href="#RS-485和CAN的区别" class="headerlink" title="RS-485和CAN的区别"></a>RS-485和CAN的区别</h2><p>虽说RS-485没有标准的数据协议格式，但和CAN总线在很多地方是有相似的，比如A&amp;B和CANH&amp;CANL都是差分信号，通信都需要收发器，都需要120欧姆的匹配电阻等等。</p>
<p>总线特性  CAN总线 RS-485总线<br>硬件成本  稍高  低廉<br>总线利用率 优先级自动仲裁，利用率高  采用轮询，利用率低<br>数据传输率 高 低<br>错误检测机制  控制器带校验机制，保证底层数据传输正确 只有物理层规范，无数据链路层规定<br>单节点故障影响 总线无影响 总线瘫痪<br>开发成本  软件开发灵活，时间成本低  开发难度较大<br>系统成本  较低  高</p>
<h2 id="RS-485常用电路"><a href="#RS-485常用电路" class="headerlink" title="RS-485常用电路"></a>RS-485常用电路</h2><p>网上找的一个常用的RS-485电路，其中需要注意两点：</p>
<p>1、使能信号RE和DE可采用一个GPIO控制，节省资源，GPIO25输出高电平，RE&#x3D;DE&#x3D;0V，进入接收模式；GPIO25输出低电平，RE&#x3D;DE&#x3D;3.3V，进入发送模式。</p>
<p>2、有一些电路中会在A上加上拉，B上加下拉电阻，主要原因是：RS-485总线在idle状态，电平是不固定的，即电平在-200mV~+200mV之间，收发器可能输出高也可能输出低，UART在空闲时需要保持高电平的，如果此时收发器输出一个低电平，对UART来说是一个start bit，会导致通信异常，关于Ru和Rd的阻值在这里不作过多赘述，后面有机会会详细写一篇文章。</p>
<p>关于第二点，需要注意：</p>
<p>① A上加上拉，B上加下拉，接反数据通信也可能出错。</p>
<p>② 某些收发器内部集成上下拉电阻，则外部不需要再添加。</p>
<p>今天的文章内容到这里就结束了，希望对你有帮助，我们下一期见。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-UART串口通信介绍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/"
    >20221213-UART串口通信介绍</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2022-12-13T04:16:06.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>串口通信 UART 介绍</p>
<p>通用异步收发传输器 ，通常称作UART ，是一种异步收发传输器</p>
<p>首先先来介绍一下同步和异步通信</p>
<p>在常见通信总线协议中，I2C SPI 属于同步通信而UART 属于异步通信</p>
<p>在UART 通信中，数据起始位和停止位是必不可少的</p>
<p>硬件层</p>
<p>常用RS-232标准，这里不详细解释，主要是对应设备的Tx 线和Rx 线要对应正确</p>
<p>协议层 </p>
<p>协议层中，规定了数据包的内容，它由起始位，主体数据，校验位以及停止位组成，通信双方的数据包格式要约定一致才能正常收发数据</p>
<p>波特率  异步通信中由于没有时钟信号，所以2个通信设备需约定好波特率，常见的有4800 9600 15200 等</p>
<p>通信的起始和停止信号，串口通信的一个数据包从起始信号开始，知道停止信号结束，数据包的起始信号由一个逻辑0 的数据位表示，而数据包的停止信号可由0.5 1 1.5 2 个逻辑1 的数据位表示，只要双方约定一致即可</p>
<p>有效数据，在数据包的起始位置之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为8位或9位长</p>
<p>数据校验  可以在传输过程中加上校验位来解决这个问题，校验方法有奇校验 偶校验 0校验 1校验 以及无校验</p>
<p>奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个 8 位长的有效数据为：01101001，此时总共有 4 个“1”，为达到奇校验效果，校验位为“1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位。偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4 个，所以偶校验位为“0”。0 校验是不管有效数据中的内容是什么，校验位总为“0”，1 校验是校验位总为“1”。</p>
<p>UART 功能框图剖析</p>
<p>这张图是当年上学时使用system C 对uart 建模的模块图，对于接口部分，重要的即为Tx Rx 数据输出，接受接口，clk 提供波特率生成模块的初始时钟信号，</p>
<p>有关控制器部分，在这里使用逻辑电路来实现，具体控制输出&#x2F;接收使能，设备使能等</p>
<p>在目前的微控制器上，数字电路控制部分已被封装，现在只需要操作对应寄存器的对应位即可实现对UART  的控制<br>下图是uart 框图 </p>
<p>波特率生成模块</p>
<p>USART 的发送器和接收器使用相同的波特率，有以下的计算公式</p>
<p>其中，fck为 USART 时钟， USARTDIV 是一个存放在波特率寄存器(USART_BRR)的一个无符号定点数。其中 DIV_Mantissa[11:0]位定义 USARTDIV 的整数部分，DIV_Fraction[3:0]位定义 USARTDIV 的小数部分。</p>
<p>例如：DIV_Mantissa&#x3D;24(0x18)，DIV_Fraction&#x3D;10(0x0A)，此时 USART_BRR 值为0x18A；那么USARTDIV的小数位10&#x2F;16&#x3D;0.625；整数位24，最终USARTDIV的值为24.625。</p>
<p>波特率的常用值有 2400、9600、19200、115200。下面以实例讲解如何设定寄存器值得到波特率的值。我们知道 USART1 使用APB2总线时钟，最高可达72MHz，其他USART的最高频率为36MHz。我们选取USART1作为实例讲解，即fck&#x3D;72MHz。为得到115200bps的波特率，此时：115200&#x3D;72000000&#x2F;(16∗USARTDIV)，解得USARTDIV&#x3D;39.0625，可算得DIV_Fraction&#x3D;0.0625*16&#x3D;1&#x3D;0x01，DIV_Mantissa&#x3D;39&#x3D;0x27，即应该设置USART_BRR的值为0x171。</p>
<p>数据寄存器</p>
<p>UART 数据寄存器 只有低9位有效，并且第9位 数据是否有效要取决于uart 控制寄存器1的M 位设置，当M 位为0 时表示8位数据字长，当M 位为1 表示9位数据字长，我们一般使用8位数据字长</p>
<p>USART_DR包含了已发送的数据或者接收到的数据。USART_DR实际是包含了两个寄存器，一个专门用于发送的可写TDR，一个专门用于接收的可读RDR。当进行发送操作时，往USART_DR写入数据会自动存储在TDR内；当进行读取操作时，向USART_DR读取数据会自动提取RDR数据。</p>
<p>TDR和RDR都是介于系统总线和移位寄存器之间。串行通信是一个位一个位传输的，发送时把TDR内容转移到发送移位寄存器，然后把移位寄存器数据每一位发送出去，接时把接收到的每一位顺序保存在接收移位寄存器内然后才转移到RDR。</p>
<p>UART支持DMA传输，可以实现高速数据传输(不经过CPU),使能UART的DMA功能需要将USART_CR1寄存器DMAT位置1。</p>
<p>控制器</p>
<p>UART 有专门控制发送的发送器，控制接收的接收器，还有唤醒单元，中断控制等，使用uart 之前需要向 usart_CR1 寄存器的ue位置使能UART UE 位用于开启供给串口的时钟</p>
<p>发送器</p>
<p>当USART_CR1寄存器的发送使能位TE置1时，启动数据发送，发送移位寄存器的数据会在TX引脚输出，低位在前，高位在后。</p>
<p>一个字符帧发送需要3部分，起始位 数据帧  停止位，起始位是一个位周期的低电平，位周期就是每一位占用的时间，数据帧就是我们要发送的8 或9 位数据，数据是最低位开始传输的，停止位是一定时间周期的高电平</p>
<p>停止位的时间长短可以通过UART控制寄存器2（USART_CR2）的STOP[1:0]位控制，可选0.5个、1个、1.5个、2个停止位。默认使用1个停止位。2个停止位适用于正常USART模式、单线模式和调制解调器模式。0.5和1.5个停止位用于智能卡模式。</p>
<p>当发使能位TE置1之后，发送器开始会发送一个空闲帧（一个数据帧长度的高电平），接下来就可以往USART_DR寄存器写入要发送的数据。在写入最后一个数据后，需等待UART状态寄存器（USART_SR）的TC位为1，表示数据传输完成。USART_CR1寄存器的TCIE位置1，则产生中断。</p>
<p>发送数据时，几个重要的标志位如下</p>
<p>TE 发送使能<br>TXE 发送寄存器为空，发送单个字节时使用<br>TC 发送完成，发送多个字节数据时候使用<br>TXIE 发送完成中断使能</p>
<p>接收器</p>
<p>将CR1寄存器的RE位置1，使能USART接收，使得接收器在RX线开始搜索起始位。在确定起始位后，就根据RX线电平状态把数据存放在接收移位寄存器内。接收完成后就把接收移位寄存器的数据移到PDR内，并把USART_SR寄存器的RXNE位置。如果USART_CR2寄存器的RXNEIE置1可以产生中断。</p>
<p>接收数据时，几个重要的标志位如下</p>
<p>RE 接收使能<br>RXNE:读数据寄存器非空。</p>
<p>RXNEIE:发送完成中断使能。</p>
<p>USART_CR1寄存器：<br>USART_CR2寄存器：<br>USART_CR3寄存器：</p>
<p>之后会基于STM32继续介绍怎样配置并使用UART，包括串口轮询&#x2F;中断&#x2F;DMA方式发送&#x2F;接收数据。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-VGA显示图像详细总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-VGA%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"
    >20221213-VGA显示图像详细总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-VGA%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2022-12-13T02:09:18.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44406200/article/details/103823607">https://blog.csdn.net/weixin_44406200/article/details/103823607</a></p>
<h2 id="VGA-显示原理"><a href="#VGA-显示原理" class="headerlink" title="VGA 显示原理"></a>VGA 显示原理</h2><p>VGA 概念</p>
<p>VGA 不是用来显示的那块屏幕，而是用来传输信号的接口，VGA 全称是video graphics array 及视频图形阵列，是模拟信号的一种视频传输标准，VGA 传输接口实物图如下</p>
<p>自测试 地址码 蓝基色  绿基色  红基色</p>
<p>数字地        蓝地  绿地   红地<br>地址码 场同步 行同步  地址码 地址码</p>
<p>操作VGA 的过程就是给你一块有横纵坐标范围的区域，区域上的每一个坐标点就是一个像素点，你可以做的事情是给这个像素点特定的rgb 色彩，既可以通过自定义rgb 也可以去取图像某个像素点的rgb ，这也就提供了你在vga 上画图以及显示图片的能力</p>
<p>VGA 分辨率及理解误区</p>
<p>640 * 480 的规格就是显示屏幕上每行有640 个像素点，总共有480行，注意，一件很重要的事情是，虽然你看到的屏幕上的大小是640 * 480 的 但是它实际大小并不只有那么点，形象一点就是说，VGA 的扫描范围是包含了你能够看到的640 480 这一块区域的更大区域，他会在周围一圈你看不到的区域部分进行扫描，因此，我们在处理扫描信号的时候一定要注意只有扫描到有效区域的时候才能把像素点数据传给 VGa 显示 </p>
<p>VGA 显示器扫描方式从屏幕左上角一点开始，从左向右逐点扫描，每扫描完一行，电子束回到屏幕的左边下一行的起始位置，在这期 间，CRT 对电子束进行消隐，每行结束时，用行同步信号进行同步，当扫描完所有的行，形成一帧，用场同步信号进行场同步，并使扫描回到屏幕左上方，同时进行场消隐，开始下一帧，完成一行扫描的时间称为水平扫描时间，其倒数称为行频率，完成一帧，扫描的时间称为垂直扫描时间，其倒数称为场频率，及屏幕的刷新频率，其扫描示意图如下图所示</p>
<p>有效显示区域</p>
<p>关于那一块非有效显示区域，实际上是因为每一行和每一列的扫描区间都是由以下几部分组成</p>
<p>行扫描  Hor Sync 、Hor Back Porch 、Hor Active Video和Hor Front Porch</p>
<p>Hor Scan Time 是一个扫描周期，它会先扫描到hor sync 再扫描 hor back porch 然后才进入有效显示区  hor active video 最后是一段 hor front porch 可以看出来，四段区间只有hor active video 这一段是能够正常显示图像信息的，也就是屏幕上显示的那一块区间</p>
<p>列扫描也同理</p>
<p>给定参数</p>
<p>实际上，根据固定的分辨率大小，比如我们实验室的板子使用的640 480 的屏幕大小，这些非有效区间的长度值都是一个固定的常数，因此你只要在扫描的时候把这些常数稍加处理即可</p>
<p>下图罗列了不同分辨率所对应的各个参数，其中的a、b、c、d、e、f、g、h、i、k的含义，与上面给出的两张图的标注一一对应；我们实验使用的是第一组数据，可以看到行时序参数中的c代表每一行的有效显示区间640，列时序参数中的h代表每一列的有效显示区间480</p>
<p>需要扫描频率，很重要的一件事，无论是行扫描还是给像素点赋值，我们都需要用一个时钟，这个时钟不是系统时针，必须要先将50MHZ 的时钟分频为25MHZ 然后拿去作为扫描信号的时钟</p>
<p>这一点是特别需要注意的，否则到时候会出现out of range 的现象</p>
<p>前期准备 coe 文件的生成</p>
<p>coe 和ip 核介绍</p>
<p>我们调用VGA 的终极目标是想要能够显示一张图片，在这之前，我们要先对这张图片进行一些预处理，因为我们是通过verilog 语言去调用图片数据的，但是verilog 并不知道怎么从一张已有的图片上去取相应的数据</p>
<p>因此我们要先将图片转换为coe 文件，coe 文件实际上就是按照某种规律将图像每一个像素点的rgb 数据都摆放成单独一行 16进制，然后借助ISE 的IP 核生成将coe 文件转化成ROM ，生成的ROM.xco 和ROM.v 文件就可以被verilog 语言所识别调用，最终就能够取到图像的数据了</p>
<p>24位bmp 图像转换为coe 文件 复原代码</p>
<p>为了统一规范，这里我们使用24位真彩色的bmp 格式图像进行转换，好处是，bmp 的三通道数据特征是非常明显的，易于处理</p>
<p>如何获取24位bmp 图像 </p>
<p>然后bmp 格式也有很多种，如单色 16色 24 256 ，这里我们统一选择24位位图选项，点击保存即可</p>
<p>使用matlab 将24位真彩色bmp 位图转化为coe 文件 </p>
<p>由于24位共rgb 三个通道，每个通道分到的是8位，占用资源太多，且老师给的ucf 引脚约束对rgb 每一个通道只给了4位，因此我们在转化为coe 文件的同时，要将每个通道压缩成4位，即整张图像同时转化为12位</p>
<p>压缩图像是一件非常重要的事情，因为经过后续的实践我们发现，板子内存资源有限，无法同时加载多张大图</p>
<p>为了能够对多张图像进行批量处理，我使用matlab 写了一个 img2coe.m 函数，只要对bmp 图像调用这个函数即可转换成coe 文件了，转换过程介绍如下</p>
<p>先将rgb 提取为三个通道，用reshape 函数对转置后的矩阵进行重组，对rgb 三个分量的数据都右移，舍去细节，留下高四位作为最终的数据，然后写入到coe 文件中</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">img2coe</span><span class="params">(path,name)</span></span></span><br><span class="line">    <span class="comment">% 利用imread函数把图片转化为一个三维矩阵</span></span><br><span class="line">    image_array = imread(path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 利用size函数把图片矩阵的三个维度大小计算出来</span></span><br><span class="line">    <span class="comment">% 第一维为图片的高度，第二维为图片的宽度，第三维为图片的RGB分量</span></span><br><span class="line">    [height,width,z]=<span class="built_in">size</span>(image_array);   </span><br><span class="line"></span><br><span class="line">    red   = image_array(:,:,<span class="number">1</span>); <span class="comment">% 提取红色分量，数据类型为uint8</span></span><br><span class="line">    green = image_array(:,:,<span class="number">2</span>); <span class="comment">% 提取绿色分量，数据类型为uint8</span></span><br><span class="line">    blue  = image_array(:,:,<span class="number">3</span>); <span class="comment">% 提取蓝色分量，数据类型为uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 把上面得到了各个分量重组成一个1维矩阵，由于reshape函数重组矩阵的</span></span><br><span class="line">    <span class="comment">% 时候是按照列进行重组的，所以重组前需要先把各个分量矩阵进行转置以后再重组</span></span><br><span class="line">    <span class="comment">% 利用reshape重组完毕以后，由于后面需要对数据拼接，所以为了避免溢出</span></span><br><span class="line">    <span class="comment">% 这里把uint8类型的数据扩大为uint32类型</span></span><br><span class="line">    r = uint32(<span class="built_in">reshape</span>(red&#x27;   , <span class="number">1</span> ,height*width));</span><br><span class="line">    g = uint32(<span class="built_in">reshape</span>(green&#x27; , <span class="number">1</span> ,height*width));</span><br><span class="line">    b = uint32(<span class="built_in">reshape</span>(blue&#x27;  , <span class="number">1</span> ,height*width));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 初始化要写入.coe文件中的RGB颜色矩阵</span></span><br><span class="line">    rgb=<span class="built_in">zeros</span>(<span class="number">1</span>,height*width);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 因为导入的图片是24-bit真彩色图片，每个像素占用24-bit，其中RGB分别占用8-bit</span></span><br><span class="line">    <span class="comment">% 而我这里需要的是12-bit，其中R为4-bit，G为4-bit，B为4-bit，所以需要在这里对24-bit的数据进行重组与拼接</span></span><br><span class="line">    <span class="comment">% bitshift()函数的作用是对数据进行移位操作，其中第一个参数是要进行移位的数据，第二个参数为负数表示向右移，为</span></span><br><span class="line">    <span class="comment">% 正数表示向左移，更详细的用法直接在Matlab命令窗口输入 doc bitshift 进行查看</span></span><br><span class="line">    <span class="comment">% 所以这里对红色分量先右移4位取出高4位，然后左移11位作为ROM中RGB数据的第11-bit到第8-bit</span></span><br><span class="line">    <span class="comment">% 对绿色分量先右移4位取出高4位，然后左移5位作为ROM中RGB数据的第7-bit到第4-bit</span></span><br><span class="line">    <span class="comment">% 对蓝色分量先右移4位取出高4位，然后左移0位作为ROM中RGB数据的第3-bit到第0-bit</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:height*width</span><br><span class="line">        rgb(<span class="built_in">i</span>) = bitshift(bitshift(r(<span class="built_in">i</span>),<span class="number">-3</span>),<span class="number">11</span>) + bitshift(bitshift(g(<span class="built_in">i</span>),<span class="number">-2</span>),<span class="number">5</span>) + bitshift(bitshift(b(<span class="built_in">i</span>),<span class="number">-3</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    fid = fopen( name , <span class="string">&#x27;w+&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">% .coe文件的最前面一行必须为这个字符串，其中16表示16进制</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;memory_initialization_radix=16;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% .coe文件的第二行必须为这个字符串</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;memory_initialization_vector =\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 把rgb数据的前 height*width-1  个数据写入.coe文件中，每个数据之间用逗号隔开</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;%x,\n&#x27;</span>,rgb(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 把rgb数据的最后一个数据写入.coe文件中，并用分号结尾</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;%x;&#x27;</span>,rgb(<span class="keyword">end</span>));</span><br><span class="line"></span><br><span class="line">    fclose( fid ); <span class="comment">% 关闭文件指针</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<p>中期准备 coe 转换为rom </p>
<p>经过上面的步骤我们已经得到了coe 文件</p>
<p>接下来就是把它转化成verilog 能够调用的rom 文件了 </p>
<p>在ISE 工程中，点击右键新建文件，选择ip 核生成 </p>
<p>选择Memories选项中的RAMs&amp;ROMs里的Block Memory Generator</p>
<p>然后进入到这个设置参数的界面</p>
<p>其中width代表你设置的图片数据是几进制，由于之前写coe的时候是用16进制写的，因此这里写16；depth表示图像的大小，即长乘宽，由于我使用的是640<em>480的图片，因此这里填207200(&#x3D;640</em>480)</p>
<p>当你的文件路径成功出现的时候，你就可以点击下方的generate生成了，当然这个generate也要很久很久，一般一张640 *480的图片要generate近一个小时左右才能生成</p>
<p>生成完毕的标志是creating结束，并且在你的目录下出现类型太阳的这个标记</p>
<p>后期调用与测试 </p>
<p>VGA 显示的过程中会遇到很多小bug 有些小bug 的原因你根本找不出，比如 out of range ，你只能静下心来慢慢调试仿真</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> TeX_baitu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="TeX_baitu blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>