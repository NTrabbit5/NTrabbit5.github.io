<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> TeX_baitu blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      


<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-20221220-HomeAssistant树莓派-小米篇"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/20/20221220-HomeAssistant%E6%A0%91%E8%8E%93%E6%B4%BE-%E5%B0%8F%E7%B1%B3%E7%AF%87/"
    >20221220-HomeAssistant树莓派-小米篇</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/20/20221220-HomeAssistant%E6%A0%91%E8%8E%93%E6%B4%BE-%E5%B0%8F%E7%B1%B3%E7%AF%87/" class="article-date">
  <time datetime="2022-12-20T05:29:21.000Z" itemprop="datePublished">2022-12-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>想要一统江湖，我们只需关心设备的传输协议即可</p>
<p>目前有一个简单粗暴的标准，即如果一个设备需要小米多功能网关才可以使用，一般来说它采用的是zigbee协议，那么只要网关接入了HA 就可以完美适配，而如果一个设备是独立接入网络的，比如米家的wifi 插座，扫地机器人，yeelight 灯具等等，我们则需要单独在hass 里接入它们</p>
<p>本篇教程将介绍将小米接入HA 的方法，如果你打算通过HB直连，请参考渣渣米大大的教程</p>
<p>表格使用 <a target="_blank" rel="noopener" href="https://docs.google.com/spreadsheets/d/1LI0n_aK-9TuKXrz-PPOAbVuaN8JUj70s5F0MyK8FtsM/edit?usp=sharing">Google SpreadSheet</a> 编辑，将会不断更新。国内朋友可访问『<a target="_blank" rel="noopener" href="https://www.jianguoyun.com/p/DYFO3Y8Qp5HMBhiQjzw">坚果云</a>』获取。<strong>在此欢迎各位派友向我提供支持信息或内容纠正，直接在表格内评论即可。</strong></p>
<p>下面我们以传输协议为划分标准，分别介绍小米设备接入智能家居系统的方法，详细完整的全系接入方法<br> <a target="_blank" rel="noopener" href="https://home-assistant.cc/component/xiaomi/">Home Assistant 中文文档</a>。</p>
<p><strong>需要提点的是，今后只要是Wifi的设备，都将通过 xiaomi_miio接入，Zigbee 设备则统一是 xiaomi_aqara。</strong></p>
<p>ZigBee 设备 网关类设备</p>
<p>以小米多功能网关第二代  为代表的网关类设备是大部分 米家 及 绿米 aqara zigbee 设备的联动基础，也是整个米家智能家居系统的核心，除多功能网关外，空调伴侣和Aqara 监控摄像头都具备网关功能</p>
<p>打开米家 app，连接设置多功能网关，点击进入网关页面，点击右上角「…」，进入「设置」。点击第二行「关于」，狂点空白处，便会跳出「局域网通信协议」以及「网关信息」。进入「局域网通信协议」，打开开关，记录下密码，这就是之后待填的「key」。回到上级页面，进入「网关信息」，记录下 mac 地址，这就是之后待填的「sid 或 mac」。</p>
<p>HA 0.50.0 及之后版本已经添加对米家平台的官方支持，我们只需要直接配置即可，如果之前有复制 custom_components 文件夹的同学，升级后请删除该文件夹</p>
<p>此设置适用于 HA 0.54.0版及之后</p>
<p>xiaomi_aqara:<br>  gateways:<br>      - mac: MAC 地址 （地址不带 “-“ 或 “:” ，行首的「-」必须保留）<br>        key: 通讯密码<br>如果你有多个网关，则按以下格式设定：</p>
<p>xiaomi_aqara:<br>  gateways:<br>    - mac: xxxxxxxxxxxx<br>      key: xxxxxxxxxxxxxxxx<br>    - mac: xxxxxxxxxxxx<br>      key: xxxxxxxxxxxxxxxx<br>重启后，HA 主界面将会自动识别网关及捆绑的所有设备。</p>
<p>Yeelight 灯具</p>
<p>yeelight 目前已经从小米独立出来，运作良好，原生支持google assistant 等平台， yeelight 在ha 中支持色温，色彩、亮度等控制，基本实现全品支持</p>
<p>配置前请先在yeelight app 中打开 局域网控制 LAN Control 服务器选择中国大陆，新加坡皆可，注意如果所选服务器与米家app 中不同，则设备无法接入米家app，但不影响在yeelight app 及ha 中的控制</p>
<p>之后重启HA 重启前请打开灯具，稍等积分中，确认一下设备是否已经被HA 自动识别添加，如果是的话，皆大欢喜，什么都无需再做了；如果没有，请打开configuration.yaml文件，在合适位置添加如下字段：</p>
<p>light:</p>
<ul>
<li>platform: yeelight<br>devices:<br>  192.168.1.25:              #Yeelight灯具ip<br>name: Living Room      #昵称<br>transition: 1000<br>use_music_mode: True #音乐随动模式，默认关闭<br>以上 2 个是最常见的具有统一平台的设备适配，下面是使用 WiFi 传输协议设备的具体配置方法：</li>
</ul>
<p>获取 token</p>
<p>所有的小米wifi 设备都必须先取得设备的token 方可接入HA ，以下简要介绍获取token 的方法之一，</p>
<p>首先在安装有node js 的电脑上安装miio 库</p>
<p>sudo npm install miio</p>
<p>之后，重置 待连小米设备的网络，使其产生wifi 热点，将电脑连接至该热点上，之后输入</p>
<p>miio –discover</p>
<p>即获取设备的token， 请集中保存，获取token 后，如需绑定米家 app 请直接在qpp 中添加设备，切勿继续重置设备，否则token 将重新生成，原有token 将失效</p>
<p>米家扫地机器人</p>
<p>HA 原生支持米家 和石头扫地机器人2nd 使用专门的类vacuum</p>
<p>按照上方教程获取扫地机的 token，之后在 configuration.yaml 中填入以下配置：</p>
<p>vacuum:</p>
<ul>
<li>platform: xiaomi_miio<br> name: ‘***’                    #昵称<br> host: 192.168.1.2            #ip<br> token: R@#RT$TFEW    #token</li>
</ul>
<p>空气净化器</p>
<p>HA 目前原生支持2代空气净化器，暂不支持pro 版</p>
<p>按照上方教程获取空气净化器的 token，之后在 configuration.yaml 中填入以下配置：</p>
<p>fan:</p>
<ul>
<li>platform: xiaomi_miio<br>name: Xiaomi Air Purifier 2<br>host: 192.168.130.66<br>token: YOUR_TOKEN</li>
</ul>
<p>空调伴侣</p>
<p>米家和aqarq 均发布了自己品牌的空调伴侣，除外观差异外，内核并无不同，，小米已于今日固件更新中开发空调伴侣的 局域网通信协议，空调控制和网关功能请分别使用各自插件接入，</p>
<p>另，目前插件仅支持部分空调品牌的部分预设模式，详见插件说明页，未支持的型号请自行抓包空调码。</p>
<p>Home Assistant 中空调伴侣以自定义组件的方式加入，此组件为爱好者 Mac_zhou 制作，欢迎大家前往 项目地址 点赞。</p>
<p>插件使用前需获取设备的 token：进入『米家』应用，点击空调伴侣，选择右上角『•••』—— 『关于』—— 狂点空白区域 —— 网关信息 “token&#x3D;xxxxxxx”即是 。</p>
<p>将 Github 中的对应文件放入文件夹，层级与 Github 中展示一致，之后在配置文件中增加以下配置：</p>
<p>climate:<br>    - platform: mi_acpartner<br>      name: mi_acpartner<br>      host: 10.0.0.234 #ip地址<br>      token: ****** #token<br>      target_sensor: sensor.temperature_158d00015aefc4 #温度传感器 ID<br>      target_temp: 26 #目标温度</p>
<p>组件由国人制作，readme 文件以中文书写，这里我就不再作变量说明了</p>
<p>wifi 插座及智能插线板</p>
<p>0.56.0的更新带来了插座的支持，接入前先获取设备的token<br>具体方法见前文。之后，在 configuraiton.yaml 添加如下设置：</p>
<p>switch:</p>
<ul>
<li>platform: xiaomi_miio<br>name: Original Xiaomi Mi Smart WiFi Socket<br>host: 192.168.130.59<br>token: YOUR_TOKEN<br>这英文简单得不能再简单了，我就不做变量说明了。</li>
</ul>
<p>净水器</p>
<p>小米净水器插件由 bit3725 制作，欢迎前往 项目 点赞~<br>使用方法：从 Github 下载 mi_water_purifier.py，放入 custom_components&#x2F;sensor&#x2F; 文件夹内（文件层级项目本身已经很清晰地给出了），在 configuration.yaml 添加如下设置：</p>
<p>sensor:</p>
<ul>
<li>platform: mi_water_purifier<br>host: YOUR_SENSOR_IP<br>token: YOUR_SENSOR_TOKEN<br>name: YOUT_SENSOR_NAME<br>接入后自动会生成几项相关的传感器数值，如果需要集中查看，请使用群组：</li>
</ul>
<p>group:</p>
<ul>
<li>xiaomi_water_purifier:<br>name: Xiaomi Water Purifier<br>icon: mdi:water<br>entities:<ul>
<li>sensor.tap_water</li>
<li>sensor.filtered_water</li>
<li>sensor.pp_cotton_filter</li>
<li>sensor.front_active_carbon_filter</li>
<li>sensor.ro_filter</li>
<li>sensor.rear_active_carbon_filter<br>PM 2.5 监测仪<br>PM 2.5 监测仪插件由 bit3725 制作，欢迎前往 项目 点赞~</li>
</ul>
</li>
</ul>
<p>使用方法：从 Github 下载 mi_air_quality_monitor.py，放入 custom_components&#x2F;sensor&#x2F; 文件夹内（文件层级项目本身已经很清晰地给出了），在 configuration.yaml 添加如下设置：</p>
<p>sensor:</p>
<ul>
<li>platform: mi_air_quality_monitor<br>host: YOUR_SENSOR_IP<br>token: YOUR_SENSOR_TOKEN<br>name: YOUT_SENSOR_NAME</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221220-HomeAssistant树莓派-设备接入篇"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/20/20221220-HomeAssistant%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%85%A5%E7%AF%87/"
    >20221220-HomeAssistant树莓派-设备接入篇</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/20/20221220-HomeAssistant%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%85%A5%E7%AF%87/" class="article-date">
  <time datetime="2022-12-20T03:43:23.000Z" itemprop="datePublished">2022-12-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在开始配置教程前，我先帮助大家捋一捋HASS 的配置框架</p>
<p>HASS配置框架</p>
<p>HASS的核心配置围绕configuration.yaml 文件展开，在这里你可以进行时区、度量单位、开发者模式、主题选择等等基础配置，淡然，最为重要的，你将在该文件内完成所有设备的接入 这也是本篇教程的重点</p>
<p>HASS 的运行以来一个个相对独立的功能组件，比如小米米家平台就可以视作一个组件，有些时候，部分设备或者功能仍未得到hass 的官方支持，你必须在主目录下新建自定义组件custom_components 文件夹，添加相关的设备支持文件</p>
<p>完成上述的文件修改，加上HB 的配置，你就可以自如控制所有智能家居设备了</p>
<p>然而，使用一段时间后，你可能觉得设备太多显示凌乱，想给界面换个风格，或者configuration.yaml 文件<br>看起来要炸了，此时，你会考虑把部分配置剥离出去形成独立的文件，<br>例如你开启了设备追踪功能，Device Tracker 那么HASS 将在主文件下自动生成known_devices.yaml 文件，你将在这里设置需要追踪的设备，</p>
<p>主文件设置</p>
<p>上一篇教程中我们已经打开了树莓派的 SMB 服务，现在我们通过 SMB 打开 HASS 主目录。<br>（macOS 在 FInder 左侧栏“共享的”接入，Windows 在 计算机-地址栏 里直接输入 &#x2F;&#x2F;树莓派地址 即可跳转)<br>打开configuration.yaml，文件默认包含如下内容，我们按需修改：</p>
<p>homeassistant:<br>  #经纬度<br>  latitude: 32.87336<br>  longitude: 117.22743<br>  #海拔<br>  elevation: 430<br>  #度量单位，默认米<br>  unit_system: metric<br>  #时区<br>  time_zone:Asia&#x2F;Shanghai<br>  #系统昵称，显示在主界面顶部<br>  name: Home</p>
<p>正常情况下，剩下的部分便无须变动了，现在添加雅虎天气服务</p>
<p>weather:</p>
<ul>
<li>platform: yweather<br>woeid:2151849</li>
</ul>
<p>其中，woeid是城市代码，打开雅虎天气官网输入城市后搜索，url的最后几位数字便是</p>
<p>保存 重启 hass</p>
<p>homebridge 设置</p>
<p>注意，如果添加了开机自启任务，勿重复运行homebridge 否则会出现端口占用错误</p>
<p>homebridge-homeassistant 插件版本为2.3.0 以上的，特别注意添加最后一行配置，否则家庭app 内设备为空</p>
<p>cd &#x2F;home&#x2F;pi&#x2F;.homebridge<br>sudo nano config.json<br>{<br>“bridge”: {<br>“name”: “Homebridge”,<br>“username”: “CC:22:3D:E3:CE:30”,     &#x2F;&#x2F;树莓派 mac 地址<br>“port”: 51826,     &#x2F;&#x2F;运行端口<br>“pin”: “123-45-678”    &#x2F;&#x2F;连接密码，自行设定<br>},<br>“platforms”: [<br>{<br>“platform”: “HomeAssistant”,<br>“name”: “HomeAssistant”,<br>“host”: “<a href="http://127.0.0.1:8123&quot;">http://127.0.0.1:8123&quot;</a>,     &#x2F;&#x2F;HA 运行的网址，可以是 ip 也可以是域名<br>“password”: “raspberry”,     &#x2F;&#x2F;HA 的 api_password，及密码，如有设置请添加<br>“supported_types”: [“automation”, “binary_sensor”, “climate”, “cover”, “device_tracker”, “fan”, “group”, “input_boolean”, “light”, “lock”, “media_player”, “remote”, “scene”, “sensor”, “switch”],<br>“default_visibility”: “visible”    &#x2F;&#x2F;特别注意此项<br>}<br>]<br>}</p>
<p>ctrl+x，y，回车。之后清除 Homebridge 的缓存：</p>
<p>sudo rm -rf &#x2F;home&#x2F;pi&#x2F;.homebridge&#x2F;persist&#x2F;<br>请大家记住此步指令，今后若出现重新配置 HA、HB 导致 iOS 设备无法识别新设备或树莓派的，大部分情况均可以使用此指令解决。</p>
<p>这样我们就完成了 Homebridge 的设置，重启Homebridge：</p>
<p>sudo systemctl restart homebridge</p>
<p>经过上述设置，我相信你的智能家居设备已经在ha 和hb 里稳定运转了，</p>
<p>首先，这个问题只存在 iOS 以及未来的 macOS 用户身上，因为只有你们可以使用 Siri，才可以痛并快乐着。 对于其他终端系统的用户而言，要么和设备厂家的 app 斗智斗勇，要么享受 HA 网页操控的快感，至于语音控制，就还需等待了。</p>
<p>其次，以米家设备为例，同是网关，HA 可以控制夜灯功能，获取光感数据，Homekit 则不能；而针对扫地机器人，HASS 的接入方法十分复杂，且现阶段只能实现开关功能，HB 的插件安装配置更为容易，且可以控制吸力……可以说两个平台之间没有绝对的胜者，都需要具体情况具体分析。个人认为大多数情况下，HA 对设备的支持更好，并且基于社群支持，跟进速度也更快。</p>
<p>设备追踪设置</p>
<p>HA 可以追踪同一路由器内网设备联网状态，我们转换一下思路，便可以利用这个系统判断家人是否在家等，非常方便</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">device_tracker:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">asuswrt</span> <span class="string">（按需填写，小米为“xiaomi”，Netgear为“netgear”，TP-LINK为“tplink”）</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="string">.xx.1</span> <span class="comment">#路由器Ip</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">*****</span> <span class="comment">#管理员账号</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">******</span> <span class="comment">#管理员密码</span></span><br><span class="line">    <span class="attr">track_new_devices:</span> <span class="literal">no</span> <span class="comment">#是否自动添加新设备</span></span><br></pre></td></tr></table></figure>

<p>不出意外，重启 HASS 后，主文件夹下便会自动生成 known_devices.yaml 文件，打开之后你会发现，系统已经自动为嗅探到的连接到路由器的设备添加了默认配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devicename:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">Friendly</span> <span class="string">Name</span> <span class="comment">#昵称</span></span><br><span class="line">  <span class="attr">mac:</span> <span class="string">EA:AA:55:E7:C6:94</span> <span class="comment">#mac地址</span></span><br><span class="line">  <span class="attr">picture:</span> <span class="string">https://home-assistant.io/images/favicon-192x192.png</span> <span class="comment">#图片icon: mdi:human-female #图标，和图片取一个设置</span></span><br><span class="line">  <span class="attr">track:</span> <span class="literal">yes</span> <span class="comment">#是否追踪</span></span><br><span class="line">  <span class="attr">hide_if_away:</span> <span class="literal">no</span> <span class="comment">#离开后是否自动隐藏</span></span><br></pre></td></tr></table></figure>

<p>在接下来的教程中，我将指导大家如何进行自动化配置，真正实现人工智能，摆脱遥控的束缚，更换主题，展现个性，设置简洁大方的控制面板等等</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221220-树莓派魔镜"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/20/20221220-%E6%A0%91%E8%8E%93%E6%B4%BE%E9%AD%94%E9%95%9C/"
    >20221220-树莓派魔镜</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/20/20221220-%E6%A0%91%E8%8E%93%E6%B4%BE%E9%AD%94%E9%95%9C/" class="article-date">
  <time datetime="2022-12-20T02:58:50.000Z" itemprop="datePublished">2022-12-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><p>树莓派3 魔镜的神经中枢</p>
<p>usb麦克风</p>
<p>显示屏 不论通过什么渠道取得的显示屏，在这里都建议自带hdmi 接口并侧面出口，剩下转接头的钱和空间，也方便未来背面走线</p>
<p>如果考虑入触摸屏建议一步到位，目前面向树莓派生产的触控屏最大能到10寸左右，价格在400至500元。加装触摸屏，务必要考虑好触摸类型，因为最上面还需要覆盖一块单透镜。建议优先使用红外触摸，有能力在外框安置感应条即可；其次压敏，但是要考虑镜子的导电性；压感在覆盖镜子的前提下，基本不可能实现。</p>
<p>驱动板+喇叭， LCD 屏需要加配高压条，一般来说近几年的屏幕都是LED 了，但还是要具体问题具体分析</p>
<p>单向透视镜</p>
<p>俗称原子镜，就是大家看的美剧里审讯室用的镜子，魔镜的“大脸”。目前，适配屏幕尺寸的单透镜需定制，价格较昂贵。定制时建议优先选择厚度较薄、透光率较强的镜面，否则会影响日间魔镜的展示效果。</p>
<p>囊中羞涩的派友也可使用镜面贴膜曲线救国，效果参考汽车车窗贴膜，但透视效果较差。</p>
<p>镜框</p>
<p>电源 </p>
<p>整套魔镜系统需要电源驱动的部件有树莓派，驱动板和显示屏，后两者并一体讨论，驱动板在外接喇叭的前提下，usb 供电接口无法为树莓派供电，因此必须独立供电树莓派，显示屏所需电源为12V5A 大家在购入电源适配器是务必看准电压电流、并兼顾走线，<br>有能力者，可手动并线</p>
<p>可选材料</p>
<p>智能插座</p>
<p>超短HDMI 线</p>
<p>工具  螺丝刀  电工胶布，泡棉胶</p>
<p>显然，大部分的工作都集中在底层，我们需要把树莓派、驱动板等等部件合理安置在显示屏背部</p>
<p>喇叭布置于头部，直立后出声位置位于上方，更具现实感。树莓派布置在底端，保证USB麦克风的收音效果，且方便拿取。中部安放驱动板，方便走线。<br>这里省略了一步操作，建议先将驱动板随附的控制板连接至驱动板，选定输入源、调整好音量后拔下，以节约背板空间。</p>
<p>上述工作完成后，依次将单透镜和显示屏置入镜框内，扣入夹片固定好，避免松动。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221219-HomeAssistant智能家居系统搭建指南"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/19/20221219-HomeAssistant%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"
    >20221219-HomeAssistant智能家居系统搭建指南</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/19/20221219-HomeAssistant%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" class="article-date">
  <time datetime="2022-12-19T09:16:41.000Z" itemprop="datePublished">2022-12-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Home assistant 是一个成熟完整的基于python 的智能家居系统，设备支持度高，支持自动化 automation 群组化，ui 客制化等等高度定制化设置，背后又有庞大的社群基础，且不断更新，最重要的是我们可以通过homeassistant-homebridge 插件打通两个平台，同样实现设备的siri 控制，整套体系的框架如下</p>
<p>本系列将围绕安装，配置、开发等内容，详细介绍HASS 平台的方方面面，同时针对HASS 与hb 兼容与选择，自动化配置方法等等问题给出自己的观点和探索</p>
<p>HASS 支持大部分平台，简而言之，只要你的主机能跑python 基本就能安装hass 配合魔镜项目，以及便捷性的考虑，<br>本系列教程也将基于树莓派展开</p>
<p>初始安装</p>
<p>在树莓派安装HASS 有2种方法供选择</p>
<p>以其他操作系统，（这里以树莓派 官方系统 raspbian 为例） 为根系统，再通过指令安装</p>
<p>直接安装集成了HASS 的hassbian 操作系统</p>
<p>以上2种方法从性能上来说并无二异，均能实现hass全部功能，hassbian 实际上亦基于raspbian 唯一需要纳入考虑的是图形化操作界面的需求。由于树莓派基金官方尚未公开单独安装图形化操作界面的方法，在当下，如果有该需求，只能通过官方图形化操作系统 raspbian with desktop 实现</p>
<p>方法1<br>安装前，请参考 <a href="https://link.zhihu.com/?target=https://sspai.com/user/714086">梓姵君</a> 的 <a href="https://link.zhihu.com/?target=https://sspai.com/post/38542">文章</a> 对树莓派进行初始基础设置，重点关注地区、WiFi、源替换的内容，这里不再展开，特别注意，2016年11月 后的官方系统默认关闭ssh 功能，请务必打开</p>
<p>使用任何方法连接到树莓派终端、输入以下安装代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -O https://raw.GitHubusercontent.com/home-assistant/fabric-home-assistant/master/hass_rpi_installer.sh &amp;&amp; sudo <span class="built_in">chown</span> pi:pi hass_rpi_installer.sh &amp;&amp; bash hass_rpi_installer.sh</span><br></pre></td></tr></table></figure>
<p>注意，不要以sudo 运行，然后泡杯茶，做点别的事情，等待程序跑完，安装时间根据网络情况不等，大约需要1-2 个小时，国内网络环境大家自行改善</p>
<p>如果你是使用此方法安装hass 的话，未来更新指令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo su -s /bin/bash homeassistant</span><br><span class="line"><span class="built_in">source</span> /srv/homeassistant/homeassistant_venv/bin/activate</span><br><span class="line">pip3 install --upgrade homeassistant</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>方法2 </p>
<p>参考 copriwolf 的</p>
<p><a href="https://link.zhihu.com/?target=https://sspai.com/post/39851">教程</a></p>
<p>使用 Etcher 安装官方最新</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/home-assistant/pi-gen/releases/latest">固件</a></p>
<p>镜像。</p>
<p>感谢少数派友 <strong>DJ</strong> 千辛万苦的搬运至<a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/1dFpaaAH">度娘盘</a>（password: 2e98）</p>
<p>要注意的是，hassbian 初次启动时需要联网进行原始设置，由于无法在初次启动前设置无限网络，因此务必将树莓派与电脑或者路由器有线连接起来，以保证树莓派在有网环境下顺利设置</p>
<p>官方教程告知初次启动需要等待5分钟左右，基于国内的网络环境，我这里测试多次，都需要等待近10分钟，所以大家不要焦躁，可以看部番剧或者往下研究一下此篇文章以便接下来顺利进展。</p>
<p>如果等待时间过久却没有出现初始界面，可尝试使用以下命令强制初始安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> install_homeassistant.service</span><br><span class="line">sudo systemctl start install_homeassistant.service</span><br></pre></td></tr></table></figure>

<p>如果使用此方法，未来更新指令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop home-assistant@homeassistant.service</span><br><span class="line">$ sudo su -s /bin/bash homeassistant</span><br><span class="line">$ <span class="built_in">source</span> /srv/homeassistant/bin/activate</span><br><span class="line">$ pip3 install --upgrade homeassistant</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ sudo systemctl start home-assistant@homeassistant.service</span><br></pre></td></tr></table></figure>


<p>无论使用哪种方法，等待过后，在浏览器输入 http:&#x2F;&#x2F;树莓派的ip 地址:8123 查找树莓派ip 地址可以直接前往路由器界面</p>
<p>如果出现类似下图，则表示初始安装完成，如若没有出现界面，或者无法连接，有很大可能是尚未安装完毕，不要着急再等等，注意地址冒号为英文字符，请勿输入中文冒号</p>
<p>Hassbian 安装注意，初次启动请等待安装出现以下界面，再进行后续操作，否则你的一切工作都是前功尽弃，并且除此启动时，勿SSH ，勿输入任何代码，保持通电，联网，静置状态，非常重要</p>
<p>macOS</p>
<p>macos 自带python，如果你不小心误删，请先重新安装，macos 下安装hass 也相当简单</p>
<p>pip3 install homeassistant</p>
<p>附加功能</p>
<p>SMB 必须</p>
<p>SMB 可以帮助我们开启树莓派的网盘模式，方便未来文件传输，这里我们除安装外把该功能加入了系统自启项目</p>
<p>通用安装指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba </span><br><span class="line">sudo smbpasswd -a homeassistant -n</span><br><span class="line">sudo nano /etc/samba/smb.conf</span><br><span class="line">[global]</span><br><span class="line">netbios name = raspberrypi</span><br><span class="line">server string = The Pi File Center</span><br><span class="line">workgroup = WORKGROUP</span><br><span class="line">hosts allow =</span><br><span class="line">remote announce =</span><br><span class="line">remote browse <span class="built_in">sync</span> =</span><br><span class="line">[HOME ASSISTANT]</span><br><span class="line">path = /home/homeassistant/.homeassistant</span><br><span class="line">comment = No comment</span><br><span class="line">browsable = <span class="built_in">yes</span></span><br><span class="line"><span class="built_in">read</span> only = no</span><br><span class="line">valid <span class="built_in">users</span> =</span><br><span class="line">writable = <span class="built_in">yes</span></span><br><span class="line">guest ok = <span class="built_in">yes</span></span><br><span class="line">public = <span class="built_in">yes</span></span><br><span class="line">create mask = 0777</span><br><span class="line">directory mask = 0777</span><br><span class="line">force user = homeassistant</span><br><span class="line">force create mode = 0777</span><br><span class="line">force directory mode = 0777</span><br><span class="line">hosts allow =</span><br></pre></td></tr></table></figure>

<p>Ctrl+X，Y，回车</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart smbd.service</span><br></pre></td></tr></table></figure>

<p>hassbian 提供了一个附加功能工具包hassbian-config 这使我们的安装更加简单，使用工具包安装原则上已经自动配置好一切，建议大家还是修改一下权限和密码</p>
<p>安装指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hassbian-config install samba</span><br><span class="line">sudo smbpasswd -a pi</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart home-assistant@homeassistant.service</span><br></pre></td></tr></table></figure>

<p>2.2 MQTT<br>MQTT 是基于二进制消息的发布，订阅编程模式的消息协议，广泛用于物联网部署中，部分智能家居设备需要MQTT 连接</p>
<p>通用安装指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mosquitto mosquitto-clients python-mosquitto</span><br><span class="line">sudo systemctl start mosquitto</span><br></pre></td></tr></table></figure>

<p>hassbian 工具包安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hassbian-config install mosquitto</span><br><span class="line">sudo systemctl start mosquitto</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Homebridge 安装<br>HASS 本身可以通过网页控制，这也赋予了其全平台的控制能力，当然，想必不少人还是冲着语言控制功能考虑智能家居的，对于ios 用户来说，想要更自由地使用homekit HB依然是绕不开的环节</li>
</ol>
<p>HB 的安装我就更不多说了，欢迎大家参考另外几篇文章，这里我根据之前指导派友的经验简单概括一下。</p>
<p>HB 提供一行安装指令：sudo npm install -g –unsafe-perm homebridge 但是安装成功率比较低，推荐大家使用下面的手动安装指令。</p>
<p>sudo apt-get install git make<br>sudo apt-get install g++<br>curl -sL <a target="_blank" rel="noopener" href="https://deb.nodesource.com/setup_7.x">https://deb.nodesource.com/setup_7.x</a> | sudo -E bash -<br>sudo apt-get install -y nodejs<br>sudo apt-get install libavahi-compat-libdnssd-dev<br>sudo npm install -g –unsafe-perm homebridge hap-nodejs node-gyp<br>cd &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;homebridge&#x2F;<br>（注意这里如果显示不存在文件夹，替换成 cd &#x2F;usr&#x2F;lib&#x2F;node_modules&#x2F;homebridge&#x2F;)<br>sudo npm install –unsafe-perm bignum<br>cd &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;hap-nodejs&#x2F;node_modules&#x2F;mdns<br>（注意这里如果显示不存在文件夹，替换成 cd &#x2F;usr&#x2F;lib&#x2F;node_modules&#x2F;hap-nodejs&#x2F;node_modules&#x2F;mdns）<br>sudo node-gyp BUILDTYPE&#x3D;Release rebuild</p>
<p>运行到这里，HB就已经安装完成了，这里建议大家直接输入homebridge 运行一次，以生成示例配置文件，然后ctrl+C退出</p>
<p>接着，安装homeassistant-homebridge 插件，实现平台联动</p>
<p>sudo npm install -g homebridge-homeassistant</p>
<ol start="4">
<li>添加自启任务</li>
</ol>
<p>忙活了那么久，即将大功告成了，最后临门一脚，我们把HASS和HB 添加至树莓派开机任务中，这样每次启动后就会自动运行上述2个进程</p>
<p>注意：配置 HB 前程序会运行错误，提示缺少配置文件，可先不理会。</p>
<p>cd &#x2F;<br>sudo useradd –system homebridge<br>sudo mkdir &#x2F;var&#x2F;homebridge<br>sudo cp ~&#x2F;.homebridge&#x2F;config.json &#x2F;var&#x2F;homebridge&#x2F;<br>sudo cp -r ~&#x2F;.homebridge&#x2F;persist &#x2F;var&#x2F;homebridge<br>sudo chmod -R 0777 &#x2F;var&#x2F;homebridge<br>cd &#x2F;etc&#x2F;default<br>sudo nano homebridge 复制粘贴</p>
<h1 id="Defaults-x2F-Configuration-options-for-homebridge"><a href="#Defaults-x2F-Configuration-options-for-homebridge" class="headerlink" title="Defaults &#x2F; Configuration options for homebridge"></a>Defaults &#x2F; Configuration options for homebridge</h1><h1 id="The-following-settings-tells-homebridge-where-to-find-the-config-json-file-and-where-to-persist-the-data-i-e-pairing-and-others"><a href="#The-following-settings-tells-homebridge-where-to-find-the-config-json-file-and-where-to-persist-the-data-i-e-pairing-and-others" class="headerlink" title="The following settings tells homebridge where to find the config.json file and where to persist the data (i.e. pairing and others)"></a>The following settings tells homebridge where to find the config.json file and where to persist the data (i.e. pairing and others)</h1><p>HOMEBRIDGE_OPTS&#x3D;-U &#x2F;var&#x2F;homebridge</p>
<h1 id="If-you-uncomment-the-following-line-homebridge-will-log-more"><a href="#If-you-uncomment-the-following-line-homebridge-will-log-more" class="headerlink" title="If you uncomment the following line, homebridge will log more"></a>If you uncomment the following line, homebridge will log more</h1><h1 id="You-can-display-this-via-systemd’s-journalctl-journalctl-f-u-homebridge"><a href="#You-can-display-this-via-systemd’s-journalctl-journalctl-f-u-homebridge" class="headerlink" title="You can display this via systemd’s journalctl: journalctl -f -u homebridge"></a>You can display this via systemd’s journalctl: journalctl -f -u homebridge</h1><h1 id="DEBUG-x3D"><a href="#DEBUG-x3D" class="headerlink" title="DEBUG&#x3D;*"></a>DEBUG&#x3D;*</h1><p>Ctrl+X，Y，回车</p>
<p>cd &#x2F;etc&#x2F;systemd&#x2F;system<br>sudo nano homebridge.service<br>复制粘贴</p>
<p>[Unit]<br>Description&#x3D;Node.js HomeKit Server<br>After&#x3D;syslog.target network-online.target<br>[Service]<br>Type&#x3D;simple<br>User&#x3D;homebridge<br>EnvironmentFile&#x3D;&#x2F;etc&#x2F;default&#x2F;homebridge<br>ExecStart&#x3D;&#x2F;usr&#x2F;lib&#x2F;node_modules&#x2F;homebridge&#x2F;bin&#x2F;homebridge $HOMEBRIDGE_OPTS<br>Restart&#x3D;on-failure<br>RestartSec&#x3D;10<br>KillMode&#x3D;process<br>[Install]<br>WantedBy&#x3D;multi-user.target<br>Ctrl+X，Y，回车</p>
<p>cd &#x2F;<br>sudo systemctl daemon-reload<br>sudo systemctl enable homebridge<br>sudo systemctl start homebridge<br>sudo systemctl status homebridge<br>sudo systemctl enable mosquitto</p>
<p>最后重启，sudo reboot</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221219-microPython是什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/19/20221219-microPython%E6%98%AF%E4%BB%80%E4%B9%88/"
    >20221219-microPython是什么</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/19/20221219-microPython%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2022-12-19T08:11:09.000Z" itemprop="datePublished">2022-12-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>microPython是什么</p>
<p>先了解一下，什么是python</p>
<p>python 是一种简单易用的，能够运行在多个平台下的计算机编程语言</p>
<p>microPython 是跑在mcu 微控制器上的python，通过内置的解释器执行py 文件或者py 命令，就可以让微控制器运行您想要的功能了，microPython 和python 编程语言一样，在任何板子上都可以使用通用的api 控制硬件底层，比如点亮LED 灯，读取传感器信息，LCD 显示字符串，控制电机、连接网络、连接蓝牙等等</p>
<p>如果说Arduino让创客摆脱了各种编程环境配置，那么micropython直接让创客摆脱了底层。命令行和解释执行，都是C语言所不具备的优势，运行micropython的soc，就类似一台完整的电脑，我们用python文件和命令行，轻松控制这台电脑中的一切。</p>
<p>micropython 是人们连接各种任务的黏合剂，即便您不懂编程，不懂硬件，也可以通过它来控制mcu 要给microPython </p>
<p>microPython诞生啦！</p>
<p>Damien George是一名计算机工程师，他每天都要使用Python语言工作，同时也在做一些机器人项目。有一天，他突然冒出了一个想法：能否用Python语言来控制单片机，进行实现对机器人的操控呢？</p>
<p>要知道，Python是一款比较容易上手的脚本语言，而且有强大的社区支持，一些非计算机专业领域的人都选它作为入门语言。遗憾的是，它不能实现一些非常底层的操控，所以在硬件领域并不起眼。</p>
<p>Damien为了突破这种限制，他花费了六个月的时间来打造Micro Python。它基于ANSI C，语法跟Pyton 3基本一致，拥有自家的解析器、编译器、虚拟机和类库等。目前它支持基于32-bit的ARM处理器，比如说pyboard（STM32F405），支持NRF51822（micro:bit）、支持FireBeetle-ESP32、支持WiPy、支持ESP8266核心主控、支持CC3200等等。</p>
<p>pyload 是microPython 官方出的一款支持microPython 的微控制器，采用stm32f405rg MCU主芯片，邮票孔设计，体积小巧<br>在性能方面，pyboard除了将stm32f405rg本身的外设延用出来，还拓展了微型SD卡插槽、三周加速度计（mma7660）。在小巧的pyboard上，设有29个GPIO，4个LED灯，板载3.3V LDO电源管理芯片，可以提供高达250mA的电流，3.6~16V的宽电压输入。</p>
<p>micro:bit</p>
<p>micro：bit是由英国广播公司BBC推出的可编程微型计算机，可以帮助用户学习基础编程知识。它最大的亮点在于支持图形化编程，支持microPython编程。micro：bit主控采用nrf51822芯片作为主控，IC包括256KB片上闪存，16KB RAM，32位ARM®Cortex™ M0 CPU，支持Bluetooth低功耗，在低功耗模式下，最低功耗可以达到0.6uA。</p>
<p>FireBeetle-ESP32</p>
<p>FireBeetle-ESP32全称是FireBeetle Board-ESP32微控制器，是由DFRobot基于Espressif ESP32主芯片开发的物联网、低功耗为控制器。FireBeetle-ESP32板载ESP-WROOM-32双核芯片，支持WiFi和蓝牙双模通信，外围兼容低功耗硬件设计，深度睡眠模式下功耗仅为10uA。FireBeetle-ESP32控制器还提供了3.7V锂电池接口，并可以通过USB口给锂电池充电。其次，在软件方面，已经支持WiFi和蓝牙功能的使用，支持I2S音频的解码，结合uPyCraft IDE，可以轻松完成物联网开发设计。值得说明的是，本书的microPython教程是基于FireBeetle-ESP32控制器硬件。</p>
<p>WiPy</p>
<p>WiPy是支持microPython编程、支持WiFi和蓝牙的开发板，定位于物联网应用的设计。WiPy控制器的核心采用Espressif ESP32芯片，其最大的特点在于体积小巧，支持蓝牙和WiFi，这点和DFRobot的FireBeetle萤火虫系列主板相似。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221219-固件firmware固件与驱动的区别"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/19/20221219-%E5%9B%BA%E4%BB%B6firmware%E5%9B%BA%E4%BB%B6%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"
    >20221219-固件firmware固件与驱动的区别</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/19/20221219-%E5%9B%BA%E4%BB%B6firmware%E5%9B%BA%E4%BB%B6%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2022-12-19T03:12:53.000Z" itemprop="datePublished">2022-12-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0222686c0fb4">https://www.jianshu.com/p/0222686c0fb4</a></p>
<p>固件 firmware 就是写入EROM 可擦写只读存储器，或者EEPROM 电可擦写可编程只读存储器中的程序</p>
<p>固件是指设备内部保存的设备驱动程序，通过固件，操作系统才能按照标准的设备驱动实现特定机器的运行运作，比如 光驱、刻录机 等都有内部固件</p>
<p>固件是担任着一个系统最基础最底层工作的软件，而在硬件设备中，固件就是硬件设备的灵魂，因为一些硬件设备除了固件以外没有其他软件组成，因此固件也就决定了这硬件设备的功能以及性能</p>
<p>手机、数码相机、mp3、mp4、路由器、电子书、交换机、猫、PSP、PS3、NDS、XBOX、U盘、主板、打印机的BIOS（BIOS就是一种固件）、显卡的BIOS。</p>
<p>固件既然是软件，就有大小之分，大的可有几百兆，小的也许只有几K 甚至不足1k</p>
<p>而对于非独立的电子产品，比如硬盘、鼠标 bios 光驱、是、盘等设备，固件就是指其最底层的，让设备得以运行的程序代码</p>
<p>固件与驱动的区别</p>
<p>驱动和固件都是代码，前者为软件服务，后者为硬件服务</p>
<p>随着计算机体系结构的发展，硬件的种类开始变多，操作系统的种类也变多了，这个时候，因为各种技术的、商业的原因，硬件厂商希望自己的硬件能被更多的软件厂商使用，所以就需要在硬件之上做一些封装，让自己的硬件操纵起来更容易，这个时候就要有 firmware 这种东西了，它简化了软件与硬件的交互</p>
<p>但是为什么不把firmware 做的很完美，做的不需要驱动支持呢？因为有不同的操作系统</p>
<p>不同的操作系统，对于操作硬件的方式完全不同，在windows 里应用态是无法直接写io 端口的，而在嵌入式系统里，一般都不限制直接操作io 端口，所以，硬件厂商一方面为了自己的硬件能被软件更简单的使用，就需要写firmware ，而另一方面为了兼容各种操作系统，又不能把firmware 写的太死，必须预留足够的余地让软件自由发挥，软件的自由发挥就是驱动</p>
<p>不同操作系统的驱动是不能兼容的，原因就是驱动是为操作系统服务的，有的操作系统是单线程的，有些操作系统不允许动态申请内存，所以不同的操作系统要操作硬件，就要根据自身的特性编写对应的操作代码，这就是驱动存在的意义–适应系统需要</p>
<p>假如世界上只有一种操作系统，并且版本永远不会改变，那么firmware 和驱动就可以融合在一起，但这只能是一个不现实的梦想，要知道民用操作系统和工业控制操作系统差别是十分巨大的</p>
<p>从计算机领域来说，驱动和固件从来没有过明确的定义，就好像今天我们说内存，大部分人用来表示SDRAM 但也有人把android 里的固化的flash storage 称为内存，你不能说这样说就错了，因为这确实是一种内部存储</p>
<p>但在linux kernel 中，driver 和firmware 是有明确含义的，其中 driver 是控制被操作系统管理的外部设备 device 的代码段，很多时候 driver 会被实现为LKM 但这不是必要条件，driver 通过 register_driver 注册到总线上，当某个device 被注册到同样的总线的时候，driver 和device 会通过一定的策略进行binding ，最终在probe 函数中由driver 实际控制对应的设备，并把对该设备的控制接口注册到linux 的其他子系统上</p>
<p>而 firmware，是表示运行在非 控制处理器 （指不直接运行操作系统的处理器，例如外设中的处理器，或者被用于bare metal 的主处理器的其中一些核） 中的程序，这些程序很多时候使用和操作所运行的处理器完全不同的指令集，这些程序以二进制形式存在于linux内核的源代码树中，根据配置，可以直接集成到最终的映像中，或者被拷贝到指定的位置，当driver 对device 进行初始化的时候，通过load_firmware 等接口，可以把指定的firmware 加载到内存中，由驱动传输到指定的设备上</p>
<p>所以，总的来说，其实 driver 和firmware 没有什么直接的关系</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221218-MQTT入门介绍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/18/20221218-MQTT%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"
    >20221218-MQTT入门介绍</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/18/20221218-MQTT%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2022-12-18T11:10:42.000Z" itemprop="datePublished">2022-12-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>MQTT 消息对流遥测传输协议，是一种基于发布&#x2F;订阅 模式的轻量级 通讯协议，该协议构建于TCP&#x2F;IP 协议上，由IBM在1999年发布，MQTT 最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务，作为一种低开销、低带宽的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用</p>
<p>MQTT 是一个基于客户端-服务器的消息发布&#x2F;订阅传输协议，MQTT 协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛，在很多情况下，如机器与机器 M2M 通信和物联网 IoT ，其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居 、及一些小型化设备中已广泛使用</p>
<p>二、设计规范</p>
<p>由于物联网的环境是非常特别的，所以MQTT 遵循以下设计原则</p>
<p>精简 不添加可有可无的功能</p>
<p>发布&#x2F;订阅 模式 方便消息在传感器之间传递</p>
<p>允许用户动态创建主题，零运维成本</p>
<p>把传输量降到最低以提高传输效率</p>
<p>把低带宽、高延迟、不稳定的网络等因素考虑在内</p>
<p>支持连续的会话控制</p>
<p>理解客户端计算能力可能很低</p>
<p>提供服务质量管理</p>
<p>假设数据不可知，不强求传输数据的类型与格式，保持灵活性</p>
<p>三、主要特性</p>
<p>MQTT 协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的，它具有以下主要的几项特性</p>
<p>使用发布&#x2F;订阅消息模式，提供一对多的消息发布，解除应用程序耦合</p>
<p>这一点很类似于XMPP ，但是MQTT 的信息冗余远小于XMPP ，因为XMPP 使用XML 格式文本来传递数据</p>
<p>对负载内容屏蔽的消息传输</p>
<p>使用TCP&#x2F;IP 提供网络连接</p>
<p>主流的MQTT 是基于TCP 连接进行数据推送的，但是同样有基于UDP 的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了</p>
<p>有三种消息发布服务质量</p>
<p>“至多一次”，消息发布完全依赖底层TCP&#x2F;IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p>
<p>至少一次，确保消息到达，但消息重复可能会发生</p>
<p>只有一次，确保消息到达一次，在一些要求比较严格的计费系统中，可以使用此级别，在计费系统中，消息重复或丢失会导致不正确的结果，这种最高质量的消息发布服务还可以用于即时通讯类的app 的推送，确保用户收到且只会收到一次</p>
<p>小型传输，开销很小，固定长度的头部是2字节  协议交换最小化，以降低网络流量</p>
<p>这就是为什么在介绍里说它非常适合 在物联网领域，传感器与服务器的通信，信息的收集，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了</p>
<p>使用last will 和testament 特性通知有关各方客户端异常中断的机制</p>
<p>last will 即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接</p>
<p>testament 遗嘱机制，功能类似于last will</p>
<p>四、MQTT 协议原理<br>MQTT 协议实现方式</p>
<p>实现MQTT 协议需要客户端和服务端通讯完成，在通讯过程中，MQTT 协议中有三种身份，发布者，代理（服务器），订阅者。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者<br>MQTT 传输的消息分为 主题topic 和负载 payload 两部分</p>
<p>topic 可以理解为消息的类型，订阅者 subscribe 后，就会收到该主题的消息内容 payload<br>payload 可以理解为消息的内容，是指订阅者具体要使用的内容</p>
<p>网络传输与应用消息</p>
<p>MQTT 会构建底层网络传输，它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。当应用数据通过MQTT 网络发送时，MQTT 会把与之相关的服务质量 QoS 和主题名topic 相关联</p>
<p>MQTT 客户端</p>
<p>一个使用MQTT 协议的应用程序或者设备，它总是建立到服务器的网络连接，客户端可以</p>
<p>发布其他客户端可能会订阅的信息</p>
<p>订阅其他客户端发布的消息</p>
<p>退订或删除应用程序的消息</p>
<p>断开与服务器连接</p>
<p>MQTT 服务器<br>MQTT 服务器以称为消息代理，可以是一个应用程序或一台设备，它是位于消息发布者和订阅者之间，它可以</p>
<p>接受来自客户的网络连接</p>
<p>接受客户发布的应用信息</p>
<p>处理来自客户端的订阅和退订请求</p>
<p>向订阅的客户转发应用程序消息</p>
<h2 id="MQTT-协议中的订阅、主题、会话"><a href="#MQTT-协议中的订阅、主题、会话" class="headerlink" title="MQTT 协议中的订阅、主题、会话"></a>MQTT 协议中的订阅、主题、会话</h2><p>订阅<br>订阅包含主题筛选器和最大服务质量，订阅会与一个会话关联，一个会话可以包含多个订阅，每一个会话中的每个订阅都有一个不同的主题筛选器</p>
<p>会话<br>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互，会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接</p>
<p>主题名</p>
<p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配，服务器会将消息发送给订阅所匹配标签的每个客户端</p>
<p>主题筛选器</p>
<p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题</p>
<p>负载</p>
<p>消息订阅者所具体接收的内容</p>
<h2 id="MQTT-协议中的方法"><a href="#MQTT-协议中的方法" class="headerlink" title="MQTT 协议中的方法"></a>MQTT 协议中的方法</h2><p>MQTT 协议中定义了一些方法，也被称为动作，来于表示对确定资源所进行操作，这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现，通常来说，资源指服务器上的文件或输出，主要方法有</p>
<p>connect 等待与服务器建立连接</p>
<p>Disconnect 等待MQTT 客户端完成所做的工作，并与服务器断开TCP&#x2F;IP 会话</p>
<p>subscribe 等待完成订阅</p>
<p>unsubscribe 等待服务器取消客户端的一个或多个topics 订阅 </p>
<p>publish MQTT 客户端发送消息请求，发送完成后返回应用程序线程</p>
<h2 id="五、MQTT-协议数据包结构"><a href="#五、MQTT-协议数据包结构" class="headerlink" title="五、MQTT 协议数据包结构"></a>五、MQTT 协议数据包结构</h2><p>在MQTT 协议中，一个MQTT 数据包由 固定头 可变头，消息体 三部分构成，MQTT 数据包结构如下</p>
<p>固定头（fixed header） 存在于所有MQTT 数据包中，表示数据包类型及数据包的分组类标识</p>
<p>可变头（variable header） 存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容</p>
<p>消息体 （payload） 存在于部分MQTT数据包中，表示客户端收到的具体内容</p>
<p>MQTT 固定头 </p>
<p>固定头存在于所有MQTT 数据包中，其结构如下</p>
<p>MQTT 数据包类型 </p>
<p>位置 byte 1 中bits 7-4<br>相于一个4位的无符号值，类型，取值及描述如下</p>
<p>标识位</p>
<p>位置：Byte 1中bits 3-0。</p>
<p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p>
<p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p>
<p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p>
<p>RETAIN 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就报这消息推送给它，如果没有那么推送至当前订阅者后释放</p>
<p>剩余长度 </p>
<p>地址Byte 2</p>
<p>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的，这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识，当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p>
<p>MQTT 可变头</p>
<p>MQTT 数据包中包含一个可变头，它驻位于固定的头和负载之间，可变头的内容因数据包类型而不同，较常的应用是作为包的标识。<br>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p>
<p>Payload 消息体</p>
<p>Payload 消息体位MQTT 数据包的第三部分，包含connect subscribe suback unsubscribe 四种类型的消息</p>
<p>connect 消息体内容主要是 客户端的clientID 订阅的topic message 以及用户名和密码</p>
<p>subscribe 消息体内容是一系列的要订阅的主题以及QoS</p>
<p>suback 消息体内容是服务器对于subscribe 所申请的主题及QoS 进行确认和回复</p>
<p>unsubscribe 消息体内容是要订阅的主题</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221217-电子电路元器件列表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/17/20221217-%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E5%88%97%E8%A1%A8/"
    >20221217-电子电路元器件列表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/17/20221217-%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E5%88%97%E8%A1%A8/" class="article-date">
  <time datetime="2022-12-17T04:54:57.000Z" itemprop="datePublished">2022-12-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-科创大赛启发"><a href="#1-科创大赛启发" class="headerlink" title="1 科创大赛启发"></a>1 科创大赛启发</h2><p>（1）围棋棋子筛选</p>
<blockquote>
<p>TCS3200颜色传感器</p>
</blockquote>
<p>（2）语音识别模块</p>
<blockquote>
<p>WEGASUN-M6</p>
</blockquote>
<p>（3）图形化语言编程</p>
<blockquote>
<p>机械控制部分采用Micro-BIT单片机模块</p>
</blockquote>
<p>（4）无线六路开关量模块</p>
<blockquote>
<p>L24YK</p>
</blockquote>
<p>（5）RDWORKS平面设计软件</p>
<p>（6）Arduino开发板</p>
<p>（7）温度传感器</p>
<blockquote>
<p>DT11、DS18B20</p>
</blockquote>
<p>（8）红外对管传感器</p>
<p>（9）实时时钟模块</p>
<blockquote>
<p>DS1320</p>
</blockquote>
<p>（10）加速度传感器</p>
<p>（11）Android 手机APP编写</p>
<blockquote>
<p>Android Studio 3.5平台、Android SDK、Eclipse、Jave</p>
</blockquote>
<p>（12）物联网无线网络遥控</p>
<blockquote>
<p>ESP8266</p>
</blockquote>
<p>（13）气体传感器</p>
<blockquote>
<p>Q2</p>
</blockquote>
<p>（14）陀螺仪</p>
<p>（15）光敏传感器</p>
<p>（16）单片机</p>
<blockquote>
<p>STC51、STM32、MSP430F149</p>
</blockquote>
<p>（17）放大器放大电流</p>
<blockquote>
<p>LM324</p>
</blockquote>
<p>（18）图像处理</p>
<blockquote>
<p>Open CV软件</p>
</blockquote>
<p>（19）霍尔开关</p>
<p>（20）图像处理</p>
<p>（21）无线遥控装置</p>
<blockquote>
<p>433MHZ</p>
</blockquote>
<p>（22）人体红外线感应传感器</p>
<blockquote>
<p>PIR</p>
</blockquote>
<p>（23）Android小程序</p>
<p>（24）Robot C编程</p>
<h2 id="2-开发过程中用到的元器件"><a href="#2-开发过程中用到的元器件" class="headerlink" title="2 开发过程中用到的元器件"></a>2 开发过程中用到的元器件</h2><p>（1）USB转串口芯片CH340G</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221217-TX-RX通信模块笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/17/20221217-TX-RX%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%E7%AC%94%E8%AE%B0/"
    >20221217-TX-RX通信模块笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/17/20221217-TX-RX%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-12-17T04:51:07.000Z" itemprop="datePublished">2022-12-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>T 代表 Transmit<br>R 代表 Receive<br>X 代表交叉，也就是说A 方的TX 接B方的RX  B 放的TX 接A 放的RX</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221217-低功耗蓝牙BLE学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/17/20221217-%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99BLE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >20221217-低功耗蓝牙BLE学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/17/20221217-%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99BLE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-12-17T04:38:23.000Z" itemprop="datePublished">2022-12-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="http://doc.iotxx.com/BLE%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98">http://doc.iotxx.com/BLE%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98</a></p>
<p>蓝牙4.0 版本分两种模式，单模蓝牙 和双模蓝牙</p>
<p>常见的蓝牙音箱，是典型的双模蓝牙，它需要传输大量的音频数据，而小米手环，蓝牙温度计则属于单模蓝牙，行业里一般不讲单模蓝牙，而是统一称为低功耗蓝牙</p>
<p>蓝牙5.0 已经发布和应用，4倍通信速度，2倍的通信距离以及Mesh 组网特性，将使蓝牙成为物联网领域的重要的技术之一</p>
<ol>
<li>蓝牙简介</li>
</ol>
<p>蓝牙是一种近距离无线通信技术，运行在2.4GHz免费频段，目前已大量应用于各种移动终端，物联网，健康医疗，智能家居等行业。蓝牙4.0以后的版本分为两种模式，单模蓝牙和双模蓝牙。</p>
<p>单模蓝牙  即低功耗蓝牙模式，是蓝牙4.0 中的重点技术，低功耗，块连接，长距离</p>
<p>双模蓝牙，支持低功耗蓝牙的同时还兼容经典蓝牙，经典蓝牙的特点是大数据高速率，例如音频、视频等数据传输。</p>
<p>经典蓝牙支持音频（HFP&#x2F;HSP, A2DP）和数据（SPP, HID等）两大类协议，在音箱，耳机，汽车电子及传统数传行业，由于苹果对经典蓝牙数据传输接口有限制（需要过MFI认证），加上功耗偏大，因此在目前移动互联应用中慢慢地被边缘化。因此低功耗蓝牙顺势而出，由于可支持苹果4S以上及安卓4.3系统以上的数据传输，且功耗极低，目前正在被越来越多的移动互联设备所采用，但低功耗蓝牙不支持音频协议，并且受数据传输速度限制，其应用也被限制在小数据传输行业。</p>
<p>蓝牙双模则是综合了两者的优缺点，既可以支持音频传输，同样可支持数据传输，并且兼容性也是两者之和，在对功耗要求不苛刻的情况下，是比较理想的选择</p>
<p>2 BLE特点</p>
<p>低功耗蓝牙瞄准多个市场，特别是移动智能终端，智能家居，互联设备等领域，主要特点包括</p>
<p>低功耗<br>快连接<br>远距离</p>
<p>为低功耗蓝牙定义了一些标准Profile ，Profile 理解为数据规范，只要遵守该规范，任意厂家的蓝牙设备，均可以相互连接与通信，例如无线蓝牙键盘鼠标，无论是安卓或是iOS还是Windows，均是即插即用，这便是“标准”的力量。低功耗蓝牙支持的标准Profile有：</p>
<p>HID 用于无线鼠标，键盘或其他遥控设备</p>
<p>BatteryServices 电池状态服务，用于告知电池电量状态</p>
<p>HRP 心率计，Profile 用于心率 采集，等等</p>
<p>另外，低功耗蓝牙还可以自定义Profile ，伴随着智能手机的发展和普及，低功耗蓝牙的这个特性得到了发扬光大，同时也拓宽了低功耗蓝牙的应用领域。例如，可以自定义一个开关量的Profile，数据01表示开灯，数据00表示关灯，然后手机发送数据01和00就可以控制灯的亮和灭。类似的应用案例有很多，下面总结应用特点</p>
<p>支持自定义Profile ，可以收发任意格式的数据，如01 和 00<br>支持自定义设备，支持任意设备的连接和通信，例如 只能蓝牙插座等等</p>
<p>提示：低功耗蓝牙的Profile均基于GATT（通用属性规范，后面会详解）之上，如HID over GATT。也就是说，经典蓝牙中的HID规范与低功耗蓝牙中的HID规范用的是两个不同的通道。</p>
<p>BLE 工作流程<br>为后面的低功耗蓝牙协议的学习准备基础</p>
<p>角色</p>
<p>BLE 设备角色主要分为两种角色，主机和从机，，当主机和从机建立连接之后才能相互收发数据</p>
<p>主机，主机可以发起对从机的扫描连接，例如手机，通常作为BLE 的主机设备</p>
<p>从机，从机只能广播并等待主机的连接，例如智能手环，是作为BLE 的从机设备</p>
<p>另外还有观察者和广播者，这两种角色不常使用，但也十分有用，例如iBeacon 就可以使用广播者 角色来做，只需要广播特定内容即可</p>
<p>观察者，观察者角色监听空中的广播事件，和主机的区别是不能发起连接，只能持续扫描从机</p>
<p>广播者 广播者可以持续广播信息，和从机的唯一区别是不能被主机连接，只能广播数据</p>
<p>蓝牙协议栈没呀限制设备的角色范围，同一个BLE 设备，可以作为主机，也可以作为从机，我们称之为主从一体，主从一体的好处是，每个BLE 设备都是对等的，可以发起连接，也可以被别人连接，更加实用</p>
<p>广播</p>
<p>广播是指从机没经过一个时间间隔发送一次广播数据包，这个时间间隔称为广播间隔，这个广播动作叫做广播事件，只有当从机处于广播状态时，主机从能发现该从机</p>
<p>在每个广播事件中，广播包会分别在37 38 和 39 三个信道上依次广播，如下所示</p>
<p>广播时间间隔的范围是从20ms到10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。</p>
<p>另外BLE 链路层会在两个广播事件之间添加0-10 ms 的随机演示，保证多个设备广播时，不会一直碰撞广播，也就是说，设置100ms 的广播间隔，实际上两次广播事件的时间间隔可能是100-110 ms 之间的任意时间</p>
<p>广播数据包最多能携带31个字节的数据，一般包含可读的设备名称，设备是否可连接等信息</p>
<p>当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播 扫描回应 数据包，扫描回应数据包和广播包一样，可以携带31个字节的数据</p>
<p>提示：蓝牙4.x，广播有效载荷最多是31个字节。而在蓝牙5.0中，通过添加额外的广播信道和新的广播PDU，将有效载荷增加到了255个字节</p>
<ol start="3">
<li>扫描</li>
</ol>
<p>扫描是主机监听从机广播数据包和发送扫描请求的过程，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信</p>
<p>扫描动作由两个比较重要的时间参数，扫描窗口 和扫描间隔，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态中，持续监听从机广播包</p>
<p>被动扫描，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层 也就是应用层，用户可编程  传递广播包</p>
<p>主动扫描，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作 扫描回应 的广播包</p>
<p>主动扫描比被动扫描，可以多收到扫描回应数据包</p>
<p>连接</p>
<p>在BLE 连接中，使用调频方案，两个设备在特定时间、特定频道上彼此发送和接收数据，这些设备稍后在新的通道（协议栈的链路层处理通道切换）上通过这个约定的时间相遇，这次用于收发数据的相遇称为连接事件，如果没有有发送或接收的应用数据，则交换链路层数据来维护连接，两个连接事件之间的时间跨度称为连接间隔，是以1.25ms 为单位，范围从最小值 7.5 ms 到最大值 4.0s</p>
<p>连接参数</p>
<p>Connection Interval 连接间隔，两次连接事件之间的时间间隔称为连接间隔，1.25ms 为单位，范围从最小值 7.5 ms 到最大值 4.0s</p>
<p>slave latency 从机延迟，如果从机没有要发送的数据，则可以跳过连接事件，继续保持睡眠节省电量</p>
<p>supervision Time-out 监控超时，是两次成功连接事件之间的最长时间，如果在此时间内没有成功的连接事件，设备将终止连接并返回到未连接状态，该参数值以10ms 为单位，监控超时值可以从最小值10 到3200 超时必须大于有效的连接间隔</p>
<p>连接参数更新请求</p>
<p>连接参数由主机发起连接的时候提供，如果从机对连接参数有自己的要求，例如要求更低的功耗，或者更高的通信速率等，从机可以向主机发送连接参数更新请求</p>
<p>从机可以在连接后的任何时候发起连接参数更新请求，但最好不要在主从建立连接后like发起，建议延迟5s 左右再发送请求</p>
<p>连接参数更新请求可以修改：Connection Interval连接间隔，Slave Latency从机延迟，Supervision Time-out监控超时。</p>
<p>有效连接间隔</p>
<p>effective connection interval 有效连接间隔等于两个连接事件之间的时间跨度，假设从机跳过最大数量的连接事件，且允许从机延迟，</p>
<p>从机延迟表示可以跳过的最大事件数。该数字的范围可以从最小值0（意味着不能跳过连接事件）到最大值499。最大值不能使有效连接间隔（见下列公式）大于16秒。间隔可以使用以下公式计算：</p>
<p>Effective Connection Interval &#x3D; (Connection Interval) × (1 + [Slave Latency])</p>
<p>Consider the following example:</p>
<p>Connection Interval: 80 (100 ms)<br>Slave Latency: 4<br>Effective Connection Interval: (100 ms) × (1 + 4) &#x3D; 500 ms</p>
<p>当没有数据从从机发送到主机时，从机每500ms 一个连接事件交互一次</p>
<p>ios 对连接参数的要求<br>不同的平台对有连接间隔有着不同的要求，例如ios 系统对ble 的连接间隔有着如下的要求</p>
<p>Interval Max * (Slave Latency + 1) &lt;&#x3D;2s<br>Interval Min &gt;&#x3D;20ms<br>Interval Min + 20 ms &lt;&#x3D; Interval Max<br>Slave Latency &lt;&#x3D; 4<br>SupervisionTimeout &lt;&#x3D; 6 s<br>Interval Max * ( Slave Latency + 1) * 3 &lt; SupervisionTimeout</p>
<p>连接参数的优化考量</p>
<p>在许多应用中，从机跳过最大连接事件数，选择正确的连接参数组在低功耗蓝牙设备的功率优化中起重要作用，以下列表给出了连接参数设置中权衡的总体概述</p>
<p>减少连接间隔如下</p>
<p>增加两个设备的功耗<br>增加双向吞吐量<br>减少任一方向发送数据的时间</p>
<p>增加连接间隔如下<br>降低两个设备的功耗<br>降低双向吞吐量<br>增加任一方向发送数据的时间</p>
<p>减少从机延迟 或将其设置为零 如下<br>增加外围设备的功耗<br>减少外围设备接收从中央设备发送的数据的时间</p>
<p>增加从机延迟如下<br>在周边没有数据发送期间，可以降低外设的功耗到主机设备<br>增加外设设备接收从机设备发送的数据的时间</p>
<p>通信</p>
<p>通俗的说，我们将从机具有的数据或者属性特征，称之为profile 可以翻译为配置文件</p>
<p>从机中添加profile 配置文件，作为GATT 的server 端，主机作为GATT 的client 端</p>
<p>profile 包含一个或者多个service 每个service 又包含一个或者多个characteristic 主机可以发现和获取从机的service 和characteristic 然后与之通信，characteristic 是主从通信的最小单元</p>
<p>主机可主动向从机write 写入或read 读取数据</p>
<p>从机可主动向主机notify 通知数据</p>
<p>注意，这里引用了服务 service 和特征值 characteristic 的概念，每个服务和特征值都有自己的唯一标识uuid 标准UUID 为128位，蓝牙协议栈中一般采用16位，也就是两个字节的UUID 格式</p>
<p>一个从机设备包括一个或者多个服务，一个服务中又可以包括一条或者多条特征值，每个特征值都有自己的属性 property 属性的取值有 可读 read 可写 write 以及通知 notify</p>
<p>可读可写的字面意思容易理解，表示该特征值可以被主机读取和写入数据</p>
<p>而通知则表示从机可以主动向主机发送通知数据，这便是主从机之间两个典型的通信方式</p>
<p>下图是一个典型的从机设备，该从机包含有一个profile 两个service 和五个characteristic 我们先来介绍这些特征值的作用，然后介绍如何通过特征值通信</p>
<p>服务0x180A </p>
<p>180A 是蓝牙协议里标准的服务uuid，用来描述设备信息device information，可以通过该服务，来提供从机设备的相关说明，例如硬件版本，软件版本，序列号等信息，这样，主机就可以获取从机的设备信息，上图中我们添加了三个提供具体设备信息的特征值，他们分别是</p>
<p>特征值0x2A24，描述产品型号 Model Number String，例如某智能锁的产品型号为：“DSL-C07”。<br>特征值0x2A25，描述产品序列号 Serial Number String，例如某智能锁的产品序列号为：“lkjl0016190502500269”<br>特征值0x2A26，描述产品固件版本号 Firmaware Revision String，例如某智能锁的固件号为：“2.7.2.0”</p>
<p>上述特征值仅有read 属性，因此主机只能读，不能执行写操作</p>
<p>服务0xfff0</p>
<p>FFF0 是我们自定义的服务uuid，它包含两个特征值，用来发送和接收数据</p>
<p>特征值0xfff1 自定义的数据发送通道，具有read 和write 属性，主机可以通过该特征值，向从机发送数据，至于发送的数据的最大长度，可以在profile 中配置<br>特征值0xfff2 ，自定义的数据接收通道，具有notify 属性，从机可以通过该特征值，主动向主机发送数据</p>
<p>假设主机写特征值的协议栈函数原型为 int GATT_WriteCharValue(uuid_t UUID, uint8 *pValue, uint8 len)</p>
<p>假设从机发送通知的协议栈函数原型为 int GATT_Notification(uuid_t UUID, uint8 *pValue, uint8 len)</p>
<p>那么主机向从机发送Hello，可以这样调用协议栈的函数：GATT_WriteCharValue(0xFFF1,”Hello”,5)</p>
<p>那么从机向主机发送1234，可以这样调用协议栈的函数：GATT_Notification(0xFFF2,”1234”,4)</p>
<p>断开</p>
<p>主机或从机都可以发起断开连接请求，对方会收到该请求，然后断开连接恢复连接前的状态</p>
<p>过程演示</p>
<p>现在我们总结一下BLE 的工作流程，使用两个虚拟的ble 硬件来模拟主从机的交互过程</p>
<p>假设有两个ble 设备，使用的是BLE261 低功耗蓝牙模块，假设已经下载了用于交互演示的功能固件，一个是主机，名称为blecentral ，另一个是从机，名称为bleperipheral，如下图所示</p>
<p>步骤1 上电初始化</p>
<p>主机，从机上电后 不分先后顺序，首先进行协议栈初始化和相关功能调用，如下图所示</p>
<p>主机设备，主机初始化时，需要设置设备类型，设置用于扫描的相关参数，初始化 gatt 等协议相关的参数<br>从机设备，从机初始化时，需要设置设备名称，广播相关参数，从机profile，等，从机一般会立即开启广播，也可以等待一个事件来触发广播，例如按键触发</p>
<p>步骤二 主机扫描从机</p>
<p>按键按下，触发主机扫描从机，此时，主机显示屏打印scanning 正在扫描，此刻的从机仍然处于广播状态</p>
<p>步骤三 发现从机设备</p>
<p>当主机扫描到从机时，可以返回已扫描到的从机相关信息，例如可以提取到下图中的从机设备名称，从机mac 地址，从机的RSSI 信号值等数据，因此，有些应用在从机的广播包或者扫描回应包中添加自定义字段，这样就可以被主机通过扫描的方式拿到数据</p>
<p>步骤四 发送连接请求<br>当主机扫描到从机后，通过mac 地址向从机发送连接请求，低功耗蓝牙的连接速度非常快，10ms 左右即可成功连接上，如果从机的广播比较大，则会影响连接的速度</p>
<p>从机在未收到连接请求之前仍然处于自由的广播状态</p>
<p>步骤五 成功连接从机</p>
<p>当从机收到连接请求后，双方成功建立连接，此时双方的状态均变为已连接状态</p>
<p>然后主机可以调用协议栈提供的接口函数来获取从机的服务</p>
<p>步骤6 获取从机服务</p>
<p>获取从机服务通常是在连接成功后就立即执行的，因为只有获取从机的服务后，从能与其通信，下图是主机想从机发送获取服务的请求</p>
<p>此刻，从机处于已连接状态，响应服务获取请求是在底层自动完成的，上层无需理会</p>
<p>步骤7 成功获取服务</p>
<p>如下图所示，主机成功获取到从机的服务，例如获取到UUID 为0xfff0的services 该service 有两个特征值，分别是具有读写属性的0xfff1 ，以及具有通知属性的0xfff2</p>
<p>读写属性是指主机可以读写该特征值的内容，而通知属性是指从机可以通过该特征值向主机发送数据</p>
<p>步骤8 主机向从机发送数据</p>
<p>主机通过特征值0xfff1 主动向从机发送自定义数据hello ，当数据成功发送后，主机状态变为：数据已发送，从机将收到主机发来的数据，从机状态变为收到数据</p>
<p>步骤9 从机向主机发送数据</p>
<p>从机可以通过norify 的方式主动向主机发送数据，例如下图，从机通过特征值0xfff2 发送了一条 notify 通知，数据内筒为1234</p>
<p>步骤10 发送断开请求</p>
<p>主机和从机任何一方均可以发起断开连接的请求，对方收到后，状态将变为已断开</p>
<p>步骤11 成功断开连接</p>
<p>从机收到主机发来的断开请求，此刻状态变为已断开</p>
<h2 id="4-BLE-协议栈"><a href="#4-BLE-协议栈" class="headerlink" title="4 BLE 协议栈"></a>4 BLE 协议栈</h2><p>BLE 协议栈一般是指芯片厂家，以及Bluetooth SIG 发布的Bluetooth core specification 核心协议的实现的代码固件，并提供函数接口，有芯片内部程序调用，可实现上节BLE 工作流程等相关功能</p>
<p>常见的协议栈有 德州仪器 TI 的ble-stack 和nordic 的softdevice</p>
<p>功能框图</p>
<p>在本节中，我们列举两家典型的蓝牙芯片厂家，TI 和noridc 来深入了解低功耗蓝牙协议栈</p>
<p>下图是TI的CC26系列芯片协议栈结构图，</p>
<p>下图是Nordic的nRF52系列芯片的协议栈结构图。</p>
<p>协议栈结构</p>
<p>从上节的两张协议栈功能框图中可以看出，无论是哪个芯片厂商实现的ble 协议栈，其结构都非常的相似，均三个部分</p>
<p>底层 controller<br>中层 host<br>顶层 application</p>
<p>然后每一层又分成若干个子模块，我们现在由下而上，逐层介绍</p>
<p>我们将位于顶层的应用层application 也归到协议栈中描述，其实，应用层application 不属于协议栈，它是用来调用协议栈提供的接口，然后实现蓝牙的功能</p>
<p>控制器 controller </p>
<p>physical layer 简称 PHY，物理层，PHY层用来指定BLE 所用的无线频段，调制解调方式和方法等，phy 层做得好不好，直接决定整个ble 芯片的功耗，灵敏度以及selectivity 等频射指标</p>
<p>link layer 简称 LL，链路层，ll层是整个ble 协议栈的核心，也是ble 协议栈的难点和重点，像nordic 的ble 协议栈能同时支持20个link 连接，就是ll 层的功劳，ll 层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK 如何接收，如何进行重传，以及如何对链路进行管理和控制等等，LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP 或者ATT</p>
<p>host controller interface 简称 HCI，协议栈应用开发中，我们会经常看到HCI 的身影，它对上host 提供controller 的功能接口，所以称作 host controller interface</p>
<p>主控Host </p>
<p>Logical link control adaptation protocol 简称 L2CAP L2CAP 对LL 进行了一次简单封装，LL 只关心传输的数据本身，L2CAP 就要区分加密通道还是普通通道，同时还要对连接间隔进行管理</p>
<p>Attribute Protocol 简称ATT ATT 层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据，BLE 协议栈中，开发者接触最多的就是ATT。BLE 引入了attribute 共年，用来描述一条一条的数据，attribute 除了定义数据，同时定义该数据可以使用的att 命令，因此这一层被称为ATT 层</p>
<p>Security Manager 简称SM SMP 用来管理BLE 连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作</p>
<p>Generic Access Profile  简称GAP GAP 是对LL 层payload 有效数据包 如何进行解析的两种方式中的一种，而且是最简单的那一种，GAP 简单的对LL payload 进行一些规范和定义，因此gap 能实现的功能极其有限，GAP 目前主要用来进行广播，扫描和发起连接等</p>
<p>Generic Attribute Profile 简称GATT<br>GATT 用来规范attribute 中的数据内容，并运用group 分组的概念对attribute 进行分类管理，没有GATT BLE 协议栈也能跑，但互联互通就会出现问题，也正是因为有了GATT 和各种各样的应用Profile，BLE 摆脱了zigbee等无线协议的兼容性困境，成了出货量最大的2.4G 无线通信产品</p>
<p>应用application</p>
<p>应用层是用户开发实际蓝牙应用的地方，包含必要的协议栈参数设置，以及各种功能函数的调用，我们分别从蓝牙从机和蓝牙主机两种设备来分析</p>
<p>蓝牙从机</p>
<p>相关硬件和基础服务初始化</p>
<p>设置广播参数，广播数据，广播间隔，扫描回应等参数或者数据</p>
<p>设置profile 添加从机服务，特征是，还有设置回调函数用于接收主机数据等<br>设置绑定管理参数 可选</p>
<p>启动广播，开始运行</p>
<p>等待相关事件，及事件处理，例如收到主机发来的数据，被链接等</p>
<p>蓝牙主机</p>
<p>相关硬件和基础服务初始化</p>
<p>设置扫描参数</p>
<p>设置连接参数</p>
<p>设置绑定管理参数 可选</p>
<p>启动协议栈，开始运行</p>
<p>等待相关事件，及事件处理，例如扫描事件，从机的notify 事件等</p>
<ol start="5">
<li>GAP 和GATT</li>
</ol>
<p>蓝牙协议分为两类结构，控制器 和主机，每个类别都有子类别，这些子类别执行特定的角色，我们将要研究的两个子类别是，通用访问配置文件 GAP 和通用属性配置文件 GATT</p>
<p>GAP是Generic Access Profile的缩写，中文含义是：通用访问配置文件。<br>GATT是Generic Attribute Profile的缩写，中文含义是：通用属性配置文件。</p>
<p>5.1 GAP 和gatt 区别</p>
<p>区分GAP 和gatt 很重要</p>
<p>GAP 定义了BLE 网络堆栈的一般拓扑</p>
<p>GATT 详细描述了一旦设备建立连接后如何传输属性数据</p>
<p>GATT 特别关注如何根据其描述的规则格式化打包和发送数据，在BLE 网络堆栈中，属性协议，ATT 与GATT 紧密对齐，GATT 直接位于ATT  的顶部，GATT<br>实际上使用ATT 来描述如何从两个连接的设备交换数据</p>
<p>通用访问配置文件 GAP</p>
<p>BLE 设备可以使用两种机制与外界通信，广播或连接，这些机制受通用访问配置文件 GAP 准则的约束，GAP 定义了启用BLE 的设备如何使其自身可用，以及两个设备如何直接相互通信</p>
<p>建立联系</p>
<p>设备可以通过采用 GAP 中指定的以下角色来加入BLE 网络</p>
<p>A、广播（Broadcasting）：这些角色不必显式地相互连接即可传输数据。</p>
<p>广播者（Broadcaster）：广播公共数据包的设备，例如可以广播按下按钮的时间。<br>观察者（Observer）：侦听广播者发送的广告包中数据的设备。广播者和观察者之间没有任何连接。&#x2F;2、&#x2F;2<br>B、连接（Connecting）：这些角色必须显式连接和握手才能传输数据。这些角色比广播角色更常用。</p>
<p>从机设备（Peripheral）：  通过广播，告知其他设备自己的存在，以便主机设备可以建立连接。连接后，从机设备不再向其他主机设备广播数据，而是保持与主机设备的连接。<br>从机设备功耗低，因为它们只需要定期发送信标即可。主机设备负责开始与从机设备的通信。<br>手环是BLE外设的一个示例。<br>主机设备（Central）：一种通过侦听广播包来启动与从机设备的连接的设备。主机设备可以连接到许多其他从机设备。<br>当主机设备要连接时，它将请求连接数据包发送到从机设备。如果从机设备接受来自主机设备的请求，则建立连接。<br>当您的手机连接到手环时，就是BLE Central设备的一个示例。</p>
<p>连接后</p>
<p>主机设备可以更新连接参数，主机设备通常在设备与其自身之间建立连接参数，只有主机设备能修改连接参数，但是，采集设备可以要求主机设备更改连接参数，及从机发送更新参数请求</p>
<p>从机设备或主机设备可以终止连接，连接可能由于多种原因而终止，例如设备的电池可能耗尽或网络干扰可能导致连接失败，设备还可以主动与对等设备断开连接</p>
<p>通用属性配置文件 GATT</p>
<p>GATT 分为两种类型，注意与从机或主机无关</p>
<p>客户端，客户端可以发送请求给GATT 服务端，客户端可以读写 服务端的属性，通过属性可以通信数据</p>
<p>服务端，服务端是用来存储属性的，每当客户端发送请求时，服务端会响应这些请求</p>
<p>客户端与服务端的关系</p>
<p>一个示例如下，手环采集了心跳信息，希望计算机读取该信息，手环充当服务端并提供信息，手机充当客户端，读取该信息</p>
<p>GAP 和GATT 模型角色基本上彼此独立从机设备或主机设备都可以充当服务端或客户端，这取决于数据的流动方式</p>
<p>在一般的主从机通信时，主机可以通过读写从机的属性，实现接收和发送数据给从机，从机可以通过发送通知的方式实现与主机的通信，因此，一般从机是作为GATT 的服务端，主机作为GATT 的客户端</p>
<p>协议栈分层协作<br>下面以如何发送一个无线数据包的例子来简单阐述协议栈中各分层的作用和必要性，实际上，协议栈的实现可能更加负责，它需要考虑方方面面的因素</p>
<p>发送数据包</p>
<p>假设有设备A 和设备B 设备A 要把自己的电量状态83 % 0x53 发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，它希望调用一个简单的api 就能完成这件事，比如 send 0x53 实际上我们的BLE 协议栈就是这样设计的，开发者只需调用 send 0x53 就可以把数据发送出去了，其余的事情BLE 协议栈帮你搞定，很多人会想，BLE 协议栈是不是直接在物理层就把0x53 发出去，就如下图所示</p>
<p>这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的，首先，它没有考虑用哪一个射频信道来进行传输，在不更改API 的情况下，我们只能对协议栈进行分层，为此引入 LL 层，开发者还是调用 send 0x53 send 0x53 再调用 send_LL 0x53 2402M 注 2402M 为信道频率，这里还有一个问题，设备B 怎么知道这个数据包是发给自己的还是其他人的，为此BLE 引入 access address 概念，用来指明接受者身份，其中，0x8e89bed6 这个access address 比较特殊，它表示要发给周边所有设备，即广播，如果你要一对一的进行通信，BLE 协议将其称为连接，即设备A 的数据包只能设备B 接收，同样设备B 的数据包只能设备A 接收，那么就必须生成一个独特的随机access address 标识设备A 和设备B 两者之间的连接</p>
<p>广播方式</p>
<p>我们先来看一下简单的广播情况，这种情况下，我们把设备A 叫advertiser 设备B叫 scanner 或者observer 扫描者，广播状态下设备A 的LL 层api 将变成 send_LL 0x53 2402M 0x8e89bed6 由于设备B 可以同时接收到很多设备的广播，因此数据包还必须包含设备A 的device address 0xE1022AAB753B 以确认该广播包来自设备A 为此send LL 参数需要变成<br>send_LL(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)<br>LL 层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24 对数据包进行检验，假设为0xb2c7be 同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble preamble 一般为0x55 或者0xAA 这样，整个空中包变成</p>
<p>空中包用小端模式表示</p>
<p>上面这个数据包还有如下问题</p>
<p>没有对数据包进行分类组织，设备B 无法找到自己想要的数据0x53 为此，我们需要在access address 之后加入两个字段，LL header 和长度字节，LL header 用来表示数据包的LL 类型，长度字节用来指明payload 的长度</p>
<p>设备B 什么时候开启射频窗口以接收空中数据包，如上图case1所示，当设备A 的数据包在空中传输的时候，设备B 包接收窗口关闭，此时通信将失败，同样对case2 来说，当设备A 没有空中发送数据包时，设备B 把接收窗口打开，此时通信也将失败，只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B 正好打开射频接收窗口，此时通信才能成功，换句话说，LL 层还必须定义通信时序</p>
<p>当设备B 拿到数据0x53 后，该如何解析这个数据呢？ 它到底表示湿度还是电量，还是别的意思，这个就是GAP 层要做的工作，GAP 层引入了LTV length type value 结构来定义数据，比如020105<br>02 长度 01 类型，强制字段，表示广播flag ，广播包必须包含该字段，05 值，由于广播包最大只能为31 个字节，它能定义的数据类型极其有限，像这里说的电量，gap 就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型 0xff 及04ff590053 其中04 表示长度，ff 表示数据类型，自定义数据，0x0059 是供应商 id 自定义数据中的强制字段，0x53 就是我们的数据，设备双方约定0x53 就是表示电量，而不是其他意思</p>
<p>AAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2</p>
<p>AA 前导帧<br>D6BE898E – 访问地址(access address)<br>60 – LL帧头字段(LL header)<br>0E – 有效数据包长度(payload length)<br>3B75AB2A02E1 – 广播者设备地址(advertiser address)<br>02010504FF590053 – 广播数据<br>8EC7B2 – CRC24值</p>
<p>有了PHY LL 和gap，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制</p>
<p>无法进行一对一双向通信，广播是一对多通信，而且是单方向的通信</p>
<p>由于不支持组包和拆包，因此无法传输大数据</p>
<p>通信不可靠及效率低下，广播信道不能太多，否则将导致扫描端效率低下，为止 ble 只使用37 2402MHZ 38 2426 39 2480 三个信道进行广播和扫描，因此广播不支持调频，由于广播是一对多的，所以广播也无法支持ack，这些都使广播通信变得不可靠</p>
<p>扫描端口功耗高，由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37 38 39 三个通道进行扫描，这样功耗就会比较高</p>
<p>而连接则可以很好解决上述问题，下面我们就来看看连接是如何将0x53 发送出去的</p>
<p>6.3 连接方式</p>
<p>到底什么叫连接，像有线uart ，很容易理解，就是用线 rx tx 等，把设备A 和设备B 相连，即为连接，用线把两个设备相连，实际是让两个设备有共同的通信媒介，并让两者时钟同步起来，蓝牙连接有何尝不是这个道理<br>所谓设备A 和设备B 建立蓝牙连接，就是指设备A 和设备B 两者一对一 同步成功，其具体包含以下几方面</p>
<p>设备A 和设备B 对接下来要用的物理信道达成一致</p>
<p>设备A 和设备B 双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点</p>
<p>设备A 和设备B 两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包</p>
<p>连接成功后，设备A 和设备B 通信流程如下所示</p>
<p>如上图所示，一旦设备A 和设备B 连接成功（此种情况下，我们把设备A称为Master 或者central ，把设备B 称为slave 或者peripheral），设备A 将周期性以CI connection interval 为间隔向设备B 发送数据包，而设备B 也周期性地以ci 为间隔打开射频接收窗口以接收设备A 的数据包，同时按照蓝牙spec 要求，设备B 收到设备A 数据包150us 后，设备B 切换到发送状态，把自己的数据发给设备A，设备A则切换到接收状态，接收设备B 发过来的数据，由此可见，连接状态下，设备A 和设备B 的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大降低系统功耗并大大提高系统效率</p>
<p>现在我们看看连接状态下是如何把数据0x53 发送出去的，从中大家可以体会到蓝牙协议分层的妙处</p>
<p>对开发者来说，很简单，他只需要调用 send 0x53</p>
<p>GATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（小端模式！）<br>ATT层用来选择具体的通信命令，比如读&#x2F;写&#x2F;notify&#x2F;indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053<br>L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053<br>LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：<br>AAAB5D65501E08040004001B130053D550F6<br>AA – 前导帧(preamble)<br>0x50655DAB – 访问地址(access address)<br>1E – LL帧头字段(LL header)<br>08 – 有效数据包长度(payload length)<br>04000400 – ATT数据长度，以及L2CAP通道编号<br>1B – notify command<br>0x0013 – 电量数据handle<br>0x53 – 真正要发送的电量数据<br>0xF650D5 – CRC24值</p>
<p>虽然 开发者只调用了send 0x53 ，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成下图所示的模样，这就既满足了低功耗蓝牙通信的需求，又让客户api 变得简单，可微一箭双雕</p>
<p>蓝牙广播</p>
<p>蓝牙状态切换</p>
<p>蓝牙服务和特性</p>
<p>SPP 协议， MID 协议</p>
<p>HID 协议 等等</p>
<p>MicroPython  BLE</p>
<p>NodeMCU-32</p>
<p>蓝牙广播 advertising</p>
<p>常见的广播类型</p>
<p>0x01 设备标识</p>
<p>0x02 16bit uuid</p>
<p>0x07 128 bit uuid</p>
<p>0x19 设备外观</p>
<p>0x08 缩略设备名称</p>
<p>0x09 完整设备名称</p>
<p>0x0A 发射功率</p>
<p>0xff 厂商自定义数据</p>
<p>app nrf connected</p>
<p>蓝牙广播类型</p>
<p>可连接非定向</p>
<p>可连接定向</p>
<p>不可连接非定向</p>
<p>可扫描非定向</p>
<p>扫描响应数据和广播数据格式是一样的</p>
<p>扫描响应数据是非必需的</p>
<p>总结</p>
<p>低功耗蓝牙通信基于特性</p>
<p>常用通信方式 read write notify<br>手机订阅才能收到 notify</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv18236129">https://www.bilibili.com/read/cv18236129</a></p>
<p>BF54D165-942B-D6A0-5425-E593CD317472</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> TeX_baitu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="TeX_baitu blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>