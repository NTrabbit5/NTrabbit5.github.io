<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> TeX_baitu blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      


<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-20221213-数字芯片中使能信号的作用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-%E6%95%B0%E5%AD%97%E8%8A%AF%E7%89%87%E4%B8%AD%E4%BD%BF%E8%83%BD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/"
    >20221213-数字芯片中使能信号的作用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-%E6%95%B0%E5%AD%97%E8%8A%AF%E7%89%87%E4%B8%AD%E4%BD%BF%E8%83%BD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/" class="article-date">
  <time datetime="2022-12-13T07:18:15.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ol>
<li>什么是使能信号，</li>
</ol>
<p>所谓使能信号，英文叫enable 翻译成中文还有启用等意思</p>
<p>如图所示，当G1为低电平的时候，不管其它输入是什么。输出全为高电平。而当G2为高电平时（G2等于G2A与上G2B），不管其它输入是什么，输出也都一律为高电平。因此仅从功能上来判断，G1和G2就可以控制这颗芯片是不是被“启用”了。可以看出当G1为低或G2位高时，整个芯片的其它输入无论如何变化都不影响输出。简单的说就是整个芯片实际上没用发挥作用，功能没有“启用”。</p>
<ol start="2">
<li>为什么使能信号可以控制芯片的启用和停用</li>
</ol>
<p>全部都连到了最后一级的所有与非门上。我们知道一个与非门，如果有1个输入为0，那么这个与非门的输出就会是1。因此，如果不满足G1为高电平，G2A和G2B都为低电平这个条件，就会让所有输出全为1。而这时无论别的输入是什么，都不会让输出有任何改变。从这一点上来说，要启用这颗芯片的功能就必须满足G1为高电平，G2A和G2B都为低电平这个条件。否则，其它输入影响不了输出，芯片“译码”的功能就没有被“启用”。</p>
<ol start="3">
<li>为什么需要使能信号</li>
</ol>
<p>需要使能信号的主要原因是一个大型的数字系统中，通常都需要使用多个芯片&#x2F;电路单元来配合完成一个功能，而这些芯片并不是每时每刻都在工作，因此需要用使能信号来控制硬功启用那个芯片来工作</p>
<p>假设4bit的二进制编码从高到低依次是A3A2A1A0</p>
<p>将A2A1A0分别对应连接到两片74XX138上。而将A3连接到低位片的G2B上和高位片的G1上。</p>
<p>这样我们实际上把4bit的二进制数据划分为了2段</p>
<p>其中一段从0000到0111，另外一段从1000到1111。当现在A2A1A0为111时，低位片的Y7和高位片的Y7都有可能输出。而假设此时A3为0（此时输入为0111），那么低位片的所有使能信号均有效，而高位片的G1是无效的。那么此时低位片被启用而高位片未被启用。所以低位片的Y7输出为低而其它均为高，高位片的所有输出都是高。因此，0111被译码为了1111111101111111（输出低有效）。反之，A3为1（此时输入为1111）。则低位片的G2B无效而高位片所有的使能信号都有效。1111倍译码为0111111111111111</p>
<ol start="4">
<li>使能信号还有哪些用法</li>
</ol>
<p>使能信号的用途非常广泛，可以作为计算机系统中存储芯片选通信号，可以作为显式系统中的控制信号，但核心的一点就是使能信号控制了芯片的功能是否能被正常的启用，这在设计大型的数字系统中是非常重要的一环</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-RS485通讯基础及通讯应用详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-RS485%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%80%9A%E8%AE%AF%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"
    >20221213-RS485通讯基础及通讯应用详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-RS485%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%80%9A%E8%AE%AF%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-12-13T05:42:43.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/341845459">https://zhuanlan.zhihu.com/p/341845459</a></p>
<p>举例：plc向变频器从机1和变频器从机2传递数据，首先变频器从机1和变频器从机2设备之间必须通过电缆连接（硬件连接）。如果变频器从机1和变频器从机设备发送101010这样一串代码，那么变频器从机1就要在他的通讯端口产生如下图所示的高低电平的组合，通过电缆这个介质变频器从机2设备的通讯端口就会接收到A设备发出高低电平的组合，同时就会将接</p>
<h2 id="RS-485概述"><a href="#RS-485概述" class="headerlink" title="RS-485概述"></a>RS-485概述</h2><p>RS-485和RS-232一样，都是串行通信标准，现在的标准名称是TIA485&#x2F;EIA-485-A，但是人们会习惯称为RS-485标准，RS-485常用在工业、自动化、汽车和建筑物管理等领域。</p>
<p>RS-485总线弥补了RS-232通信距离短，速率低的缺点，RS-485的速率可高达10Mbit&#x2F;s，理论通讯距离可达1200米；RS-485和RS-232的单端传输不一样，是差分传输，使用一对双绞线，其中一根线定义为A，另一个定义为B。</p>
<p>双绞线</p>
<h2 id="RS-485物理层"><a href="#RS-485物理层" class="headerlink" title="RS-485物理层"></a>RS-485物理层</h2><p>RS-485的物理层负责在设备和物理传输介质之间传输原始数据。它处理电信号到数字数据的转换，同时定义电压、时序、数据速率等。</p>
<p>① 差分信号</p>
<p>长距离布线会有信号衰减，而且引入噪声和干扰的可能性更大，在线缆A和B上的表现就是电压幅度的变化，但是，采用差分线的好处就是，差值相减就会忽略掉干扰依旧能输出正常的信号，把这种差分接收器忽略两条信号线上相同电压的能力称为共模抑制。</p>
<p>标准规定了，逻辑1：+2V to +6V；逻辑0：-6V to -2V。</p>
<p>RS-485不需要使用特定的总线电压，只看最小差分电压，在较长的电缆长度上，接收器接收到的电压可能会降低到+&#x2F;- 200 mV，这对于RS-485仍然是完全可以接受的，这也是RS-485的优点之一。</p>
<p>很多收发器的标准达到甚至超过TIA&#x2F;EIA-485A规范，在实际使用中，以器件的SPEC参数为主，如下某收发器的负输入阈值最小也是-200mV。</p>
<p>② 信号定义</p>
<p>现在很多的RS-485转换器都是兼容RS-422的，所以看到很多转换器上面的信号都是T&#x2F;R+、T&#x2F;R-，即对应RS-485的A+和B-。</p>
<p>对于DB9针型的母头，RS-485有如下的接线定义示意，Pin6~Pin9为N&#x2F;A不接。</p>
<p>DB9 输出信号  RS-422全双工接线 RS-485半双工接线<br>1 T&#x2F;R+  发（A+） RS-485（A+）<br>2 T&#x2F;R-  发（B-） RS-485（B-）<br>3 RXD+  收（A+） 空<br>4 RXD-  收（B-） 空<br>5 GND 地线  地线</p>
<p>③ 拓扑结构</p>
<p>RS485有两线制和四线制两种接线，四线制只能实现点对点的通信方式，现很少采用，多采用的是两线制接线方式，这种接线方式为总线拓扑结构，在同一总线上最多可以挂接32个节点。</p>
<p>RS-485总线同I2C，也是主从模式，支持点对点单从机模式，也支持多从机模式，不支持多主机模式。</p>
<h2 id="RS-485收发器"><a href="#RS-485收发器" class="headerlink" title="RS-485收发器"></a>RS-485收发器</h2><p>RS-485是差分传输，如果用单片机控制RS-485接口的设备，需要用到收发器，这一点和CAN总线是类似的，如下是一个MCU控制一个RS-485的图示。</p>
<p>收发器内部是一个接收器（上半部分）加一个发送器（下半部分），下面简单说说收发器的原理，便于理解MCU是如何和485设备通信的。</p>
<p>RS-485收发器内部结构</p>
<p>其中：</p>
<p>A和B为总线；<br>R为接收器输入；<br>RE为接收器使能信号；<br>DE为发送器使能信号；<br>D为发送器输出；<br>对于使能信号，字母上面加一横的为低电平有效（如上图RE），不加的为高电平有效（如DE）。</p>
<p>对于发送器，有如下的真值表：</p>
<p>1、当驱动器使能引脚DE为逻辑高时，差分输出A和B遵循数据输入D处的逻辑状态。D处的逻辑高导致A转为高，B转为低。在这种情况下，定义为VOD&#x3D;VA-VB的差分输出电压为正。当D为低时，输出状态反转，B变高，A变低，VOD为负。</p>
<p>2、当DE低时，两个输出都变成高阻抗。在这种情况下，与D处的逻辑状态是不相关的。</p>
<p>发送器真值表</p>
<p>对于接收器，有如下的真值表：</p>
<p>1、当接收器使能引脚RE逻辑低时，接收器被激活。当定义为VID&#x3D;VA–VB的差分输入电压为正且高于正输入阈值VIT+时，接收机输出R变高。当VID为负且低于负输入阈值VIT-，接收机输出R变低。如果VID在VIT+和VIT-之间，则输出不确定。</p>
<p>2、当RE为逻辑高或悬空时，接收机输出为高阻抗，VID的大小和极性无关。</p>
<p>接收器真值表</p>
<h2 id="RS-485数据链路"><a href="#RS-485数据链路" class="headerlink" title="RS-485数据链路"></a>RS-485数据链路</h2><p>上面讲到的RS-485收发器的工作原理，下面简单描述RS-485的数据链路，可以先看一下通俗易懂的UART协议帧格式</p>
<p>主机发送给从机或者从机发送给主机，都会占用到A和B线，所以RS-485多用在半双工模式。</p>
<p>主机的GPIO会控制RS-485收发器的DE管脚，设置发送模式，从UART TXD线向RS-485收发器的数据（D或DI）线发送一个字节，收发器将在A和B线上将单端UART位流转换为差分位流，数据离开收发器后，主机立即将收发器的模式切换为接收模式。</p>
<p>从机和主机是类似的，从机控制RS-485收发器的&#x2F;RE管脚，设置为接收模式，接收主机发送的比特流，将其转换为单端信号，通过从机的UART RXD线接收，当从机准备好响应时，它按主机原来的方式进行发送，而主机变为接收。</p>
<h2 id="RS-232和RS-485转换"><a href="#RS-232和RS-485转换" class="headerlink" title="RS-232和RS-485转换"></a>RS-232和RS-485转换</h2><p>RS-232和RS-485之间可以转换，一个方法是RS-232转换成TTL，再由TTL转换为RS-485，当然也有芯片支持将RS-232直接转换成RS-485，网上有很多模块。</p>
<p>RS-232和RS-485转换模块</p>
<h2 id="RS-485和CAN的区别"><a href="#RS-485和CAN的区别" class="headerlink" title="RS-485和CAN的区别"></a>RS-485和CAN的区别</h2><p>虽说RS-485没有标准的数据协议格式，但和CAN总线在很多地方是有相似的，比如A&amp;B和CANH&amp;CANL都是差分信号，通信都需要收发器，都需要120欧姆的匹配电阻等等。</p>
<p>总线特性  CAN总线 RS-485总线<br>硬件成本  稍高  低廉<br>总线利用率 优先级自动仲裁，利用率高  采用轮询，利用率低<br>数据传输率 高 低<br>错误检测机制  控制器带校验机制，保证底层数据传输正确 只有物理层规范，无数据链路层规定<br>单节点故障影响 总线无影响 总线瘫痪<br>开发成本  软件开发灵活，时间成本低  开发难度较大<br>系统成本  较低  高</p>
<h2 id="RS-485常用电路"><a href="#RS-485常用电路" class="headerlink" title="RS-485常用电路"></a>RS-485常用电路</h2><p>网上找的一个常用的RS-485电路，其中需要注意两点：</p>
<p>1、使能信号RE和DE可采用一个GPIO控制，节省资源，GPIO25输出高电平，RE&#x3D;DE&#x3D;0V，进入接收模式；GPIO25输出低电平，RE&#x3D;DE&#x3D;3.3V，进入发送模式。</p>
<p>2、有一些电路中会在A上加上拉，B上加下拉电阻，主要原因是：RS-485总线在idle状态，电平是不固定的，即电平在-200mV~+200mV之间，收发器可能输出高也可能输出低，UART在空闲时需要保持高电平的，如果此时收发器输出一个低电平，对UART来说是一个start bit，会导致通信异常，关于Ru和Rd的阻值在这里不作过多赘述，后面有机会会详细写一篇文章。</p>
<p>关于第二点，需要注意：</p>
<p>① A上加上拉，B上加下拉，接反数据通信也可能出错。</p>
<p>② 某些收发器内部集成上下拉电阻，则外部不需要再添加。</p>
<p>今天的文章内容到这里就结束了，希望对你有帮助，我们下一期见。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-UART串口通信介绍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/"
    >20221213-UART串口通信介绍</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2022-12-13T04:16:06.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>串口通信 UART 介绍</p>
<p>通用异步收发传输器 ，通常称作UART ，是一种异步收发传输器</p>
<p>首先先来介绍一下同步和异步通信</p>
<p>在常见通信总线协议中，I2C SPI 属于同步通信而UART 属于异步通信</p>
<p>在UART 通信中，数据起始位和停止位是必不可少的</p>
<p>硬件层</p>
<p>常用RS-232标准，这里不详细解释，主要是对应设备的Tx 线和Rx 线要对应正确</p>
<p>协议层 </p>
<p>协议层中，规定了数据包的内容，它由起始位，主体数据，校验位以及停止位组成，通信双方的数据包格式要约定一致才能正常收发数据</p>
<p>波特率  异步通信中由于没有时钟信号，所以2个通信设备需约定好波特率，常见的有4800 9600 15200 等</p>
<p>通信的起始和停止信号，串口通信的一个数据包从起始信号开始，知道停止信号结束，数据包的起始信号由一个逻辑0 的数据位表示，而数据包的停止信号可由0.5 1 1.5 2 个逻辑1 的数据位表示，只要双方约定一致即可</p>
<p>有效数据，在数据包的起始位置之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为8位或9位长</p>
<p>数据校验  可以在传输过程中加上校验位来解决这个问题，校验方法有奇校验 偶校验 0校验 1校验 以及无校验</p>
<p>奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个 8 位长的有效数据为：01101001，此时总共有 4 个“1”，为达到奇校验效果，校验位为“1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位。偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4 个，所以偶校验位为“0”。0 校验是不管有效数据中的内容是什么，校验位总为“0”，1 校验是校验位总为“1”。</p>
<p>UART 功能框图剖析</p>
<p>这张图是当年上学时使用system C 对uart 建模的模块图，对于接口部分，重要的即为Tx Rx 数据输出，接受接口，clk 提供波特率生成模块的初始时钟信号，</p>
<p>有关控制器部分，在这里使用逻辑电路来实现，具体控制输出&#x2F;接收使能，设备使能等</p>
<p>在目前的微控制器上，数字电路控制部分已被封装，现在只需要操作对应寄存器的对应位即可实现对UART  的控制<br>下图是uart 框图 </p>
<p>波特率生成模块</p>
<p>USART 的发送器和接收器使用相同的波特率，有以下的计算公式</p>
<p>其中，fck为 USART 时钟， USARTDIV 是一个存放在波特率寄存器(USART_BRR)的一个无符号定点数。其中 DIV_Mantissa[11:0]位定义 USARTDIV 的整数部分，DIV_Fraction[3:0]位定义 USARTDIV 的小数部分。</p>
<p>例如：DIV_Mantissa&#x3D;24(0x18)，DIV_Fraction&#x3D;10(0x0A)，此时 USART_BRR 值为0x18A；那么USARTDIV的小数位10&#x2F;16&#x3D;0.625；整数位24，最终USARTDIV的值为24.625。</p>
<p>波特率的常用值有 2400、9600、19200、115200。下面以实例讲解如何设定寄存器值得到波特率的值。我们知道 USART1 使用APB2总线时钟，最高可达72MHz，其他USART的最高频率为36MHz。我们选取USART1作为实例讲解，即fck&#x3D;72MHz。为得到115200bps的波特率，此时：115200&#x3D;72000000&#x2F;(16∗USARTDIV)，解得USARTDIV&#x3D;39.0625，可算得DIV_Fraction&#x3D;0.0625*16&#x3D;1&#x3D;0x01，DIV_Mantissa&#x3D;39&#x3D;0x27，即应该设置USART_BRR的值为0x171。</p>
<p>数据寄存器</p>
<p>UART 数据寄存器 只有低9位有效，并且第9位 数据是否有效要取决于uart 控制寄存器1的M 位设置，当M 位为0 时表示8位数据字长，当M 位为1 表示9位数据字长，我们一般使用8位数据字长</p>
<p>USART_DR包含了已发送的数据或者接收到的数据。USART_DR实际是包含了两个寄存器，一个专门用于发送的可写TDR，一个专门用于接收的可读RDR。当进行发送操作时，往USART_DR写入数据会自动存储在TDR内；当进行读取操作时，向USART_DR读取数据会自动提取RDR数据。</p>
<p>TDR和RDR都是介于系统总线和移位寄存器之间。串行通信是一个位一个位传输的，发送时把TDR内容转移到发送移位寄存器，然后把移位寄存器数据每一位发送出去，接时把接收到的每一位顺序保存在接收移位寄存器内然后才转移到RDR。</p>
<p>UART支持DMA传输，可以实现高速数据传输(不经过CPU),使能UART的DMA功能需要将USART_CR1寄存器DMAT位置1。</p>
<p>控制器</p>
<p>UART 有专门控制发送的发送器，控制接收的接收器，还有唤醒单元，中断控制等，使用uart 之前需要向 usart_CR1 寄存器的ue位置使能UART UE 位用于开启供给串口的时钟</p>
<p>发送器</p>
<p>当USART_CR1寄存器的发送使能位TE置1时，启动数据发送，发送移位寄存器的数据会在TX引脚输出，低位在前，高位在后。</p>
<p>一个字符帧发送需要3部分，起始位 数据帧  停止位，起始位是一个位周期的低电平，位周期就是每一位占用的时间，数据帧就是我们要发送的8 或9 位数据，数据是最低位开始传输的，停止位是一定时间周期的高电平</p>
<p>停止位的时间长短可以通过UART控制寄存器2（USART_CR2）的STOP[1:0]位控制，可选0.5个、1个、1.5个、2个停止位。默认使用1个停止位。2个停止位适用于正常USART模式、单线模式和调制解调器模式。0.5和1.5个停止位用于智能卡模式。</p>
<p>当发使能位TE置1之后，发送器开始会发送一个空闲帧（一个数据帧长度的高电平），接下来就可以往USART_DR寄存器写入要发送的数据。在写入最后一个数据后，需等待UART状态寄存器（USART_SR）的TC位为1，表示数据传输完成。USART_CR1寄存器的TCIE位置1，则产生中断。</p>
<p>发送数据时，几个重要的标志位如下</p>
<p>TE 发送使能<br>TXE 发送寄存器为空，发送单个字节时使用<br>TC 发送完成，发送多个字节数据时候使用<br>TXIE 发送完成中断使能</p>
<p>接收器</p>
<p>将CR1寄存器的RE位置1，使能USART接收，使得接收器在RX线开始搜索起始位。在确定起始位后，就根据RX线电平状态把数据存放在接收移位寄存器内。接收完成后就把接收移位寄存器的数据移到PDR内，并把USART_SR寄存器的RXNE位置。如果USART_CR2寄存器的RXNEIE置1可以产生中断。</p>
<p>接收数据时，几个重要的标志位如下</p>
<p>RE 接收使能<br>RXNE:读数据寄存器非空。</p>
<p>RXNEIE:发送完成中断使能。</p>
<p>USART_CR1寄存器：<br>USART_CR2寄存器：<br>USART_CR3寄存器：</p>
<p>之后会基于STM32继续介绍怎样配置并使用UART，包括串口轮询&#x2F;中断&#x2F;DMA方式发送&#x2F;接收数据。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-VGA显示图像详细总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-VGA%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"
    >20221213-VGA显示图像详细总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-VGA%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2022-12-13T02:09:18.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44406200/article/details/103823607">https://blog.csdn.net/weixin_44406200/article/details/103823607</a></p>
<h2 id="VGA-显示原理"><a href="#VGA-显示原理" class="headerlink" title="VGA 显示原理"></a>VGA 显示原理</h2><p>VGA 概念</p>
<p>VGA 不是用来显示的那块屏幕，而是用来传输信号的接口，VGA 全称是video graphics array 及视频图形阵列，是模拟信号的一种视频传输标准，VGA 传输接口实物图如下</p>
<p>自测试 地址码 蓝基色  绿基色  红基色</p>
<p>数字地        蓝地  绿地   红地<br>地址码 场同步 行同步  地址码 地址码</p>
<p>操作VGA 的过程就是给你一块有横纵坐标范围的区域，区域上的每一个坐标点就是一个像素点，你可以做的事情是给这个像素点特定的rgb 色彩，既可以通过自定义rgb 也可以去取图像某个像素点的rgb ，这也就提供了你在vga 上画图以及显示图片的能力</p>
<p>VGA 分辨率及理解误区</p>
<p>640 * 480 的规格就是显示屏幕上每行有640 个像素点，总共有480行，注意，一件很重要的事情是，虽然你看到的屏幕上的大小是640 * 480 的 但是它实际大小并不只有那么点，形象一点就是说，VGA 的扫描范围是包含了你能够看到的640 480 这一块区域的更大区域，他会在周围一圈你看不到的区域部分进行扫描，因此，我们在处理扫描信号的时候一定要注意只有扫描到有效区域的时候才能把像素点数据传给 VGa 显示 </p>
<p>VGA 显示器扫描方式从屏幕左上角一点开始，从左向右逐点扫描，每扫描完一行，电子束回到屏幕的左边下一行的起始位置，在这期 间，CRT 对电子束进行消隐，每行结束时，用行同步信号进行同步，当扫描完所有的行，形成一帧，用场同步信号进行场同步，并使扫描回到屏幕左上方，同时进行场消隐，开始下一帧，完成一行扫描的时间称为水平扫描时间，其倒数称为行频率，完成一帧，扫描的时间称为垂直扫描时间，其倒数称为场频率，及屏幕的刷新频率，其扫描示意图如下图所示</p>
<p>有效显示区域</p>
<p>关于那一块非有效显示区域，实际上是因为每一行和每一列的扫描区间都是由以下几部分组成</p>
<p>行扫描  Hor Sync 、Hor Back Porch 、Hor Active Video和Hor Front Porch</p>
<p>Hor Scan Time 是一个扫描周期，它会先扫描到hor sync 再扫描 hor back porch 然后才进入有效显示区  hor active video 最后是一段 hor front porch 可以看出来，四段区间只有hor active video 这一段是能够正常显示图像信息的，也就是屏幕上显示的那一块区间</p>
<p>列扫描也同理</p>
<p>给定参数</p>
<p>实际上，根据固定的分辨率大小，比如我们实验室的板子使用的640 480 的屏幕大小，这些非有效区间的长度值都是一个固定的常数，因此你只要在扫描的时候把这些常数稍加处理即可</p>
<p>下图罗列了不同分辨率所对应的各个参数，其中的a、b、c、d、e、f、g、h、i、k的含义，与上面给出的两张图的标注一一对应；我们实验使用的是第一组数据，可以看到行时序参数中的c代表每一行的有效显示区间640，列时序参数中的h代表每一列的有效显示区间480</p>
<p>需要扫描频率，很重要的一件事，无论是行扫描还是给像素点赋值，我们都需要用一个时钟，这个时钟不是系统时针，必须要先将50MHZ 的时钟分频为25MHZ 然后拿去作为扫描信号的时钟</p>
<p>这一点是特别需要注意的，否则到时候会出现out of range 的现象</p>
<p>前期准备 coe 文件的生成</p>
<p>coe 和ip 核介绍</p>
<p>我们调用VGA 的终极目标是想要能够显示一张图片，在这之前，我们要先对这张图片进行一些预处理，因为我们是通过verilog 语言去调用图片数据的，但是verilog 并不知道怎么从一张已有的图片上去取相应的数据</p>
<p>因此我们要先将图片转换为coe 文件，coe 文件实际上就是按照某种规律将图像每一个像素点的rgb 数据都摆放成单独一行 16进制，然后借助ISE 的IP 核生成将coe 文件转化成ROM ，生成的ROM.xco 和ROM.v 文件就可以被verilog 语言所识别调用，最终就能够取到图像的数据了</p>
<p>24位bmp 图像转换为coe 文件 复原代码</p>
<p>为了统一规范，这里我们使用24位真彩色的bmp 格式图像进行转换，好处是，bmp 的三通道数据特征是非常明显的，易于处理</p>
<p>如何获取24位bmp 图像 </p>
<p>然后bmp 格式也有很多种，如单色 16色 24 256 ，这里我们统一选择24位位图选项，点击保存即可</p>
<p>使用matlab 将24位真彩色bmp 位图转化为coe 文件 </p>
<p>由于24位共rgb 三个通道，每个通道分到的是8位，占用资源太多，且老师给的ucf 引脚约束对rgb 每一个通道只给了4位，因此我们在转化为coe 文件的同时，要将每个通道压缩成4位，即整张图像同时转化为12位</p>
<p>压缩图像是一件非常重要的事情，因为经过后续的实践我们发现，板子内存资源有限，无法同时加载多张大图</p>
<p>为了能够对多张图像进行批量处理，我使用matlab 写了一个 img2coe.m 函数，只要对bmp 图像调用这个函数即可转换成coe 文件了，转换过程介绍如下</p>
<p>先将rgb 提取为三个通道，用reshape 函数对转置后的矩阵进行重组，对rgb 三个分量的数据都右移，舍去细节，留下高四位作为最终的数据，然后写入到coe 文件中</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">img2coe</span><span class="params">(path,name)</span></span></span><br><span class="line">    <span class="comment">% 利用imread函数把图片转化为一个三维矩阵</span></span><br><span class="line">    image_array = imread(path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 利用size函数把图片矩阵的三个维度大小计算出来</span></span><br><span class="line">    <span class="comment">% 第一维为图片的高度，第二维为图片的宽度，第三维为图片的RGB分量</span></span><br><span class="line">    [height,width,z]=<span class="built_in">size</span>(image_array);   </span><br><span class="line"></span><br><span class="line">    red   = image_array(:,:,<span class="number">1</span>); <span class="comment">% 提取红色分量，数据类型为uint8</span></span><br><span class="line">    green = image_array(:,:,<span class="number">2</span>); <span class="comment">% 提取绿色分量，数据类型为uint8</span></span><br><span class="line">    blue  = image_array(:,:,<span class="number">3</span>); <span class="comment">% 提取蓝色分量，数据类型为uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 把上面得到了各个分量重组成一个1维矩阵，由于reshape函数重组矩阵的</span></span><br><span class="line">    <span class="comment">% 时候是按照列进行重组的，所以重组前需要先把各个分量矩阵进行转置以后再重组</span></span><br><span class="line">    <span class="comment">% 利用reshape重组完毕以后，由于后面需要对数据拼接，所以为了避免溢出</span></span><br><span class="line">    <span class="comment">% 这里把uint8类型的数据扩大为uint32类型</span></span><br><span class="line">    r = uint32(<span class="built_in">reshape</span>(red&#x27;   , <span class="number">1</span> ,height*width));</span><br><span class="line">    g = uint32(<span class="built_in">reshape</span>(green&#x27; , <span class="number">1</span> ,height*width));</span><br><span class="line">    b = uint32(<span class="built_in">reshape</span>(blue&#x27;  , <span class="number">1</span> ,height*width));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 初始化要写入.coe文件中的RGB颜色矩阵</span></span><br><span class="line">    rgb=<span class="built_in">zeros</span>(<span class="number">1</span>,height*width);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 因为导入的图片是24-bit真彩色图片，每个像素占用24-bit，其中RGB分别占用8-bit</span></span><br><span class="line">    <span class="comment">% 而我这里需要的是12-bit，其中R为4-bit，G为4-bit，B为4-bit，所以需要在这里对24-bit的数据进行重组与拼接</span></span><br><span class="line">    <span class="comment">% bitshift()函数的作用是对数据进行移位操作，其中第一个参数是要进行移位的数据，第二个参数为负数表示向右移，为</span></span><br><span class="line">    <span class="comment">% 正数表示向左移，更详细的用法直接在Matlab命令窗口输入 doc bitshift 进行查看</span></span><br><span class="line">    <span class="comment">% 所以这里对红色分量先右移4位取出高4位，然后左移11位作为ROM中RGB数据的第11-bit到第8-bit</span></span><br><span class="line">    <span class="comment">% 对绿色分量先右移4位取出高4位，然后左移5位作为ROM中RGB数据的第7-bit到第4-bit</span></span><br><span class="line">    <span class="comment">% 对蓝色分量先右移4位取出高4位，然后左移0位作为ROM中RGB数据的第3-bit到第0-bit</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:height*width</span><br><span class="line">        rgb(<span class="built_in">i</span>) = bitshift(bitshift(r(<span class="built_in">i</span>),<span class="number">-3</span>),<span class="number">11</span>) + bitshift(bitshift(g(<span class="built_in">i</span>),<span class="number">-2</span>),<span class="number">5</span>) + bitshift(bitshift(b(<span class="built_in">i</span>),<span class="number">-3</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    fid = fopen( name , <span class="string">&#x27;w+&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">% .coe文件的最前面一行必须为这个字符串，其中16表示16进制</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;memory_initialization_radix=16;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% .coe文件的第二行必须为这个字符串</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;memory_initialization_vector =\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 把rgb数据的前 height*width-1  个数据写入.coe文件中，每个数据之间用逗号隔开</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;%x,\n&#x27;</span>,rgb(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 把rgb数据的最后一个数据写入.coe文件中，并用分号结尾</span></span><br><span class="line">    fprintf( fid, <span class="string">&#x27;%x;&#x27;</span>,rgb(<span class="keyword">end</span>));</span><br><span class="line"></span><br><span class="line">    fclose( fid ); <span class="comment">% 关闭文件指针</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<p>中期准备 coe 转换为rom </p>
<p>经过上面的步骤我们已经得到了coe 文件</p>
<p>接下来就是把它转化成verilog 能够调用的rom 文件了 </p>
<p>在ISE 工程中，点击右键新建文件，选择ip 核生成 </p>
<p>选择Memories选项中的RAMs&amp;ROMs里的Block Memory Generator</p>
<p>然后进入到这个设置参数的界面</p>
<p>其中width代表你设置的图片数据是几进制，由于之前写coe的时候是用16进制写的，因此这里写16；depth表示图像的大小，即长乘宽，由于我使用的是640<em>480的图片，因此这里填207200(&#x3D;640</em>480)</p>
<p>当你的文件路径成功出现的时候，你就可以点击下方的generate生成了，当然这个generate也要很久很久，一般一张640 *480的图片要generate近一个小时左右才能生成</p>
<p>生成完毕的标志是creating结束，并且在你的目录下出现类型太阳的这个标记</p>
<p>后期调用与测试 </p>
<p>VGA 显示的过程中会遇到很多小bug 有些小bug 的原因你根本找不出，比如 out of range ，你只能静下心来慢慢调试仿真</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221212-SPI协议详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/12/20221212-SPI%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"
    >20221212-SPI协议详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/12/20221212-SPI%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-12-12T11:58:24.000Z" itemprop="datePublished">2022-12-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/290620901">https://zhuanlan.zhihu.com/p/290620901</a></p>
<p>UART 没有时钟信号，无法控制何时发送数据，也无法保证双方按照完全相同的速度接收数据，因此，双方以不同的速度进行数据接收和发送，就会出现问题</p>
<p>如果要解决这个问题，uart 为每个字节添加额外的起始位和停止位，以帮助接收器在数据到达时进行同步</p>
<p>双方还必须事先就传输速度达成共识，设置相同的波特率 例如每秒9600位</p>
<p>传输速率如果有微小差异不是问题，因为接收器会在每个字节的开头重新同步</p>
<p>如果您注意到上图中的11001010不等于0x53，这是一个细节。串口协议通常会首先发送最低有效位，因此最小位在最左边LSB。低四位字节实际上是0011 &#x3D; 0x3，高四位字节是0101 &#x3D; 0x5。</p>
<p>异步串行工作得很好，但是在每个字节发送的时候都需要额外的起始位和停止位 以及在发送和接收数据所需的复杂硬件方面都有很多开销</p>
<p>不难发现，如果接收端和发送端设置的速度都不一致，那么接收到的数据将是垃圾 乱码</p>
<h2 id="SPI-通讯协议"><a href="#SPI-通讯协议" class="headerlink" title="SPI 通讯协议"></a>SPI 通讯协议</h2><p>spi 是一个同步的数据总线，也就是说它是用单独的数据线和一个单独的时钟信号来保证发送端和接收端的完美同步</p>
<p>时钟是一个振荡信号，它告诉接收端在确切的时机对数据线上的信号进行采样</p>
<p>产生时钟的一侧称为主机，另一侧为从机，总是只有一个主机 一般来说可以是微控制器 MCU 但是可以有多个从机</p>
<p>数据的采集时机可能是时钟信号的上升沿 或下降沿</p>
<p>具体要看对 spi 的配置</p>
<p>整体的传输大概可以分为以下几个过程</p>
<p>主机先将NSS 信号拉低，这样保证开始接收数据</p>
<p>当接收端检测到时钟的边沿信号时，它将立即读取数据线上的信号，这样就得到了一位数据 1bit</p>
<p>由于时钟是随数据一起发送的，因此指定数据的传输速度并不重要，尽管设备将具有可以运行的最高速度</p>
<p>主机发送到从机时：主机产生相应的时钟信号，然后数据一位一位地将从MOSI信号线上进行发送到从机；<br>主机接收从机数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过MISO信号线发送；</p>
<p>注意  spi 是全双工 具有单独的发送和接收线路，因此可以在同一时间发送和接收数据，另外 spi 的接收硬件可以是一个简单的移位寄存器，这笔异步串行通信所需的完整uart 要简单得多，并且更加便宜</p>
<p>spi 特性</p>
<p>spi 总线包括4条 逻辑线，定义如下</p>
<p>MISO 主机输入，从机输出，数据来自从机</p>
<p>MOSI 主机输出，从机输入</p>
<p>SCLK 串行时钟信号，由主机产生发送给从机</p>
<p>SS 片选信号，由主机发送，以控制与哪个从机通信，通常是低电平有效信号</p>
<p>其他制造商可能会遵循其他命名规则，但是最终他们指的相同的含义。以下是一些常用术语；</p>
<p>MISO也可以是SIMO，DOUT，DO，SDO或SO（在主机端）;<br>MOSI也可以是SOMI，DIN，DI，SDI或SI（在主机端）;<br>NSS也可以是CE，CS或SSEL;<br>SCLK也可以是SCK;<br>本文将按照以下命名进行讲解[MISO, MOSI, SCK，NSS]</p>
<p>时钟频率</p>
<p>SPI 总线上的主机必须在通信开始时候配置并生成相应的时钟信号，在每个SPI 时钟周期内，都会发生全双工数据传输</p>
<p>主机在mosi 线上发送一位数据，从机读取它，而从机在miso 线上发送一位数据，主机读取它</p>
<p>就算只进行单向的数据传输，也要保持这样的顺序，这就意味着无论接收任何数据，必须实际发送一些东西，在这种情况下，我们称其为虚拟数据</p>
<p>从理论上讲，只要实际可行，时钟速率就可以是您想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的SPI传输速率。</p>
<p>时钟极性 CKP Clock Polarity</p>
<p>除了配置串行时钟频率 外，SPI 主设备还需要配置时钟极性</p>
<p>根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据；</p>
<p>CKP 可以配置为1或0 ，这意味着您可以根据需要将时钟的默认状态 IDLE 设置为高或低，极性反转可以通过简单的逻辑逆变器实现，您必须参考设备的数据手册才能正确设置CKP 和CKE</p>
<p>CKP &#x3D; 0：时钟空闲IDLE为低电平0；<br>CKP &#x3D; 1：时钟空闲IDLE为高电平1；</p>
<p>时钟相位 CKE Clock Phase Edge</p>
<p>除配置串行时钟速率和极性外，SPI 主设备还应配置时钟相位，根据硬件制造商的不同，时钟相位通常写为CKE 或CPHA</p>
<p>顾明思义，时钟相位&#x2F;边沿，也就是采集数据时是在时钟信号的具体相位或者边沿</p>
<p>CKE &#x3D; 0 在时钟信号SCK 的第一个跳变沿采样</p>
<p>CKE &#x3D; 1 在时钟信号SCK 的第二个跳变沿采样</p>
<p>时钟配置总结</p>
<p>综上几种情况，下图总结了所有时钟配置组合，并突出显示了实际采样数据的时刻</p>
<p>其中黑色线为采样数据的时刻</p>
<p>蓝色线为SCK 时钟信号</p>
<p>具体如下图所示</p>
<p>模式编号</p>
<p>SPI 的时钟极性和相位的配置通常称为SPI 模式，所有可能的模式都遵循以下约定，具体如下表所示</p>
<p>除此之外，我们还应该仔细检查微控制器数据手册中包含的模式表，以确保一切正常</p>
<p>多从机模式</p>
<p>前面说到的SPI 总线必须有一个主机，可以有多个从机，那么具体连接到SPI 总线的方法有以下两种</p>
<p>第一种方法 多NSS</p>
<p>通常，每个从机都需要一条单独的SS 线</p>
<p>如果要和特定的从机进行通讯，可以将相应的NSS 信号线拉低，并保持其他NSS 信号线的状态为高电平，如果同时将两个NSS 信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条MISO 线上传输数据，最终导致接收数据乱码</p>
<p>具体连接方式如下图所示</p>
<p>第二种方法 菊花链</p>
<p>在数字通信世界中，在设备信号 （总线信号或中断信号） 以串行的方式从一个设备依次传到下一个设备，不断循环直到数据到达目标设备的方式被称为菊花链</p>
<ol>
<li>菊花链的最大缺点是因为信号串行传输，所以一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了</li>
</ol>
<p>另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况</p>
<p>具体的连接如下图所示</p>
<p>其中红线加粗为数据的流向</p>
<p>所以最终的数据流向图可以表示为</p>
<p>SCK 为时钟信号，8clks 表示8个边沿信号</p>
<p>其中D 为数据，X 为无效数据</p>
<p>所以不难发现，菊花链模式充分使用了SPI 其移位寄存器的功能，整个链充当通信移位寄存器，每个从机在下一个时钟周期将输入数据复制到输出</p>
<p>优缺点</p>
<p>SPI 通讯的优势</p>
<p>使SPI 作为串口通信接口脱颖而出的原因很多</p>
<p>全双工串行通信；<br>高速数据传输速率。<br>简单的软件配置；<br>极其灵活的数据传输，不限于8位，它可以是任意大小的字；<br>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。</p>
<p>SPI 的缺点 </p>
<p>没有硬件从机应答信号  主机可能在不知情的情况下无处发送</p>
<p>通常仅支持一个主设备</p>
<p>需要更多的引脚 与I2C 不同</p>
<p>没有定义硬件级别的错误检查协议</p>
<p>与RS232 和CAN 总线相比，只能支持非常短的距离</p>
<p>编程实现<br>下面是通过STM32的cubemx自动生成的HAL库代码，比较简单，截取了其中一部分，具体如下；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_SPI1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hspi1.Instance = SPI1;</span><br><span class="line">    hspi1.Init.Mode = SPI_MODE_MASTER;    <span class="comment">//主机模式</span></span><br><span class="line">    hspi1.Init.Direction = SPI_DIRECTION_2LINES; <span class="comment">//全双工</span></span><br><span class="line">    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;  <span class="comment">//数据位为8位</span></span><br><span class="line">    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;  <span class="comment">//CPOL=0</span></span><br><span class="line">    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;   <span class="comment">//CPHA为数据线的第一个变化沿</span></span><br><span class="line">    hspi1.Init.NSS = SPI_NSS_SOFT;     <span class="comment">//软件控制NSS</span></span><br><span class="line">    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;<span class="comment">//2分频，32M/2=16MHz</span></span><br><span class="line">    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;   <span class="comment">//最高位先发送</span></span><br><span class="line">    hspi1.Init.TIMode = SPI_TIMODE_DISABLE;   <span class="comment">//TIMODE模式关闭</span></span><br><span class="line">    hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;<span class="comment">//CRC关闭</span></span><br><span class="line">    hspi1.Init.CRCPolynomial = <span class="number">10</span>;     <span class="comment">//默认值，无效</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_SPI_Init(&amp;hspi1) != HAL_OK)    <span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        _Error_Handler(__FILE__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">HAL_StatusTypeDef  </span><br><span class="line"><span class="title function_">HAL_SPI_Transmit</span><span class="params">(SPI_HandleTypeDef *hspi, </span></span><br><span class="line"><span class="params">                 <span class="type">uint8_t</span> *pData, </span></span><br><span class="line"><span class="params">                 <span class="type">uint16_t</span> Size, </span></span><br><span class="line"><span class="params">                 <span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">HAL_StatusTypeDef  </span><br><span class="line"><span class="title function_">HAL_SPI_Receive</span><span class="params">(SPI_HandleTypeDef *hspi, </span></span><br><span class="line"><span class="params">                <span class="type">uint8_t</span> *pData, </span></span><br><span class="line"><span class="params">                <span class="type">uint16_t</span> Size, </span></span><br><span class="line"><span class="params">                <span class="type">uint32_t</span> Timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>% SPI、UART、RS232、RS485、IIC 5</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221212-RS2329针串口定义"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/12/20221212-RS2329%E9%92%88%E4%B8%B2%E5%8F%A3%E5%AE%9A%E4%B9%89/"
    >20221212-RS2329针串口定义</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/12/20221212-RS2329%E9%92%88%E4%B8%B2%E5%8F%A3%E5%AE%9A%E4%B9%89/" class="article-date">
  <time datetime="2022-12-12T11:43:43.000Z" itemprop="datePublished">2022-12-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>电脑 9 针串口<br>电脑串口引脚定义<br>这里写图片描述<br>按序号说明：<br>1 载波检测(DCD)<br>2 接受数据(RXD)<br>3 发出数据(TXD)<br>4 数据终端准备好(DTR)<br>5 信号地线(SG)<br>6 数据准备好(DSR)<br>7 请求发送(RTS)<br>8 清除发送(CTS)<br>9 振铃指示(RI)<br>串口母头连接器的管脚定义<br>这里写图片描述<br>此上为计算机串口管脚定义说明。<br>1、 RS-232C 母接头定义(9 芯)：<br>这里写图片描述<br>注意图和总引脚的标号。<br>针脚 定义 符号<br>1 载波检测 DCD<br>2 接收数据 RXD<br>3 发送数据 TXD<br>4 数据终端准备好 DTR<br>5 信号地 SG<br>6 数据准备好 DSR<br>7 请求发送 RTS<br>8 清除发送 CTS<br>9 振铃提示 RI<br>Pin 1 Received Line Signal Detector(Data Carrier Detect)<br>Pin 2 Received Data<br>Pin 3 Transmit Data<br>Pin 4 Data Terminal Ready<br>Pin 5 Signal Ground<br>Pin 6 Data Set Ready<br>Pin 7 Request To Send<br>Pin 8 Clear To Send<br>Pin 9 Ring Indicator</p>
<p>2、 RS-232C 母接头定义(25 芯)<br>针脚 定义 符号<br>1 频蔽地线<br>2 发送数据 TXD<br>3 接收数据 RXD<br>4 请求发送 RTS<br>5 允许发送 CTS<br>6 数据准备好 DSR<br>7 信号地 SG<br>8 载波检测 DCD<br>9 发送返回(+)<br>10 未定义<br>11 数据发送(-)<br>12<del>17 未定义<br>18 数据接收(+)<br>19 未定义<br>20 数据终端准备好 DTR<br>21 未定义<br>22 振铃 RI<br>23</del>24 未定义<br>25 接收返回(-)<br>Pin 1 Protective Ground<br>Pin 2 Transmit Data<br>Pin 3 Received Data<br>Pin 4 Request To Send<br>Pin 5 Clear To Send<br>Pin 6 Data Set Ready<br>Pin 7 Signal Ground<br>Pin 8 Received Line Signal Detector<br>(Data Carrier Detect)<br>Pin 20 Data Terminal Ready<br>Pin 22 Ring Indicator<br>RS-232C,25 芯针转换为 9 芯针<br>这里写图片描述</p>
<p><strong>二、 补充 （几个小时的查询和求助才弄明白的，呵呵，珍贵<br>啊）</strong><br>1.RX232 公接头的图片和引脚编号 ：<br>这里写图片描述<br>2.从两个图可以看出， 公接头和母接头相连时 rx-rx，<br>tx-tx，进而可知下载线的两端接口本应该 rx-rx、t<br>x-tx 的，但买串口线时需要买交叉串口线（实现 RX-<br>tx 的连接），进而实现一段发送一段接收。<br>三、更详细的引脚标号规则（超准）<br>DB9 Male (Pin Side) DB9 Female (Pin Side)<br>DB9 Female (Solder Side) DB9 Male (Solder Side)<br>这里写图片描述<br>1 ，RS232 的定义：<br>RS-232 串行接口标准详细介绍<br>目前 RS-232 是 PC 机与通信工业中应用最广泛的一种串行接口。RS-232 被定义为一种在低速率串<br>行通讯中增加通讯距离的单端标准。RS-232 采取不平衡传输方式，即所谓单端通讯。<br>这里写图片描述<br>图一<br>在 RS-232 的通讯标准中是以一个 25 针的接口来定义的，并在早期的计算机如 PC 或 XT 机型上广<br>泛使用，但在 AT 机以后的机型上，实际均采用了 9 针的简化版本应用，现在所说的 232 通讯均默认为 9<br>针的接口。图一显示了 9 针通讯的接口管脚名称，以下是各管脚的说明：<br>这里写图片描述<br>现在通常计算机均配有这种标准的 232 接口，通常这种接口用于联接鼠标、MODEM 或打印机等外<br>部设备。<br>实际应用中，电子工程师在设计计算机与外围设备的通信时，通常在 9 针的基础再进行简化，只用<br>其中的 2、3、5 三个管脚进行通信。这三个管脚分别是接收线、发送线和地线，在一般情况下即可满足通<br>讯的要求，计算机和外部通讯的接线方法如图二：<br>这里写图片描述<br>值得注意的是，图二中 2、3 两脚是交叉互联的，这很容易理解，因为一个设备的发送线必须联接到<br>另外一台设备的接收线上，反之亦然。<br>对于 232 信号的电器特性等知识，在这里无法详细解说，有兴趣的话可以去网站查阅这方面的文章，<br>232 是最常用的通信方式之一，大量应用于各种工业控制或电子家电等产品中，是电子工程师必须掌握的<br>知识之一。<br>另外说明一下，232 信号的有效通讯距离是 15M。<br>2.RS232 TO TTL 电路：</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221212-蓝牙协议分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/12/20221212-%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"
    >20221212-蓝牙协议分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/12/20221212-%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2022-12-12T09:26:15.000Z" itemprop="datePublished">2022-12-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/482020575">https://zhuanlan.zhihu.com/p/482020575</a></p>
<p>本文介绍蓝牙协议的基本特点，版本演进，协议的构成，学习路线等基础知识分享</p>
<p>​ 蓝牙（英语：Bluetooth），一种无线通讯技术标准，用来让固定与移动设备，在短距离间交换资料，以形成个人局域网（PAN）。其使用短波特高频（UHF）无线电波，经由2.4至2.485 GHz的ISM频段来进行通信。1994年由电信商爱立信（Ericsson）发展出这个技术。它最初的设计，是希望创建一个RS-232数据线的无线通信替代版本。它能够链接多个设备，克服同步的问题。</p>
<p>技术类型 </p>
<p>蓝牙技术分为 基础率 增强数据率，和低功耗 LE 两种技术类型，其中 、BR EDR 是以点对点网络拓扑结构创建一对一设备通信 LE 型则使用点对点 一对一 广播 一对多和网格 多对多 等多种网络拓扑结构</p>
<p>蓝牙技术联盟（英语：Bluetooth Special Interest Group，缩写为SIG）拥有蓝牙的商标，负责制定蓝牙规范、认证制造厂商，授权他们使用蓝牙技术与蓝牙标志，但本身不负责蓝牙设备的设计、生产及贩售。</p>
<p>蓝牙 2.x EDR<br>加入了非跳跃窄频通道，因为不需要与每个设备交换应答信号，这种通道可以用来将给中器件的蓝牙服务概要同时广播到巨量的蓝牙器件，应答信号交换过程当前需要大约一秒，实时公共交通的时刻表，基本的交通畅通性信息和高级交通指向指示灯未加密信息可以以高速度发送给设备，更高的连接速度，支持多个速度水平 </p>
<p>​ 2007年7月26日，蓝牙技术联盟通过了蓝牙核心规范2.1+EDR，向下对1.2版本完全兼容，并增加了Sniff省电功能，使得适配器与设备的联系时间延长到0.5秒，能节约不小电量；增强功能有简单安全配对（SSP），这改善了蓝牙设备的配对经验，同时提升了使用和安全强度。</p>
<p>蓝牙 3.0 HS</p>
<p>是一种全新的交替射频技术，蓝牙3.0 + HS 提高了资料传输速率，集成802.11 PAL 最高速度可达24Mbps 此外引入了增强电源控制，实际空闲功耗明显降低</p>
<p>蓝牙 4.x </p>
<p>提出了低功耗蓝牙 传统蓝牙 和高速蓝牙  三种模式</p>
<p>高速蓝牙 主攻数据交换与传输</p>
<p>传统蓝牙 则以信息沟通，设备连接为重点</p>
<p>低功耗蓝牙 以不需要占用太多带宽的设备连接为主，</p>
<p>这三种协议规范还能够互相组合搭配，从而实现更广泛的应用模式，此外，Bluetooth 4.0 还包蓝牙的传输距离提升到100米以上  低功耗模式调条件下</p>
<p>调频 使用所有蓝牙规范版本通用的自适应调频，最大程度地减少 和其他 2.4GHz ISM 频段无线技术的串扰</p>
<p>蓝牙 5.x </p>
<p>在有效传输距离上将是4.2 LE 版本的4倍 传输速度将是4.2LE 版本的2倍 </p>
<p>蓝牙5.0 还支持室内定位导航功能，允许无需配对接受信标的数据 ，针对物联网进行了很多底层优化</p>
<p>1.6 总结 </p>
<p>我们常说的蓝牙4.0 不等同于BLE BLE 只是蓝牙4.0 的子集，蓝牙4.0 是一个综合性协议规范</p>
<p>蓝牙4.0 版本以后技术模式上分为低功耗蓝牙 和经典蓝牙 两种，市场芯片多数为仅支持BLE 的，也有两者都支持的 双模蓝牙芯片</p>
<p>蓝牙芯片的三种功能配置 </p>
<ol start="2">
<li>蓝牙协议栈</li>
</ol>
<p>蓝牙协议栈由主机 +HCI 可选 +控制器三大块组成，其中对于单芯片方案是没用HCI 的 </p>
<p>主机 Host 主机部分由核心协议层 和核心规范构成</p>
<p>控制器 此部分拆分为低功耗蓝牙和经典蓝牙两个章节说明</p>
<p>HCI 此部分定义了主机和控制器之间通信的接口标准，可以是UART USB 等通信方式 </p>
<p>上图中红色部分是 BR&#x2F;RED 经典蓝牙的必选项，绿色部分是LE 低功耗蓝牙必选项，蓝色部分是公共部分，当然经典蓝牙也可以具备绿色部分特性，HCI 接口根据芯片架构有关，是可选项，两者在物理层的差异性图中没有体现，不涉及芯片设计，这块可暂不关注 </p>
<p>GPA 规范，通用接入规范，定义了所有蓝牙设备的基础功能，设备键发现，连接、配对，绑定的流程，蓝牙设备中四种角色，广播和扫描响应报文的格式，还有一些通用蓝牙参数定义，比如设备地址，名称、配对密钥和设备的外观特征值，用于区分是什么设备，手机还是电脑；明确了作为一个低功耗蓝牙设备的基本需求，包含哪些层级以及如何协同工作的，规范了一些通用的蓝牙参数，蓝牙设备地址、设备名称、配对密钥、外观特征值  用于区分是手机还是电脑</p>
<p>ATT 属性协议，定义了访问对端设备上数据的一组规则，是GATT 规范的基础，也是低功耗蓝牙的基石，定义了host 端属性报文格式和报文类型</p>
<p>GATT 通用属性规范，位于ATT 之上，定义了属性的类型及其使用方法，GATT 用来规范attribute 中的数据内容，并运用 group 的概念对attribute 进行分类管理，没有GATT BLE 协议栈也能跑，但互联互通就会出现问题</p>
<p>L2CAP 层，屏蔽了控制器传输协议中的许多特性，方便高层协议的开发，报文分片和重组，SAR 流控，重传 报文完整性校验等</p>
<p>SMP 安全管理协议，定义了蓝牙设备配对，认证，解密等行为的安全操作</p>
<p>LLCP LL 链路层控制，</p>
<p>PHY 物理层，低功耗蓝牙采用40个信道，分为数据信道和广播信道；广播信道占用3个，用于发现设备、建立连接、广播数据；数据信道占用37个，用于已建立连接设备间的数据通信。建立连接的两个设备，必须同一时间处于同一信道上才能通信。</p>
<ol start="3">
<li>学习路线</li>
</ol>
<p>此部分给出低功耗蓝牙的基本学习路线，不一定适合所有人</p>
<p>初步理解协议栈基本组成、专业术语，对协议栈有整体的认识。<br>结合相关项目抓包分析，结合理论和实际表现分析每个子过程，比如ble广播功能、ble建立连接等。有条件的可以整个开发板，都有配套教程代码，可以直接运行的。<br>相关协议栈源码移植和学习，推荐Zephyr.<br>4. 协议文档<br>蓝牙联盟官方下载入口：<a target="_blank" rel="noopener" href="http://www.bluetooth.com/">http://www.bluetooth.com</a><br>个人网盘分享：<a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/dhKyo">https://www.aliyundrive.com/s/dhKyo</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221212-MQTT协议笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/12/20221212-MQTT%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/"
    >20221212-MQTT协议笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/12/20221212-MQTT%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-12-12T08:18:48.000Z" itemprop="datePublished">2022-12-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/mqtt-intro.html">https://www.runoob.com/w3cnote/mqtt-intro.html</a></p>
<p>MQTT 入门介绍</p>
<p>MQTT 消息队列遥测传输协议，是一种基于发布&#x2F;订阅模式的轻量级 通讯协议，该协议构建于TCP&#x2F;IP 协议上，由IBM 在1999年发布，MQTT 最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务，作为一种低开销，低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用</p>
<p>MQTT 是一个基于客户端-服务器的消息发布&#x2F;订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<p>二、设计规范</p>
<p>由于物联网的环境是非常特别的，所以MQTT 遵循以下设计原则</p>
<p>精简，不添加有可无的功能</p>
<p>发布&#x2F;订阅 模式，方便消息在传感器之间传递</p>
<p>允许用户动态创建主题，零运维成本</p>
<p>把传输量降到最低以提高传输效率</p>
<p>把低带宽、高延迟、不稳定的网络等因素考虑在内</p>
<p>支持连续的会话控制</p>
<p>理解客户端计算能力可能很低</p>
<p>提供服务质量管理</p>
<p>假设数据不可知，不强求传输数据的类型与格式，保持灵活性</p>
<h2 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h2><p>MQTT 协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性。</p>
<p>使用发布&#x2F;订阅消息模式，提供一对多的消息发布，解除应用程序耦合</p>
<p>这一点很类似于XMPP，但是MQTT 的信息冗余远小于XMPP，因为XMPP 使用XML 格式文本来传递数据</p>
<p>对负载内容屏蔽的消息传输</p>
<p>使用TCP&#x2F;IP提供网络连接</p>
<p>主流的MQTT 是基于TCP 连接进行数据推送的，但是同样有基于UDP 的版本，叫做MQTT-SN 这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了</p>
<p>有三种消息发布服务质量</p>
<p>至多一次，消息发布完全依赖底层TCP&#x2F;IP 网络，会发生消息丢失或重复，这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送，这一种方式主要普通APP 的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了</p>
<p>至少一次，确保消息到达，但消息重复可能会发生</p>
<p>只有一次，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别，在计费系统中，消息重复或丢失会导致不正确的结果，这种最高质量的消息发布服务还可以用于即时通讯类的app 的推送，确保用户收到且只会收到一次</p>
<p>小型传输，开销很小，协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合  在物联网领域，传感器与服务器的通信，信息的收集，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了</p>
<p>使用 last will 和testament特性通知有关各客户端异常中断的机制</p>
<p>last will  即遗言机制，用于同位置同一主题下的其他设备发送遗言的设备已经断开了连接</p>
<p>testament  医嘱机制，功能类似于  last will </p>
<p>MQTT 协议原理 </p>
<p>实现MQTT 协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT 协议中有三种身份 发布者，代理，服务器，订阅者，其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者</p>
<p>MQTT 传输的消息分为，主题，和负载 两部分</p>
<p>topic 可以理解为消息的类型，订阅者订阅后，就会收到该主题的消息内容</p>
<p>payload 可以理解为消息的内容，是指订阅者具体要使用的内容</p>
<p>4.2 网络传输与应用消息</p>
<p>MQTT 会构建底层网络传输，它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输</p>
<p>当应用数据通过MQTT 网络发送时，MQTT 会把与之相关的服务质量和主题名 相关连</p>
<p>MQTT 客户端</p>
<p>一个使用MQTT 协议的应用程序或者设备，它总是建立到服务器的网络连接，客户端可以</p>
<p>发布其他客户端可能会订阅的信息</p>
<p>订阅其他客户端发布的消息</p>
<p>退订或删除应用程序的消息</p>
<p>断开与服务器连接</p>
<p>4.4 MQTT 服务器</p>
<p>MQTT 服务器以称为消息代理，可以是一个应用程序或一台设备，它是位于消息发布者和订阅者之间，它可以</p>
<p>接受来自客户的网络连接</p>
<p>接受客户发布的应用信息</p>
<p>处理来自客户端的订阅和退订请求</p>
<p>向订阅的客户转发应用程序消息</p>
<p>4.5 MQTT 协议中的订阅、主题、会话</p>
<p>订阅 </p>
<p>订阅包含主题筛选器 和最大服务质量，订阅会与一个会话关联，一个会话可以包含多个订阅，每一个会话中的每个订阅都有一个不同的主题筛选器</p>
<p>会话</p>
<p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互，会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接、</p>
<p>主题名</p>
<p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配，服务器会将消息发送给订阅所匹配标签的每个客户端</p>
<p>主题筛选器</p>
<p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题</p>
<p>负载</p>
<p>消息订阅者所具体接收的内容</p>
<p>MQTT 协议中的方法</p>
<p>MQTT 协议中定义了一些方法 也被称为动作，来于表示对确定资源所进行操作，这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现，通常来说，资源指服务器上的文件或输出，主要方法有</p>
<p>connect 等待与服务器建立连接</p>
<p>disconnect 等待MQTT 客户端完成所做的工作，并与服务器断开TCP&#x2F;IP 会话</p>
<p>subscribe 等待完成订阅</p>
<p>unsubscribe 等待服务器取消客户端的一个或多个topics 订阅 </p>
<p>publish MQTT 客户端发送消息请求，发送完成后返回应用程序线程</p>
<p>MQTT 协议数据包结构</p>
<p>在MQTT 协议中，一个MQTT 数据包由固定头，可变头，消息体 三部分构成，MQTT 数据包结构如下</p>
<p>固定头 fixed header  存在于所有MQTT 数据包中，表示数据包类型及数据包的分组类表示</p>
<p>可变头  存在于部分MQTT 数据包中，数据包类型 决定了可变头是否存在及其具体内容</p>
<p>消息体 pyload  存在于部分MQTT 数据包中，表示客户端收到的具体内容</p>
<p>MQTT 固定头  </p>
<p>固定头存在于所有MQTT 数据包中，其结构如下</p>
<p>MQTT 数据包类型 </p>
<p>位置byte1 中bits 7-4 </p>
<p>相当于一个4位的无符号值，类型，取值及描述如下</p>
<p>标识位</p>
<p>在不使用标识位的消息类型中，标识位被作为保留位，如果收到无效的标志时，接收端必须关闭网络连接</p>
<p>DUP 发布消息 的副本，用来在保证消息的可靠传输，如果设置为1  则在下面的变长中增加 messageid 并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送</p>
<p>QoS 发布消息的服务质量，即：保证消息传递的次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ø00：最多一次，即：&lt;=1</span><br><span class="line"></span><br><span class="line">Ø01：至少一次，即：&gt;=1</span><br><span class="line"></span><br><span class="line">Ø10：一次，即：=1</span><br><span class="line"></span><br><span class="line">Ø11：预留</span><br></pre></td></tr></table></figure>

<p>RETAIN 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把消息推送给它，如果没有那么推送至当前订阅者后释放</p>
<p>剩余长度</p>
<p>固定头的第二字节用来保存变长头部和消息体的总大小，但不是直接保存的，这一字节是可以扩展的，其保存机制，前7位用于保存长度，后一部用作标识，当最后一位为1时，表示长度不足，需要使用两个字节继续保存，例如，计算出后面的大小为0 </p>
<p>MQTT 可变头 </p>
<p>MQTT 数据包中包含一个可变头，它驻位于固定的头和负载之间，可变头的内容因数据包类型而不同，较常的应用是作为包的标识</p>
<p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有</p>
<p>PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p>
<p>Payload 消息体 </p>
<p>payload 消息体位MQTT 数据包的第三部分，包含 connect subscribe  subback unsubscribe 四种类型的消息</p>
<p>connect 消息体内容主要是客户端的clientID 订阅的topic message 以及用户名和密码 </p>
<p>subscribe 消息体内容是一系列的要订阅的主题以及QoS</p>
<p>suback 消息体内容是服务器对于subscribe 所申请的主题及QoS 进行确认和回复</p>
<p>unsubscribe  消息体内容是要订阅的主题</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221212-贪吃蛇小游戏"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/12/20221212-%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F/"
    >20221212-贪吃蛇小游戏</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/12/20221212-%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F/" class="article-date">
  <time datetime="2022-12-12T04:59:14.000Z" itemprop="datePublished">2022-12-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_TIME 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义direction的每个值代表的方向</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOWN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[H][W];        <span class="comment">//地图数组</span></span><br><span class="line"><span class="type">int</span> s[H*W][<span class="number">2</span>];      <span class="comment">//蛇身坐标数组</span></span><br><span class="line"><span class="type">int</span> sLength;        <span class="comment">//蛇的长度</span></span><br><span class="line"><span class="type">int</span> direction;      <span class="comment">//蛇的方向</span></span><br><span class="line"><span class="type">bool</span> eated=<span class="literal">false</span>;   <span class="comment">//标记是否吃到食物</span></span><br><span class="line"><span class="type">int</span> score=<span class="number">0</span>;        <span class="comment">//得分</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>         <span class="comment">//程序开始时的初始化操作</span></span><br><span class="line">&#123;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));            <span class="comment">//设置随机数种子为现在的时间</span></span><br><span class="line">    CONSOLE_CURSOR_INFO cursor_info = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);    <span class="comment">//隐藏关标</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;H; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i][<span class="number">0</span>]=<span class="number">1</span>;          <span class="comment">//让第一列为1</span></span><br><span class="line">        a[i][W<span class="number">-1</span>]=<span class="number">1</span>;        <span class="comment">//让最后一列为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;W; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>][j]=<span class="number">1</span>;      <span class="comment">//让第一行为1</span></span><br><span class="line">        a[H<span class="number">-1</span>][j]=<span class="number">1</span>;    <span class="comment">//让最后一行为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    sLength=<span class="number">4</span>;          <span class="comment">//让蛇的最初长度为4</span></span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>]=H/<span class="number">2</span>;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">1</span>]=W/<span class="number">2</span>;        <span class="comment">//给蛇头坐标赋值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i][<span class="number">0</span>]=s[<span class="number">0</span>][<span class="number">0</span>]+i;</span><br><span class="line">        s[i][<span class="number">1</span>]=s[<span class="number">0</span>][<span class="number">1</span>];  <span class="comment">//给刚开始的蛇身几个初始坐标</span></span><br><span class="line">    &#125;</span><br><span class="line">    direction=UP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gotoxy</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>        <span class="comment">//移动光标</span></span><br><span class="line">&#123;</span><br><span class="line">    COORD position= &#123;j,i&#125;;</span><br><span class="line">    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> ii,<span class="type">int</span> jj)</span>        <span class="comment">//判断这个点能不能放食物，可以放返回1，不能放返回0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[ii][jj]==<span class="number">1</span>)        <span class="comment">//如果有障碍物，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ii==s[i][<span class="number">0</span>]&amp;&amp;jj==s[i][<span class="number">1</span>])      <span class="comment">//如果和其中一个蛇身重合，就返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ii==<span class="number">0</span>||ii==H<span class="number">-1</span>||jj==<span class="number">0</span>||jj==W<span class="number">-1</span>)      <span class="comment">//如果在边界上面，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">//最后筛选 过后的是符合条件的点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">food</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=rand()%H;                 <span class="comment">//生成0~H-1之间的一个数</span></span><br><span class="line">        j=rand()%W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(check(i,j)==<span class="number">0</span>);           <span class="comment">//生成点直到满足条件</span></span><br><span class="line">    a[i][j]=<span class="number">-1</span>;                     <span class="comment">//标记为食物</span></span><br><span class="line">    gotoxy(i,j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;$&quot;</span>);                    <span class="comment">//画出食物</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drawMap</span><span class="params">()</span>                  <span class="comment">//画地图</span></span><br><span class="line">&#123;</span><br><span class="line">    gotoxy(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;H; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;W; j++)          <span class="comment">//两重for循环遍历数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)          <span class="comment">//为0输出空格</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>                    <span class="comment">//为1输出#</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);               <span class="comment">//别忘了换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    gotoxy(s[sLength<span class="number">-1</span>][<span class="number">0</span>],s[sLength<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);                            <span class="comment">//在尾巴上面画空格以擦除尾巴</span></span><br><span class="line">    <span class="keyword">if</span>(eated)               <span class="comment">//如果吃到了食物</span></span><br><span class="line">    &#123;</span><br><span class="line">        sLength++;</span><br><span class="line">        eated=<span class="literal">false</span>;        <span class="comment">//设置为false，不然无限变长</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=sLength<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)  <span class="comment">//从尾巴开始，每一个点的位置等于它前面一个点的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        s[i][<span class="number">0</span>]=s[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        s[i][<span class="number">1</span>]=s[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(direction)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> UP:</span><br><span class="line">        s[<span class="number">0</span>][<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DOWN:</span><br><span class="line">        s[<span class="number">0</span>][<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LEFT:</span><br><span class="line">        s[<span class="number">0</span>][<span class="number">1</span>]--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RIGHT:</span><br><span class="line">        s[<span class="number">0</span>][<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drawSnake</span><span class="params">()</span>                <span class="comment">//画蛇</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gotoxy(s[i][<span class="number">0</span>],s[i][<span class="number">1</span>]);        <span class="comment">//移动关标到蛇的坐标</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;@&quot;</span>);                    <span class="comment">//在这个位置画蛇</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(kbhit()!=<span class="number">0</span>)          <span class="comment">//如果有键盘输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> in;</span><br><span class="line">        <span class="keyword">while</span>(!kbhit()==<span class="number">0</span>)  <span class="comment">//如果玩家输入了多个按键，以最后一个按键为准</span></span><br><span class="line">            in=getch();</span><br><span class="line">        <span class="keyword">switch</span>(in)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(direction!=DOWN)         <span class="comment">//不能缩头吧。。。。</span></span><br><span class="line">                direction=UP;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(direction!=UP)</span><br><span class="line">                direction=DOWN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(direction!=RIGHT)</span><br><span class="line">                direction=LEFT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(direction!=LEFT)</span><br><span class="line">                direction=RIGHT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            gotoxy(H,<span class="number">0</span>);        <span class="comment">//将光标移动到下面</span></span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            gotoxy(H,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);  <span class="comment">//消去下面的按任意键继续</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">gameOver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> isGameOver=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sX=s[<span class="number">0</span>][<span class="number">0</span>],sY=s[<span class="number">0</span>][<span class="number">1</span>];      <span class="comment">//蛇头的x坐标和y坐标</span></span><br><span class="line">    <span class="keyword">if</span>(sX==<span class="number">0</span>||sX==H<span class="number">-1</span>||sY==<span class="number">0</span>||sY==W<span class="number">-1</span>)</span><br><span class="line">        isGameOver=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;sLength; i++)    <span class="comment">//判断有没有吃到自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i][<span class="number">0</span>]==sX&amp;&amp;s[i][<span class="number">1</span>]==sY)</span><br><span class="line">            isGameOver=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isGameOver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printScore</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    gotoxy(<span class="number">0</span>,W+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  贪吃蛇小游戏&quot;</span>);</span><br><span class="line">    gotoxy(<span class="number">1</span>,W+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  TeX白兔 制作&quot;</span>);</span><br><span class="line">    gotoxy(<span class="number">4</span>,W+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  得分:%d&quot;</span>,score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init();                     <span class="comment">//程序开始时的初始化操作</span></span><br><span class="line">    drawMap();                  <span class="comment">//画地图</span></span><br><span class="line">    food();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        drawSnake();                <span class="comment">//画蛇</span></span><br><span class="line">        printScore();</span><br><span class="line">        Sleep(WAIT_TIME);           <span class="comment">//等待一段时间</span></span><br><span class="line">        key();</span><br><span class="line">        move();                     <span class="comment">//移动蛇（主要是修改蛇身数组的数据）</span></span><br><span class="line">        <span class="keyword">if</span>(gameOver())</span><br><span class="line">        &#123;</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);          <span class="comment">//清除屏幕内容</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Game Over\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[s[<span class="number">0</span>][<span class="number">0</span>]][s[<span class="number">0</span>][<span class="number">1</span>]]==<span class="number">-1</span>) <span class="comment">//如果蛇头碰到食物，就重新投放食物，并且把食物点重置为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            eated=<span class="literal">true</span>;             <span class="comment">//标记已经吃到食物</span></span><br><span class="line">            score+=<span class="number">10</span>;</span><br><span class="line">            food();</span><br><span class="line">            a[s[<span class="number">0</span>][<span class="number">0</span>]][s[<span class="number">0</span>][<span class="number">1</span>]]=<span class="number">0</span>;  <span class="comment">//去掉食物</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221203-《登泰山记》"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/03/20221203-%E3%80%8A%E7%99%BB%E6%B3%B0%E5%B1%B1%E8%AE%B0%E3%80%8B/"
    >20221203-《登泰山记》</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/03/20221203-%E3%80%8A%E7%99%BB%E6%B3%B0%E5%B1%B1%E8%AE%B0%E3%80%8B/" class="article-date">
  <time datetime="2022-12-03T12:09:59.000Z" itemprop="datePublished">2022-12-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>《登泰山记》</p>
<p>姚鼐 〔清代〕</p>
<p>泰山之阳，汶水西流；其阴，济水东流。阳谷皆入汶，阴谷皆入济。当其南北分者，古长城也。最高日观峰，在长城南十五里。</p>
<p>余以乾隆三十九年十二月，自京师乘风雪，历齐河、长清，穿泰山西北谷，越长城之限，至于泰安。是月丁未，与知府朱孝纯子颍由南麓登。四十五里，道皆砌石为磴，其级七千有余。泰山正南面有三谷。中谷绕泰安城下，郦道元所谓环水也。余始循以入，道少半，越中岭，复循西谷，遂至其巅。古时登山，循东谷入，道有天门。东谷者，古谓之天门溪水，余所不至也。今所经中岭及山巅，崖限当道者，世皆谓之天门云。道中迷雾冰滑，磴几不可登。及既上，苍山负雪，明烛天南。望晚日照城郭，汶水、徂徕如画，而半山居雾若带然。</p>
<p>戊申晦，五鼓，与子颍坐日观亭，待日出。大风扬积雪击面。亭东自足下皆云漫。稍见云中白若樗蒱数十立者，山也。极天云一线异色，须臾成五采。日上，正赤如丹，下有红光动摇承之。或曰，此东海也。回视日观以西峰，或得日或否，绛皓驳色，而皆若偻。</p>
<p>亭西有岱祠，又有碧霞元君祠。皇帝行宫在碧霞元君祠东。是日观道中石刻，自唐显庆以来；其远古刻尽漫失。僻不当道者，皆不及往。</p>
<p>山多石，少土。石苍黑色，多平方，少圜。少杂树，多松，生石罅，皆平顶。冰雪，无瀑水，无鸟兽音迹。至日观数里内无树，而雪与人膝齐。</p>
<p>桐城姚鼐记。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> TeX_baitu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="TeX_baitu blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>