<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> TeX_baitu blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      


<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-20220801-UX交互设计网址"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/01/20220801-UX%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E7%BD%91%E5%9D%80/"
    >20220801-UX交互设计网址</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/01/20220801-UX%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E7%BD%91%E5%9D%80/" class="article-date">
  <time datetime="2022-08-01T00:44:40.000Z" itemprop="datePublished">2022-08-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>故事板：<a target="_blank" rel="noopener" href="https://www.storyboardthat.com/">https://www.storyboardthat.com/</a><br>图表：<a target="_blank" rel="noopener" href="https://live.amcharts.com/">https://live.amcharts.com/</a><br><a target="_blank" rel="noopener" href="https://www.pixton.com/">https://www.pixton.com/</a><br>云图制作：<br><a target="_blank" rel="noopener" href="http://www.picdata.cn/indexb.php">http://www.picdata.cn/indexb.php</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220801-epub电子书制作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/01/20220801-epub%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%B6%E4%BD%9C/"
    >20220801-epub电子书制作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/01/20220801-epub%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%B6%E4%BD%9C/" class="article-date">
  <time datetime="2022-08-01T00:31:38.000Z" itemprop="datePublished">2022-08-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>软件 zigil</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220731-用DISM命令备份与还原windows系统"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/31/20220731-%E7%94%A8DISM%E5%91%BD%E4%BB%A4%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9Fwindows%E7%B3%BB%E7%BB%9F/"
    >20220731-用DISM命令备份与还原windows系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/31/20220731-%E7%94%A8DISM%E5%91%BD%E4%BB%A4%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9Fwindows%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2022-07-31T09:25:34.000Z" itemprop="datePublished">2022-07-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>用浅显易懂的语言全面详细的解说用DISM命令进行系统备份与还原</p>
<p>用 DISM 命令进行系统备份与还原需要在 Windows 8 以上的第二系统（系统引导不能在需要备份的系统分区中）、Windows To Go、Windows PE 或 Windows RE 下才能进行，并以管理员身份运行命令提示符。</p>
<p>注意：</p>
<p>有的 PE 精简过分可能不能运行 DISM 命令。由于 DISM 命令不能进行系统热备份，所以在第二系统中进行备份时，如果当前系统的启动引导文件在需要进行备份的分区中，DISM 会显示“另一个程序正在使用此文件，进程无法访问。”</p>
<p>另外，如果用 Windows 8 Ent 中自带功能制作的 Windows To Go，是不能对本地磁盘进行操作的，只能用其他方法制作的 Windows To Go 来进行操作。</p>
<p>如果在 Windows 7 系统（包括 PE）中使用 DISM 命令可以把 Windows 8 系统 C:\Windows\System32 中的 Dism 文件夹与 Dism.exe 复制到 Windows 7 系统（包括 PE）的 C:\Windows\System32 下就可以使用 DISM 所有命令了。</p>
<p>一、初始备份（例如：把 C 分区的系统备份到 D 分区的 Win8BF 文件夹中，备份文件名为 Win8Pro.wim）：</p>
<p>Dism &#x2F;Capture-Image &#x2F;ImageFile:D:\Win8BF\Win8Pro.wim &#x2F;CaptureDir:C:\ &#x2F;Name:Win8Pro-1 &#x2F;Description:0000-00-00</p>
<p>命令解释：</p>
<p>&#x2F;Capture-Image - 指定捕获映像。</p>
<p>&#x2F;ImageFile: - 指定映像文件路径。                </p>
<p>&#x2F;CaptureDir: - 指定捕获目录。</p>
<p>&#x2F;Name: - 指定名称。此项不能省略。</p>
<p>&#x2F;Description: - 指定描述。描述是为了说明这次备份的具体情况，我们这里用了时间。此项可省略。</p>
<p>注意：如果是在 Win8 系统中进行操作，备份时注意暂时关闭 Windows Defender，它要对整个备份文件进行扫描，其中 MsMpEng.exe 对 CPU 的占用有时高达 90% 以上，严重拖慢备份速度，有时甚至使备份时间延长十倍以上。</p>
<p>二、增量备份（例如：把 C 分区的系统增量备份到 D:\Win8BF\Win8Pro.wim 中）：</p>
<p>Dism &#x2F;Append-Image &#x2F;ImageFile:D:\Win8BF\Win8Pro.wim &#x2F;CaptureDir:C:\ &#x2F;Name:Win8Pro-2 &#x2F;Description:0000-00-00</p>
<p>命令解释：</p>
<p>&#x2F;Append-Image - 指定追加映像。</p>
<p>Dism 允许各卷映像之间同名，但为了以后应用方便，各卷映像之间的名称最好不同。Dism 可以指定卷映像索引号或名称来对卷映像进行操作。索引号可能因删除某卷映像而发生改变，但名称是不会变的，如果各卷映像之间同名，用指定名称来对卷映像进行操作时就会出现问题。</p>
<p>重要事项：</p>
<p>确保有足够的磁盘空间可用于运行 &#x2F;Append-Image 选项。如果在附加映像期间磁盘空间不足，则可能会损坏 .wim 文件。</p>
<p>三、系统还原（例如：把 D:\Win8BF\Win8Pro.wim 中第二次备份还原到 C 分区）：</p>
<p>Dism &#x2F;Apply-Image &#x2F;ImageFile:D:\Win8BF\Win8Pro.wim &#x2F;Index:2 &#x2F;ApplyDir:C:\</p>
<p>命令解释：</p>
<p>&#x2F;Apply-Image - 指定应用映像。</p>
<p>&#x2F;ApplyDir: - 指定应用目录。</p>
<p>&#x2F;Index: - 指定索引。此项不能省略。</p>
<p>因 Dism 安装 WIM 映像不会像 Ghost 那样格式化磁盘，所以如果需要可以自己格式化系统盘。   </p>
<p>修改映像路径与应用目录可把任意一个系统备份的卷映像还原到任意一个分区。修改卷映像索引号或卷映像名称可以还原备份映像中的任意一个备份。</p>
<p>也可以用此命令把 Windows 系统（WIM 映像）快速安装到任何分区。例如在 PE 中把 Win8Pro 安装到 C 分区（设 Win8ISO 用虚拟光驱加载的盘符为 E）：</p>
<p>Dism &#x2F;Apply-Image &#x2F;ImageFile:E:\sources\install.wim &#x2F;Index:1 &#x2F;ApplyDir:C:\</p>
<p>由于 Windows 系统原始 WIM 映像中没有启动引导文件，需要添加启动引导：</p>
<p>bcdboot C:\windows &#x2F;s C: &#x2F;l zh-cn</p>
<p>如果是把 Windows 8 安装到 USB 设备中作 Windows To Go，也应添加启动引导：</p>
<p>bcdboot X:\windows &#x2F;s X: &#x2F;l zh-cn &#x2F;f ALL （X为 USB 设备的盘符）。</p>
<p>添加 Net 3.5（包括 2.0 和 3.0）：</p>
<p>Dism &#x2F;Image:C:\ &#x2F;enable-feature &#x2F;featurename:NetFX3 &#x2F;Source:E:\sources\sxs</p>
<p>四、获取WIM文件映像信息（例如：查看 D:\Win8BF\Win8Pro.wim 映像信息）：</p>
<p>Dism &#x2F;Get-WimInfo &#x2F;Wimfile:D:\Win8BF\Win8Pro.wim</p>
<p>命令解释：</p>
<p>&#x2F;Get-WimInfo - 显示有关 WIM 文件中的映像的信息。</p>
<p>&#x2F;Wimfile: - 指定 WIM 文件路径。<br>可以在后面添加索引号或名称来查看某次备份的详细信息。还可以在后面添加 &gt;d:\list.txt 把信息导出为记事本，方便查看。如：</p>
<p>Dism &#x2F;Get-WimInfo &#x2F;Wimfile:D:\Win8BF\Win8Pro.wim &#x2F;Index:1&gt; d:\list.txt</p>
<p>或：Dism &#x2F;Get-WimInfo &#x2F;Wimfile:D:\Win8BF\Win8Pro.wim &#x2F;Name:Win8Pro-1&gt; d:\list.txt</p>
<p>在一个映像中如果有两个卷映像同名，就不能用指定名称来查看这两个卷映像的详细信息。</p>
<p>五、从具有多个卷映像的WIM 文件中删除指定的卷映像（例如：删除 D:\Win8BF\Win8.wim 中的第二次备份）：<br>Dism &#x2F;Delete-Image &#x2F;ImageFile:D:\Win8BF\Win8Pro.wim &#x2F;Index:2</p>
<p>命令解释：</p>
<p>&#x2F;Delete-Image - 指定删除映像。</p>
<p>此命令仅删除卷映像名称与描述，而不会删除卷映像数据。可用于防止误应用该卷映像。</p>
<p>六、从具有多个卷映像的WIM 文件中提取单独的卷映像：</p>
<p>增量备份多了，WIM 文件也变得大起来了，删除指定的卷映像仅删除了名称与描述，而不会删除卷映像数据，所以不会减小 WIM 文件的体积。这就要用 &#x2F;Export-Image 命令从具有多个卷映像的 WIM 文件中提取需要保留的单独卷映像，以减小 WIM 文件的体积。（例如：从 D:\Win8BF\Win8Pro.wim 中提取第二次备份到 D:\Win8BF\ 中，保存为 Win8Pro-2.wim）：</p>
<p>Dism &#x2F;Export-Image &#x2F;SourceImageFile:D:\Win8BF\Win8Pro.wim &#x2F;SourceIndex:2 &#x2F;DestinationImageFile:D:\Win8BF\Win8Pro-2.wim   </p>
<p>命令解释：</p>
<p>&#x2F;Export-Image - 指定导出映像。</p>
<p>&#x2F;SourceImageFile: - 指定映像文件来源路径。</p>
<p>&#x2F;SourceIndex: - 指定来源索引。</p>
<p>&#x2F;DestinationImageFile: - 指定目标映像文件路径。</p>
<p>如果 Win8Pro.wim 中有五个备份，我们只想保留其中第二与第五个备份，同样可以用 &#x2F;Export-Image 命令把其中 Index:2 与 Index:5 提取出来，保存为 Win8.wim。命令如下：</p>
<p>Dism &#x2F;Export-Image &#x2F;SourceImageFile:D:\Win8BF\Win8Pro.wim &#x2F;SourceIndex:2 &#x2F;DestinationImageFile:D:\Win8BF\Win8.wim<br>Dism &#x2F;Export-Image &#x2F;SourceImageFile:D:\Win8BF\Win8Pro.wim &#x2F;SourceIndex:5 &#x2F;DestinationImageFile:D:\Win8BF\Win8.wim   </p>
<p>Win8.wim 中就包涵有两个卷映像，卷映像的索引号会发生改变，但名称不会变。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>附录1：一些可用选项</p>
<p>&#x2F;Verify - 指定校验。用于检查错误和文件重复。</p>
<p>&#x2F;CheckIntegrity - 用于在捕捉、卸载、导出和提交操作中使用 .wim 文件时检测和跟踪 .wim 文件的损坏情况。</p>
<p>用于在 DISM 检测到 .wim 文件在应用和装载操作中发生损坏时停止操作。</p>
<p>&#x2F;ScratchDir: - 指定暂存目录的路径。此目录必须存在。该目录必须位于本地。</p>
<p>&#x2F;Compress: - 用于指定对初始捕捉操作使用的压缩类型。</p>
<p>maximum 选项能提供最佳压缩效果，但是捕捉映像所用的时间较长。</p>
<p>fast 选项能提供更快速的映像压缩，但生成的文件比使用 maximum 选项压缩的文件大。这也是在未指定参数时所用的默认压缩类型。</p>
<p>none 选项不会压缩捕捉的映像。</p>
<p>recovery 选项导出一键重置映像。生成的文件显著缩小，这又大大减少了在恢复驱动器上保存一键重置映像所需的磁盘空间量。必须使用 .esd 扩展名指定目标文件。</p>
<p>&#x2F;ConfigFile: - 指定映像捕捉和压缩命令排除列表配置文件的位置。</p>
<p>默认的排除列表——默认情况下，DISM.exe 工具将排除以下文件：   </p>
<p>[ExclusionList]<br>$ntfs.log<br>\hiberfil.sys<br>\pagefile.sys<br>\swapfile.sys<br>“\System Volume Information”<br>\RECYCLER<br>\Windows\CSC</p>
<p>[CompressionExclusionList]<br>*.mp3<br>*.zip<br>*.cab<br>\WINDOWS\inf*.pnf<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>附录2： &#x2F;ScratchDir 命令具体使用方法</p>
<p>创建或处理 Windows 映像时，你应使用带有 DISM 的 &#x2F;ScratchDir 选项，在不同的驱动器上创建临时目录。临时目录适用于许多 DISM 操作，包括捕获映像、安装语言包、更新或在 Windows 映像中安装或删除 Windows 功能。先将一些文件扩展到此临时目录，然后再将它们应用于 Windows 映像。</p>
<p>&#x2F;ScratchDir: - 指定暂存目录的路径。</p>
<p>指定用来解压缩服务文件的临时目录。此目录必须存在。</p>
<p>指定在服务期间提取临时使用的文件时要使用的临时目录。该目录必须位于本地。<br>安装完成后，不再需要此目录的内容，可以将其删除。</p>
<p>如果你不使用 &#x2F;ScratchDir 选项设置临时目录路径， Windows PE 将默认创建 32-MB 临时目录。</p>
<p>如果未指定临时目录，将使用 \Windows%Temp% 目录，以及每次运行 DISM 时随机生成的十六进制值的子目录名称。每次操作后，都会删除暂存目录中的项。</p>
<p>作为最佳做法，你应使用 &#x2F;ScratchDir 选项，转而在其他有足够空间支持任何映像管理和你所执行的服务操作的分区上指定目录。</p>
<p>运行 DISM 命令临时目录空间不足的问题多出现在 PE 操作的情况下，下面是备份及还原命令中 &#x2F;ScratchDir 具体使用的完整命令。</p>
<p>以初始备份为例（例如：把 C 分区的系统备份到 D 分区的 Win8BF 文件夹中，备份文件名为 Win8Pro.wim，指定临时目录为 D:\Temp）：</p>
<p>Dism &#x2F;Capture-Image &#x2F;ImageFile:D:\Win8BF\Win8Pro.wim &#x2F;ScratchDir:D:\Temp &#x2F;CaptureDir:C:\ &#x2F;Name:Win8Pro-1 &#x2F;Description:0000-00-00</p>
<p>注意：必须先在 D 盘建立一个 Temp 文件夹,D 盘必须有充足的可用空间。</p>
<p>以还原为例（例如：把 D:\Win8BF\Win8Pro.wim 中第二次备份还原到 C 分区，指定临时目录为 D:\Temp）：</p>
<p>Dism &#x2F;Apply-Image &#x2F;ImageFile:D:\Win8BF\Win8Pro.wim &#x2F;Index:2 &#x2F;ScratchDir:D:\Temp &#x2F;ApplyDir:C:\</p>
<p>wbadmin<br>项目<br>2022&#x2F;04&#x2F;02<br>7 个参与者</p>
<p>使你能够从命令提示符备份和还原操作系统、卷、文件、文件夹和应用程序。</p>
<p>若要使用此命令配置定期计划的备份，您必须是 Administrators 组的成员。 若要使用此命令执行所有其他任务，您必须是 Backup Operators 组或 Administrators 组的成员，或者您必须被委派了适当的权限。</p>
<p>必须从提升的命令提示符运行 wbadmin ，方法是右键单击 “ 命令提示符”，然后选择 “以 管理员身份运行”。</p>
<p>参数<br>参数  说明<br>wbadmin delete catalog  删除本地计算机上的备份目录。 仅当此计算机上的备份目录已损坏，并且你没有将备份存储在可用于还原目录的其他位置时，才使用此命令。<br>wbadmin delete systemstatebackup  删除一个或多个系统状态备份。<br>wbadmin disable backup  禁用日常备份。<br>wbadmin enable backup 配置并启用定期计划的备份。<br>wbadmin get disks 列出当前处于联机状态的磁盘。<br>wbadmin get items 列出备份中包含的项。<br>wbadmin get status  显示当前正在运行的备份或恢复操作的状态。<br>wbadmin get versions  列出从本地计算机恢复的备份的详细信息，或者，如果指定了其他位置，则从另一台计算机。<br>wbadmin restore catalog 在本地计算机上的备份目录已损坏的情况下，从指定的存储位置恢复备份目录。<br>wbadmin start backup  运行一次性备份。 如果与不带参数一起使用，则将使用每日备份计划的设置。<br>wbadmin start recovery  运行指定的卷、应用程序、文件或文件夹的恢复。<br>wbadmin start sysrecovery 运行完整系统的恢复 (至少包含操作系统状态) 的所有卷。 仅当使用 Windows 恢复环境时，此命令才可用。<br>wbadmin start systemstatebackup 运行系统状态备份。<br>wbadmin start systemstaterecovery 运行系统状态恢复。<br>wbadmin stop job  停止当前正在运行的备份或恢复操作。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220726-恋爱时的聊天话题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/26/20220726-%E6%81%8B%E7%88%B1%E6%97%B6%E7%9A%84%E8%81%8A%E5%A4%A9%E8%AF%9D%E9%A2%98/"
    >20220726-恋爱时的聊天话题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/26/20220726-%E6%81%8B%E7%88%B1%E6%97%B6%E7%9A%84%E8%81%8A%E5%A4%A9%E8%AF%9D%E9%A2%98/" class="article-date">
  <time datetime="2022-07-25T23:26:44.000Z" itemprop="datePublished">2022-07-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>聊对近期某个电影的看法<br>聊新开的某家餐厅<br>聊有喜欢喝的饮料<br>聊一点点的奶茶<br>聊对人生的看法<br>聊有没有近期的规划<br>聊想实现的心愿<br>聊最想得到的东西<br>聊小时候的故事<br>聊同桌的她<br>聊那个讨厌的班主任<br>聊那个难忘的考试<br>聊家庭的构成<br>聊父母的和睦<br>聊父母的爱好<br>聊可爱的弟弟<br>聊那些柜子里不穿的衣服<br>聊多久打扫的房间<br>聊地板的颜色<br>聊洗衣服的分类<br>聊今天发生的趣事<br>聊那个给你买棒冰的闺蜜<br>聊最好的朋友<br>聊送出祝福的初恋<br>聊没看出来的化妆<br>聊夏天出来防晒的霜<br>聊带出来的帽子<br>聊装饰的项链<br>聊初次见面时的尴尬<br>聊没有表现好的那个谈话<br>聊没来得及说的漂亮的鞋子<br>聊这个包与你衣服很配<br>聊习惯的猫猫狗狗<br>聊种死的那盆肉肉<br>聊习惯的花<br>聊习惯的香味<br>聊大学怎么过来的<br>聊难忘的实习<br>聊实习的那个师父<br>聊一起实习的那些人<br>聊眼镜的度数<br>聊眼镜的起源<br>聊隐形眼镜<br>聊你们工资<br>聊你们的福利<br>聊公司组织出去旅游<br>聊有意义的福利发放经历<br>聊看的书<br>聊看的电视剧<br>聊当前的比赛<br>聊此刻的电影频道<br>聊最喜欢的节目</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220723-ADB命令大全"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/23/20220723-ADB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"
    >20220723-ADB命令大全</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/23/20220723-ADB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" class="article-date">
  <time datetime="2022-07-23T11:43:43.000Z" itemprop="datePublished">2022-07-23</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ol>
<li>常用命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">adb devices #查看连接设备</span><br><span class="line"></span><br><span class="line">adb -s cf27456f shell # 指定连接设备使用命令</span><br><span class="line"></span><br><span class="line">adb install test.apk # 安装应用</span><br><span class="line"></span><br><span class="line">adb install -r demo.apk #安装apk 到sd 卡：</span><br><span class="line"></span><br><span class="line">adb uninstall cn.com.test.mobile #卸载应用，需要指定包</span><br><span class="line"></span><br><span class="line">adb uninstall -k cn.com.test.mobile #卸载app 但保留数据和缓存文件</span><br><span class="line"></span><br><span class="line">adb shell pm list packages #列出手机装的所有app 的包名</span><br><span class="line"></span><br><span class="line">adb shell pm list packages -3 #列出除了系统应用的第三方应用包名</span><br><span class="line"></span><br><span class="line">adb shell pm clear cn.com.test.mobile #清除应用数据与缓存</span><br><span class="line"></span><br><span class="line">adb shell am start -ncn.com.test.mobile/.ui.SplashActivity #启动应用</span><br><span class="line"></span><br><span class="line">adb shell dumpsys package #包信息Package Information</span><br><span class="line"></span><br><span class="line">adb shell dumpsys meminfo #内存使用情况Memory Usage</span><br><span class="line"></span><br><span class="line">adb shell am force-stop cn.com.test.mobile #强制停止应用</span><br><span class="line"></span><br><span class="line">adb logcat #查看日志</span><br><span class="line"></span><br><span class="line">adb logcat -c #清除log 缓存</span><br><span class="line"></span><br><span class="line">adb reboot #重启</span><br><span class="line"></span><br><span class="line">adb get-serialno #获取序列号</span><br><span class="line"></span><br><span class="line">adb shell getprop ro.build.version.release #查看Android 系统版本</span><br><span class="line"></span><br><span class="line">adb shell top -s 10 #查看占用内存前10 的app</span><br><span class="line"></span><br><span class="line">adb push &lt;local&gt; &lt;remote&gt; #从本地复制文件到设备</span><br><span class="line"></span><br><span class="line">adb pull &lt;remote&gt; &lt;local&gt; #从设备复制文件到本地</span><br><span class="line"></span><br><span class="line">adb bugreport #查看bug 报告</span><br><span class="line"></span><br><span class="line">adb help #查看ADB 帮助</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>2.1 连接设备</p>
<p>adb [-d|-e|-s <serialNumber>] <command></p>
<p>连接指定设备</p>
<p>参数：</p>
<p>-d 指定当前唯一通过usc 连接的android 设备为命令目标</p>
<p>-e 指定当前唯一运行的模拟器为命令目标</p>
<p>-s 指定相应serialNumber 号的设备 模拟器为命令目标</p>
<p>command 为所需对设备执行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">cf263b7f device</span><br><span class="line">emulator-5554 offline</span><br><span class="line">192.168.1.6:5555 device</span><br><span class="line">$adb -s cf263b7f #连接cf264b8f 设备</span><br></pre></td></tr></table></figure>

<p>adb devices 查看已连接的设备信息，上面已经连接3台设备</p>
<p>2.2 查看信息</p>
<p>查看版本设备</p>
<p>adb version 版本信息</p>
<p>注意：offline 表示设备未连接成功或无响应，device 设备已连接</p>
<p>adb shell getprop ro.product.model 查看设备型号</p>
<p>adb get-serialno 获取设备序列号</p>
<p>adb bugreport 查看bug 报告</p>
<p>adb logcat 查看日志</p>
<p>adb shell wm size 查看屏幕分辨率</p>
<p>adb shell wm density 查看屏幕密度</p>
<p>查看应用信息</p>
<p>adb shell pm list packages 列出手机装的所有app 的包名</p>
<p>adb shell pm list packages -s 列出系统应用的所有包名</p>
<p>adb shell pm list packages -3 列出除了系统应用的第三方应用包名</p>
<p>adb shell pm list packages | find “test” win 列出手机装带有的test的包</p>
<p>adb shell pm list packages | grep ‘test’ linux 列出手机装带有的test的包</p>
<p>adb shell cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;wlan0&#x2F;address 获取MAC 地址, 根据系统版本参数可能不同</p>
<p>adb shell getprop ro.build.version.release 查看Android 系统版本</p>
<p>adb shell dumpsys activity services [<packagename>] 查看正在运行的Services</p>
<p><packagename> 参数不是必须的，指定<packagename> 表示查看与某个包名相关的Services，不指定表示查看所有Services。</p>
<p><packagename> 不一定要给出完整的包名，比如运行adb shell dumpsys activity services org.zhihu，那么包名org.zhihu.demo1、org.zhihu.demo2 和org.zhihu 等相关的Services 都会列出来。</p>
<p>app 安装和卸载</p>
<p>adb install <apkfile> 参数apkfile 为.apk 文件名称</p>
<p>adb install -r test.apk 保留数据和缓存文件，重新安装apk</p>
<p>adb install -s test.apk 安装apk 到sd 卡</p>
<p>app 卸载</p>
<p>db uninstall <package> 参数package 为软件包名称</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$adb uninstall cn.com.test.mobile</span><br><span class="line"> </span><br><span class="line">#  卸载app 但保留数据和缓存文件</span><br><span class="line">$adb uninstall -k ccn.com.test.mobile </span><br></pre></td></tr></table></figure>

<p>2.4 启动停止服务</p>
<p>adb start-server</p>
<p>启动adb 服务，基本不会用到，因为只要设备连接正确，会自动启动adb server</p>
<p>adb kill-server</p>
<p>停止adb server</p>
<p>adb -P <port> start-server</p>
<p>指定adb server 的网络端口port （默认为5037）启动服务</p>
<p>与应用交互</p>
<p>adb  shell pm clear <packagename></p>
<p>清除应用数据与缓存</p>
<p>示例：</p>
<p>$adb shell pm clear cn.com.test.mobile<br>adb shell am force-stop <packagename></p>
<p>强制停止应用</p>
<p>示例：强制停止微信</p>
<p>$adb shell am force-stop com.tencent.mm<br>adb shell am <command></p>
<p>command 命令详解</p>
<p>command 用途<br>start [options] <INTENT> 启动 <INTENT> 指定的 Activity<br>startservice [options] <INTENT> 启动 <INTENT> 指定的 Service<br>broadcast [options] <INTENT> 发送 <INTENT> 指定的广播<br>force-stop <packagename> 停止 <packagename> 相关的进程<br><INTENT> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应,用于决定 intent 对象的选项如下：</p>
<p>-a <ACTION> 指定 action，如android.intent.action.VIEW<br>-c <CATEGORY> 指定 category，如android.intent.category.APP_CONTACTS<br>-n <COMPONENT> 指定完整 component 名，用于明确指定启动哪个 Activity，如<br>com.example.app&#x2F;.ExampleActivity</p>
<p>启动activity</p>
<p>adb shell am start [options] <INTENT></p>
<p>示例：</p>
<p> #指定完整 component 名，用于明确指定启动哪个Activity<br>$adb shell am start -n <COMPONENT><br>如： #表示调起微信主界面<br>$adb shell am start -n com.tencent.mm&#x2F;.ui.LauncherUI<br>2.5.2 启动 Service</p>
<p>adb shell am startservice [options] <INTENT></p>
<p>示例： 表示调起微信的某 Service。</p>
<p>$adb shell am startservice -n com.tencent.mm&#x2F;.plugin.accountsync.model.AccountAuthenticatorService<br>2.5.3 发送广播</p>
<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>adb shell am broadcast [options] <INTENT></p>
<p>示例：</p>
<p>#向所有组件广播 BOOT_COMPLETED (开机广播)<br>$adb shell am broadcast -a android.intent.action.BOOT_COMPLETED<br>#如：只向 org.mazhuang.boottimemeasure&#x2F;.BootCompletedReceiver 广播 BOOT_COMPLETED：<br>$adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure&#x2F;.BootCompletedReceiver<br>系统预定义的广播：</p>
<p>强制停止应用</p>
<p>adb shell am force-stop <packagename></p>
<p>示例：</p>
<h1 id="查询出包名"><a href="#查询出包名" class="headerlink" title="查询出包名"></a>查询出包名</h1><p>$adb shell pm list packages<br>…..</p>
<h1 id="强制停止微信"><a href="#强制停止微信" class="headerlink" title="强制停止微信"></a>强制停止微信</h1><p>$adb shell am force-stop com.tencent.mm</p>
<p>文件管理</p>
<p>2.6.1 复制设备里的文件到电脑</p>
<p>adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</p>
<p>示例：</p>
<p>$adb pull &#x2F;sdcard&#x2F;abc.mp4  ~&#x2F;tmp&#x2F;<br>小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp &#x2F;path&#x2F;on&#x2F;device &#x2F;sdcard&#x2F;filename 将文件复制到 sdcard，然后 adb pull &#x2F;sdcard&#x2F;filename &#x2F;path&#x2F;on&#x2F;pc。<br>2.6.2 复制电脑里的文件到设备</p>
<p>adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</p>
<p>示例：</p>
<p>$adb push  e:&#x2F;ss.au3  &#x2F;data&#x2F;local&#x2F;tmp&#x2F;<br>小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push &#x2F;path&#x2F;on&#x2F;pc &#x2F;sdcard&#x2F;filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp &#x2F;sdcard&#x2F;filename &#x2F;path&#x2F;on&#x2F;device<br>2.7 使用ADB命令模拟按键&#x2F;输入<br>adb shell input keyevent <keycode></p>
<p>keycode位操作参数，不同的 keycode 能实现不同的功能</p>
<p>完整的功能见：<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/view/KeyEvent.html">https://developer.android.com/reference/android/view/KeyEvent.html</a></p>
<p>keycode 能实现不同的功能，对应的编码如下：</p>
<p>$adb shell input keyevent 26  #电源键<br>$adb shell input keyevent 82  #菜单键<br>$adb shell input keyevent 3  #HOME 键<br>$adb shell input keyevent 4 #返回键<br>$adb shell input keyevent 24 #增加音量<br>$adb shell input keyevent 25 #降低音量<br>$adb shell input keyevent 164 #静音<br>$adb shell input keyevent 85  #播放&#x2F;暂停<br>$adb shell input keyevent 86 #停止播放<br>$adb shell input keyevent 87 #播放下一首<br>$adb shell input keyevent 88 #播放上一首<br>$adb shell input keyevent 126 #恢复播放<br>$adb shell input keyevent 127 #暂停播放<br>$adb shell input keyevent 224 #点亮屏幕<br>$adb shell input keyevent 223 #熄灭屏幕<br>$adb shell input swipe 300 1000 300 500  #滑动解锁，向上滑动手势解锁<br>#参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标<br>$adb shell input text hello #焦点处于某文本框时输入文本</p>
<p>2.8 查看日志</p>
<p>2.8.1 Android 日志<br>[adb] logcat [<option>] … [<filter-spec>] …</p>
<p>按级别过滤日志</p>
<p>按某级别过滤日志则会将该级别及以上的日志输出，Android 日志的优先级如下：</p>
<p>V —— Verbose（最低，输出得最多）<br>D —— Debug<br>I —— Info<br>W —— Warning<br>E —— Error<br>F —— Fatal<br>S —— Silent（最高，啥也不输出）<br>示例：输出W之上的日志，W,E,F,S</p>
<p>$adb logcat *:W<br>按 tag 和级别过滤日志</p>
<p><filter-spec> 可以由多个 <tag>[:priority] 组成</p>
<p>示例：输出 tag ActivityManager 的 I 以上级别日志，输出tag MyApp的D 以上级别日志，及其它 tag 的 S 级别日志（即屏蔽其它 tag 日志）。</p>
<p>$adb logcat ActivityManager:I MyApp:D *:S<br>日志格式</p>
<p>adb logcat -v <format></p>
<p>指定日志输出格式</p>
<p>示例：</p>
<p>$adb logcat -v <format>  指定日志输出格式<br>$adb logcat -v brief   #默认格式,<priority>&#x2F;<tag>(<pid>): <message><br>$adb logcat -v process #<priority>(<pid>) <message><br>$adb logcat -v tag  #<priority>&#x2F;<tag>: <message><br>$adb logcat -v raw  #<message><br>$adb logcat -v time  #<datetime> <priority>&#x2F;<tag>(<pid>): <message><br>$adb logcat -v threadtime #<datetime> <pid> <tid> <priority> <tag>: <message><br>$adb logcat -v long  #[ <datetime> <pid>:<tid> <priority>&#x2F;<tag>:] <message><br>$adb logcat -v long ActivityManager:I *:S  #指定格式可与上面的过滤同时使用<br>清空日志</p>
<p>$adb logcat -c<br>2.8.2 内核日志</p>
<p>$adb shell dmesg<br>查看内核日志</p>
<p>2.9 查看设备信息<br>2.9.1 型号<br>$adb shell getprop ro.product.model<br>2.9.2 电池状况<br>$adb shell dumpsys battery<br>2.9.3 屏幕分辨率<br>$adb shell wm size<br>2.9.4 屏幕密度<br>$adb shell wm density<br>2.9.5 显示屏参数<br>$adb shell dumpsys window displays<br>2.9.6 android_id<br>$adb shell settings get secure android_id<br>2.9.7 IMEI<br>$adb shell dumpsys iphonesubinfo<br>#而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：<br>adb shell<br>su<br>$service call iphonesubinfo 1<br>2.9.8 Android 系统版本<br>$adb shell getprop ro.build.version.release<br>2.9.9 IP 地址<br>$adb shell ifconfig | find “Mask”<br>$adb shell ifconfig wlan0 #设备连着 WiFi，可以使用如下命令来查看局域网 IP<br>$adb shell netcfg # 上面两个无结果可以用这个，查看网络连接状态<br>2.9.10 Mac 地址<br>$adb shell cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;wlan0&#x2F;address # 设备不同可能地址不同<br>2.9.11 CPU 信息<br>$adb shell cat &#x2F;proc&#x2F;cpuinfo<br>2.9.12 内存信息<br>$adb shell cat &#x2F;proc&#x2F;meminfo<br>2.9.13更多硬件与系统属性<br>$adb shell cat &#x2F;system&#x2F;build.prop<br>adb shell getprop &lt;属性名&gt;</p>
<p>也可以</p>
<p>$adb shell cat &#x2F;system&#x2F;build.prop | grep ro.product.cpu.abi<br>$adb shell cat &#x2F;system&#x2F;build.prop | find “ro.product.cpu.abi”</p>
<p>2.10 修改设置<br>修改设置之后，运行恢复命令仍然不太正常，可以运行 adb reboot 重启设备或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p>
<p>2.10.1分辨率<br>adb shell wm size 480x1024 #将分辨率修改为 480px * 1024px</p>
<p>adb shell wm size reset #恢复原分辨率</p>
<p>2.10.2屏幕密度<br>adb shell wm density 160 #屏幕密度修改为 160dpi</p>
<p>adb shell wm density reset #恢复原屏幕密度</p>
<p>2.10.3显示区域<br>adb shell wm overscan 0,0,0,100</p>
<h1 id="四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部-100px留白"><a href="#四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部-100px留白" class="headerlink" title="四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 100px留白"></a>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 100px留白</h1><p>adb shell wm overscan reset #恢复显示区域</p>
<p>2.10.4 关闭 USB 调试模式<br>adb shell settings put global adb_enabled 0</p>
<p>使用命令无法恢复调试模式，只能通过手动</p>
<p>2.10.5 状态栏和导航栏的显示隐藏<br>adb shell settings put global policy_control <key-values></p>
<p><key-values> 可由如下几种键及其对应的值组成，格式为 <key1>&#x3D;<value1>:<key2>&#x3D;<value2></p>
<p>key 键对应的值</p>
<p>这些键对应的值可则如下值用逗号组合</p>
<p>示例：</p>
<h1 id="设置在所有界面下都同时隐藏状态栏和导航栏"><a href="#设置在所有界面下都同时隐藏状态栏和导航栏" class="headerlink" title="设置在所有界面下都同时隐藏状态栏和导航栏"></a>设置在所有界面下都同时隐藏状态栏和导航栏</h1><p>$adb shell settings put global policy_control immersive.full&#x3D;*</p>
<h1 id="设置在包名为-com-package1-和-com-package2-的应用里隐藏状态栏，在除了包名为-com-package3-的所有应用里隐藏导航栏。"><a href="#设置在包名为-com-package1-和-com-package2-的应用里隐藏状态栏，在除了包名为-com-package3-的所有应用里隐藏导航栏。" class="headerlink" title="设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。"></a>设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。</h1><p>$adb shell settings put global policy_control immersive.status&#x3D;com.package1,com.package2:immersive.navigation&#x3D;apps,-com.package3<br>2.11 实用功能<br>2.11.1屏幕截图<br>adb exec-out screencap -p &gt; img.png # 老版本无exec-out命令，只适合于新版的截图</p>
<p>adb shell screencap -p &#x2F;sdcard&#x2F;img.png # 老版本截图先保存在设备端</p>
<p>adb pull &#x2F;sdcard&#x2F;img.png # 通过pull拷贝到本地</p>
<p>screencap 参数：</p>
<p>参数 含义</p>
<p>-p 指定保存文件为 png 格式</p>
<p>-d display-id 指定截图的显示屏编号（有多显示屏的情况下）</p>
<p>2.11.2录制屏幕</p>
<h1 id="默认录制时间和最长录制时间都是180s"><a href="#默认录制时间和最长录制时间都是180s" class="headerlink" title="默认录制时间和最长录制时间都是180s"></a>默认录制时间和最长录制时间都是180s</h1><p>adb shell screenrecord &#x2F;sdcard&#x2F;filename.mp4</p>
<p>screenrecord 参数：</p>
<p>参数 含义</p>
<p>–size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。</p>
<p>–bit-rate RATE 视频的比特率，默认是 4Mbps。</p>
<p>–time-limit TIME 录制时长，单位秒。</p>
<p>–verbose 输出更多信息。</p>
<p>2.11.3 重新挂载 system 分区为可写</p>
<p>注：需要 root 权限</p>
<p>&#x2F;system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 &#x2F;system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<p>1.进入 shell 并切换到 root 用户权限。</p>
<p>$adb shell<br>$su<br>2.查看当前分区挂载情况。</p>
<p>$mount<br>输出如下<br>…..<br>debugfs &#x2F;sys&#x2F;kernel&#x2F;debug debugfs rw,relatime 0 0<br>none &#x2F;acct cgroup rw,relatime,cpuacct 0 0<br>none &#x2F;sys&#x2F;fs&#x2F;cgroup tmpfs rw,seclabel,relatime,mode&#x3D;750,gid&#x3D;1000 0 0<br>tmpfs &#x2F;mnt&#x2F;obb tmpfs rw,seclabel,relatime,mode&#x3D;755,gid&#x3D;1000 0 0<br>none &#x2F;dev&#x2F;cpuctl cgroup rw,relatime,cpu 0 0<br>&#x2F;dev&#x2F;block&#x2F;mtdblock0 &#x2F;system ext4 ro,seclabel,relatime,data&#x3D;ordered 0 0<br>…….<br>找到其中我们关注的带 &#x2F;system 的那一行：</p>
<p>3.重新挂载。</p>
<p>$mount -o remount,rw -t yaffs2 &#x2F;dev&#x2F;block&#x2F;mtdblock0 &#x2F;system<br>2.11.4 查看连接过的 WiFi 密码</p>
<p>注：需要 root 权限</p>
<p>$adb shell<br>$su<br>$cat &#x2F;data&#x2F;misc&#x2F;wifi&#x2F;*.conf<br>2.11.5设置系统日期和时间</p>
<p>注：需要 root 权限</p>
<p>$adb shell<br>$su<br>$date -s 20190531.131600  #将系统日期和时间更改为 2019 年 05 月 31 日 13 点 16 分 00 秒。<br>2.11.6 重启手机</p>
<p>$adb reboot<br>2.11.7 检测设备是否已 root</p>
<p>$adb shell<br>$su<br>此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。</p>
<p>2.11.8 使用 Monkey 进行压力测试</p>
<p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<h1 id="向-指定的应用程序发送-500-个伪随机事件"><a href="#向-指定的应用程序发送-500-个伪随机事件" class="headerlink" title="向  指定的应用程序发送 500 个伪随机事件"></a>向 <packagename> 指定的应用程序发送 500 个伪随机事件</h1><p>$adb shell monkey -p <packagename> -v 500<br>monkey 官方文档 <a target="_blank" rel="noopener" href="https://developer.android.com/studio/test/monkey.html">https://developer.android.com/studio/test/monkey.html</a></p>
<p>2.11.9 开启&#x2F;关闭 WiFi</p>
<p>注：需要 root 权限</p>
<p>开启 WiFi：</p>
<p>$adb root<br>$adb shell svc wifi enable<br>关闭 WiFi：</p>
<p>$adb root<br>$adb shell svc wifi disable</p>
<p>刷机相关命令<br>注：不要随便操作，没实验过无法保证成功</p>
<p>2.12.1重启到 Recovery 模式<br>$adb reboot recovery<br>2.12.2从 Recovery 重启到 Android<br>$adb reboot<br>2.12.3重启到 Fastboot 模式<br>$adb reboot bootloader<br>2.12.4通过 sideload 更新系统<br>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<p>1.重启到 Recovery 模式。</p>
<p>$adb reboot recovery<br>2.在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。</p>
<p>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。</p>
<p>3.通过 adb 上传和更新系统。</p>
<p>$adb sideload &lt;path-to-update.zip&gt;<br>2.13 更多 adb shell 命令<br>2.13.1查看进程<br>adb shell ps</p>
<p>2.13.2查看实时资源占用情况<br>adb shell top</p>
<p>top命令参数如下：</p>
<p>使用方法: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</p>
<p>-m num 最多显示多少个进程<br>-n num 刷新多少次后退出<br>-d num 刷新时间间隔（单位秒，默认值 5）<br>-s col 按某列排序（可用 col 值：cpu, vss, rss, thr）<br>-t 显示线程信息<br>-h 显示帮助文档<br>2.13.3其它</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220722-PowerShell管道使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/22/20220722-PowerShell%E7%AE%A1%E9%81%93%E4%BD%BF%E7%94%A8/"
    >20220722-PowerShell管道使用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/22/20220722-PowerShell%E7%AE%A1%E9%81%93%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2022-07-22T03:42:57.000Z" itemprop="datePublished">2022-07-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/powershell/module/microsoft.powershell.core/about/about_pipelines?view=powershell-7.2">https://docs.microsoft.com/zh-CN/powershell/module/microsoft.powershell.core/about/about_pipelines?view=powershell-7.2</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lavender000/p/6941393.html">https://www.cnblogs.com/lavender000/p/6941393.html</a></p>
<p>简短说明</p>
<p>在powershell 中将命令合并到管道中</p>
<p>长说明</p>
<p>管道是一系列由管道运算符连接的命令 |</p>
<p>可以发送第一个命令的输出，作为第二个命令的输入进行处理。 还可以将输出发送到另一个命令。 结果是一个复杂的命令链或 管道 ，由一系列简单的命令组成。</p>
<p>例如，</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command-1 | Command-2 | Command-3</span><br></pre></td></tr></table></figure>
<p>在此示例中，发出的对象 Command-1 将发送到 Command-2 。 Command-2 处理对象并将其发送到 Command-3 。 Command-3 处理对象并将其沿管道向下发送。 由于管道中没有更多命令，因此结果将显示在控制台上。</p>
<p>在管道中，按从左到右的顺序处理命令。 处理将作为单个操作进行处理，并在生成时显示输出。</p>
<p>下面是一个简单的示例。 以下命令将获取记事本进程，然后将其停止。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Process notepad | Stop-Process</span><br></pre></td></tr></table></figure>

<p>此管道示例获取当前目录中的文本文件，只选择长度超过10000个字节的文件，按长度对它们进行排序，并在表中显示每个文件的名称和长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get-ChildItem -Path *.txt |</span><br><span class="line">  Where-Object &#123;$_.length -gt 10000&#125; |</span><br><span class="line">    Sort-Object -Property length |</span><br><span class="line">      Format-Table -Property name, length</span><br></pre></td></tr></table></figure>

<p>此管道按指定顺序包含四个命令。 下图显示了每个命令的输出，因为它将传递到管道中的下一个命令。</p>
<p>使用管道</p>
<p>大多数powershell cmdlet 都设计为支持管道，在大多数情况下，你可以通过管道将Get cmdlet 的结果传递给相同名词的另一个cmdlet</p>
<p>例如，可以通过管道将 cmdlet 的输出 Get-Service 传递给 Start-Service 或 Stop-Service cmdlet。</p>
<p>此示例管道在计算机上启动 WMI 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Service wmi | Start-Service</span><br></pre></td></tr></table></figure>

<p>再例如，你可以通过管道将 PowerShell 注册表提供程序的输出 Get-Item Get-ChildItem 传递给 New-ItemProperty cmdlet。 此示例将值为 8124 的新注册表项 NoOfEmployees 添加到 MyCompany 注册表项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get-Item -Path HKLM:\Software\MyCompany |</span><br><span class="line">  New-ItemProperty -Name NoOfEmployees -Value 8124</span><br></pre></td></tr></table></figure>

<p>许多实用工具 cmdlet Get-Member （如、 Group-Object Where-Object Sort-Object 、、和 Measure-Object ）几乎只是在管道中使用。 可以通过管道将任何对象类型传递给这些 cmdlet。 此示例显示了如何按每个进程中打开的句柄数对计算机上的所有进程进行排序。</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Process | Sort-Object -Property handles</span><br></pre></td></tr></table></figure>
<p>可以通过管道将对象传递给格式设置、导出和输出 cmdlet，例如 Format-List 、 Format-Table Export-Clixml Export-CSV 、、和。 Out-File</p>
<p>此示例演示如何使用 Format-List cmdlet 显示进程对象的属性列表。</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Process winlogon | Format-List -Property *</span><br></pre></td></tr></table></figure>
<p>还可以通过管道将本机命令的输出传递给 PowerShell cmdlet。 例如：</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS&gt; ipconfig.exe | Select-String -Pattern &#x27;IPv4&#x27;</span><br><span class="line"></span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 172.24.80.1</span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 192.168.1.45</span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 100.64.108.37</span><br></pre></td></tr></table></figure>
<p> 重要</p>
<p>成功 和 错误 流类似于其他 shell 的 stdin 和 stderr 流。 但 stdin 未连接到 PowerShell 管道进行输入。 有关详细信息，请参阅 about_Redirection。</p>
<p>使用几个实践，你会发现将简单命令合并到管道可节省时间和键入内容，并使你的脚本更有效。</p>
<h2 id="管道的工作方式"><a href="#管道的工作方式" class="headerlink" title="管道的工作方式"></a>管道的工作方式</h2><p>本部分介绍如何将输入对象绑定到 cmdlet 参数并在管道执行期间进行处理。</p>
<h3 id="接受管道输入"><a href="#接受管道输入" class="headerlink" title="接受管道输入"></a>接受管道输入</h3><p>若要支持流水线，接收 cmdlet 必须具有接受管道输入的参数。 <code>Get-Help</code>使用带有 <strong>Full</strong> 或 <strong>Parameter</strong> 选项的命令来确定 cmdlet 接受管道输入的参数。</p>
<p>例如，若要确定 cmdlet 的哪些参数 <code>Start-Service</code> 接受管道输入，请键入：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> <span class="built_in">Start-Service</span> <span class="literal">-Full</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> <span class="built_in">Start-Service</span> <span class="literal">-Parameter</span> *</span><br></pre></td></tr></table></figure>

<p>Cmdlet 的帮助 <code>Start-Service</code> 显示：只有 <strong>InputObject</strong> 和 <strong>Name</strong> 参数接受管道输入。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-InputObject &lt;ServiceController[]&gt;</span><br><span class="line">Specifies ServiceController objects representing the services to be started.</span><br><span class="line">Enter a variable that contains the objects, or type a command or expression</span><br><span class="line">that gets the objects.</span><br><span class="line"></span><br><span class="line">Required?                    true</span><br><span class="line">Position?                    0</span><br><span class="line">Default value                None</span><br><span class="line">Accept pipeline input?       True (ByValue)</span><br><span class="line">Accept wildcard characters?  false</span><br><span class="line"></span><br><span class="line">-Name &lt;String[]&gt;</span><br><span class="line">Specifies the service names for the service to be started.</span><br><span class="line"></span><br><span class="line">The parameter name is optional. You can use Name or its alias, ServiceName,</span><br><span class="line">or you can omit the parameter name.</span><br><span class="line"></span><br><span class="line">Required?                    true</span><br><span class="line">Position?                    0</span><br><span class="line">Default value                None</span><br><span class="line">Accept pipeline input?       True (ByPropertyName, ByValue)</span><br><span class="line">Accept wildcard characters?  false</span><br></pre></td></tr></table></figure>

<p>当你通过管道将对象发送到 <code>Start-Service</code> 时，PowerShell 会尝试将对象与 <strong>InputObject</strong> 和 <strong>Name</strong> 参数相关联。</p>
<h3 id="接受管道输入的方法"><a href="#接受管道输入的方法" class="headerlink" title="接受管道输入的方法"></a>接受管道输入的方法</h3><p>Cmdlet 参数可采用以下两种不同方式之一接受管道输入：</p>
<ul>
<li><p><strong>ByValue</strong>：参数接受与所需的 .net 类型匹配或可转换为该类型的值。</p>
<p>例如，的 <strong>Name</strong> 参数 <code>Start-Service</code> 接受按值的管道输入。 它可以接受可以转换为字符串的字符串对象或对象。</p>
</li>
<li><p><strong>ByPropertyName</strong>：仅当输入对象具有与参数名称相同的属性时，此参数才接受输入。</p>
<p>例如，的 <code>Start-Service</code> name 参数可以接受具有 <strong>Name</strong> 属性的对象。 若要列出某个对象的属性，请将其传递到 <code>Get-Member</code> 。</p>
</li>
</ul>
<p>一些参数可以通过值或属性名称接受对象，使从管道中获取输入变得更加容易。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>当你通过管道将对象从一个命令传递给另一个命令时，PowerShell 会尝试将管道对象与接收 cmdlet 的参数相关联。</p>
<p>PowerShell 的参数绑定组件根据以下条件将输入对象与 cmdlet 参数关联：</p>
<ul>
<li>参数必须接受来自管道的输入。</li>
<li>参数必须接受要发送的对象的类型或可转换为预期类型的类型。</li>
<li>命令中未使用参数。</li>
</ul>
<p>例如， <code>Start-Service</code> cmdlet 具有多个参数，但其中只有两个参数、 <strong>名称</strong> 和 <strong>InputObject</strong> 接受管道输入。 <strong>Name</strong> 参数使用字符串， <strong>InputObject</strong> 参数使用服务对象。 因此，可以通过管道字符串、服务对象和具有可转换为字符串或服务对象的属性的对象。</p>
<p>PowerShell 会尽可能有效地管理参数绑定。 不能建议或强制 PowerShell 绑定到特定参数。 如果 PowerShell 无法绑定管道对象，则该命令将失败。</p>
<p>有关排除绑定错误的详细信息，请参阅本文后面的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/powershell/module/microsoft.powershell.core/about/about_pipelines?view=powershell-7.2#investigating-pipeline-errors">调查管道错误</a> 。</p>
<h3 id="一次一次性处理"><a href="#一次一次性处理" class="headerlink" title="一次一次性处理"></a>一次一次性处理</h3><p>通过管道将对象传递给命令与使用命令的参数来提交对象非常类似。 让我们看一看管道示例。 在此示例中，我们使用管道来显示服务对象表。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Service</span> | <span class="built_in">Format-Table</span> <span class="literal">-Property</span> Name, DependentServices</span><br></pre></td></tr></table></figure>

<p>在功能上，这与使用的 <strong>InputObject</strong> 参数 <code>Format-Table</code> 来提交对象集合类似。</p>
<p>例如，我们可以将服务集合保存到使用 <strong>InputObject</strong> 参数传递的变量。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$services</span> = <span class="built_in">Get-Service</span></span><br><span class="line"><span class="built_in">Format-Table</span> <span class="literal">-InputObject</span> <span class="variable">$services</span> <span class="literal">-Property</span> Name, DependentServices</span><br></pre></td></tr></table></figure>

<p>或者，可以将该命令嵌入到 <strong>InputObject</strong> 参数中。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Format-Table</span> <span class="literal">-InputObject</span> (<span class="built_in">Get-Service</span>) <span class="literal">-Property</span> Name, DependentServices</span><br></pre></td></tr></table></figure>

<p>但有一个重要的差异。 通过管道将多个对象传递给命令时，PowerShell 会一次将对象发送到命令。 使用命令参数时，对象将作为单个数组对象发送。 这种次要差别会产生重大后果。</p>
<p>执行管道时，PowerShell 会自动枚举任何实现 <code>IEnumerable</code> 接口的类型，并一次通过管道发送成员。 异常是 <code>[hashtable]</code> ，这需要调用 <code>GetEnumerator()</code> 方法。</p>
<p>在下面的示例中，将向 <code>Measure-Object</code> cmdlet 传递一个数组和一个哈希表，以计算从管道接收的对象数。 该数组具有多个成员，并且哈希表具有多个键值对。 一次只枚举一个数组。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">@</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) | <span class="built_in">Measure-Object</span></span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Count    : 3</span><br><span class="line">Average  :</span><br><span class="line">Sum      :</span><br><span class="line">Maximum  :</span><br><span class="line">Minimum  :</span><br><span class="line">Property :</span><br></pre></td></tr></table></figure>

<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">@</span>&#123;<span class="string">&quot;One&quot;</span>=<span class="number">1</span>;<span class="string">&quot;Two&quot;</span>=<span class="number">2</span>&#125; | <span class="built_in">Measure-Object</span></span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Count    : 1</span><br><span class="line">Average  :</span><br><span class="line">Sum      :</span><br><span class="line">Maximum  :</span><br><span class="line">Minimum  :</span><br><span class="line">Property :</span><br></pre></td></tr></table></figure>

<p>同样，如果你通过 <code>Get-Process</code> 管道将多个进程对象传递给 <code>Get-Member</code> cmdlet，则 PowerShell 会将每个进程对象一次发送到 <code>Get-Member</code> 。 <code>Get-Member</code> 显示 (类型的 .NET 类) 进程对象及其属性和方法。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Get-Member</span></span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TypeName: System.Diagnostics.Process</span><br><span class="line"></span><br><span class="line">Name      MemberType     Definition</span><br><span class="line">----      ----------     ----------</span><br><span class="line">Handles   AliasProperty  Handles = Handlecount</span><br><span class="line">Name      AliasProperty  Name = ProcessName</span><br><span class="line">NPM       AliasProperty  NPM = NonpagedSystemMemorySize</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p> 备注</p>
<p><code>Get-Member</code> 消除重复项，因此，如果所有对象都属于同一类型，则它只显示一种对象类型。</p>
<p>但是，如果使用的 <strong>InputObject</strong> 参数 <code>Get-Member</code> ，则 <code>Get-Member</code> 会将 <strong>system.object</strong> 对象的数组作为单个单元接收。 它显示对象数组的属性。 (记下 array 符号 (<code>[]</code> 在 <strong>system.object</strong> 类型名称后面) 。 )</p>
<p>例如，</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Member</span> <span class="literal">-InputObject</span> (<span class="built_in">Get-Process</span>)</span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TypeName: System.Object[]</span><br><span class="line"></span><br><span class="line">Name               MemberType    Definition</span><br><span class="line">----               ----------    ----------</span><br><span class="line">Count              AliasProperty Count = Length</span><br><span class="line">Address            Method        System.Object&amp; Address(Int32 )</span><br><span class="line">Clone              Method        System.Object Clone()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此结果可能不是你所期望的结果。 但在理解后，就可以使用它了。 例如，所有数组对象都具有 <strong>Count</strong> 属性。 可以使用它来计算计算机上运行的进程数。</p>
<p>例如，</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Get-Process</span>).count</span><br></pre></td></tr></table></figure>

<p>请务必记住，在管道中发送的对象每次传递一次。</p>
<h2 id="在管道中使用本机命令"><a href="#在管道中使用本机命令" class="headerlink" title="在管道中使用本机命令"></a>在管道中使用本机命令</h2><p>PowerShell 允许在管道中包含本机外部命令。 但是，请务必注意，PowerShell 的管道是面向对象的，不支持原始字节数据。</p>
<p>从输出原始字节数据的本机程序对输出进行管道或重定向会将输出转换为 .NET 字符串。 这种转换可能会导致原始数据输出损坏。</p>
<p>作为一种解决方法，使用 <code>cmd.exe /c</code> 或 <code>sh -c</code> 调用本机命令，并使用 <code>|</code> 本机 shell 提供的和 <code>&gt;</code> 运算符。</p>
<h2 id="调查管道错误"><a href="#调查管道错误" class="headerlink" title="调查管道错误"></a>调查管道错误</h2><p>当 PowerShell 无法将管道对象与接收 cmdlet 的参数关联时，该命令将失败。</p>
<p>在下面的示例中，我们尝试将注册表项从一个注册表项移到另一个注册表项。 该 <code>Get-Item</code> cmdlet 将获取目标路径，然后将该路径传递给 <code>Move-ItemProperty</code> cmdlet。 <code>Move-ItemProperty</code>命令指定要移动的注册表项的当前路径和名称。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\sales |</span><br><span class="line"><span class="built_in">Move-ItemProperty</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\design <span class="literal">-Name</span> product</span><br></pre></td></tr></table></figure>

<p>命令失败，PowerShell 将显示以下错误消息：</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Move-ItemProperty : The input object can&#x27;t be bound to any parameters for</span><br><span class="line">the command either because the command doesn&#x27;t take pipeline input or the</span><br><span class="line">input and its properties do not match any of the parameters that take</span><br><span class="line">pipeline input.</span><br><span class="line">At line:1 char:23</span><br><span class="line">+ $a | Move-ItemProperty &lt;&lt;&lt;&lt;  -Path HKLM:\Software\MyCompany\design -Name p</span><br></pre></td></tr></table></figure>

<p>若要进行调查，请使用 <code>Trace-Command</code> cmdlet 跟踪 PowerShell 的参数绑定组件。 下面的示例跟踪管道的执行过程中的参数绑定。 <strong>PSHost</strong> 参数将跟踪结果显示在控制台中， <strong>FilePath</strong> 参数会将跟踪结果发送到 <code>debug.txt</code> 文件，供以后参考。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Trace-Command</span> <span class="literal">-Name</span> ParameterBinding <span class="literal">-PSHost</span> <span class="literal">-FilePath</span> debug.txt <span class="literal">-Expression</span> &#123;</span><br><span class="line">  <span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\sales |</span><br><span class="line">    <span class="built_in">Move-ItemProperty</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\design <span class="literal">-Name</span> product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪的结果很长，但会显示绑定到 <code>Get-Item</code> cmdlet 的值，然后显示绑定到 <code>Move-ItemProperty</code> cmdlet 的命名值。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">BIND NAMED cmd line args [`Move-ItemProperty`]</span><br><span class="line">BIND arg [HKLM:\Software\MyCompany\design] to parameter [Path]</span><br><span class="line">...</span><br><span class="line">BIND arg [product] to parameter [Name]</span><br><span class="line">...</span><br><span class="line">BIND POSITIONAL cmd line args [`Move-ItemProperty`]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，它显示尝试将路径绑定到的 <code>Move-ItemProperty</code> <strong>目标</strong> 参数失败。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">BIND PIPELINE object to parameters: [`Move-ItemProperty`]</span><br><span class="line">PIPELINE object TYPE = [Microsoft.Win32.RegistryKey]</span><br><span class="line">RESTORING pipeline parameter&#x27;s original values</span><br><span class="line">Parameter [Destination] PIPELINE INPUT ValueFromPipelineByPropertyName NO</span><br><span class="line">COERCION</span><br><span class="line">Parameter [Credential] PIPELINE INPUT ValueFromPipelineByPropertyName NO</span><br><span class="line">COERCION</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>Get-Help</code>使用 cmdlet 查看 <strong>目标</strong> 参数的属性。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Get-Help Move-ItemProperty -Parameter Destination</span><br><span class="line"></span><br><span class="line">-Destination &lt;String&gt;</span><br><span class="line">    Specifies the path to the destination location.</span><br><span class="line"></span><br><span class="line">    Required?                    true</span><br><span class="line">    Position?                    1</span><br><span class="line">    Default value                None</span><br><span class="line">    Accept pipeline input?       True (ByPropertyName)</span><br><span class="line">    Accept wildcard characters?  false</span><br></pre></td></tr></table></figure>

<p>结果显示 <strong>目标</strong> 仅按属性名称获取管道输入。 因此，管道对象必须具有一个名为 “ <strong>Destination</strong>“ 的属性。</p>
<p>使用 <code>Get-Member</code> 可查看来自的对象 <code>Get-Item</code> 的属性。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\sales | <span class="built_in">Get-Member</span></span><br></pre></td></tr></table></figure>

<p>输出显示该项目是没有 <strong>目标</strong> 属性的 <strong>Microsoft. Win32</strong> 对象。 这说明了命令失败的原因。</p>
<p><strong>Path</strong> 参数按名称或值接受管道输入。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Get-Help Move-ItemProperty -Parameter Path</span><br><span class="line"></span><br><span class="line">-Path &lt;String[]&gt;</span><br><span class="line">    Specifies the path to the current location of the property. Wildcard</span><br><span class="line">    characters are permitted.</span><br><span class="line"></span><br><span class="line">    Required?                    true</span><br><span class="line">    Position?                    0</span><br><span class="line">    Default value                None</span><br><span class="line">    Accept pipeline input?       True (ByPropertyName, ByValue)</span><br><span class="line">    Accept wildcard characters?  true</span><br></pre></td></tr></table></figure>

<p>若要修复此命令，必须在 cmdlet 中 <code>Move-ItemProperty</code> 指定目标，并使用 <code>Get-Item</code> 获取要移动的项的 <strong>路径</strong> 。</p>
<p>例如，</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\design |</span><br><span class="line"><span class="built_in">Move-ItemProperty</span> <span class="literal">-Destination</span> HKLM:\Software\MyCompany\sales <span class="literal">-Name</span> product</span><br></pre></td></tr></table></figure>

<h2 id="内部续行符"><a href="#内部续行符" class="headerlink" title="内部续行符"></a>内部续行符</h2><p>正如前面所讨论的，管道是一系列由管道运算符连接的命令 (<code>|</code>) ，通常在一行上写入。 但是，为了提高可读性，PowerShell 允许跨多个行拆分管道。 当管道运算符是行上的最后一个标记时，PowerShell 分析器会将下一行连接到当前命令以继续构造管道。</p>
<p>例如，以下单行管道：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command<span class="literal">-1</span> | Command<span class="literal">-2</span> | Command<span class="literal">-3</span></span><br></pre></td></tr></table></figure>

<p>可以编写为：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Command<span class="literal">-1</span> |</span><br><span class="line">  Command<span class="literal">-2</span> |</span><br><span class="line">    Command<span class="literal">-3</span></span><br></pre></td></tr></table></figure>

<p>后续行中的前导空格并不重要。 缩进增强了可读性。</p>
<p>PowerShell 7 增加了对管道的延续的支持，并在行的开头提供管道字符。 下面的示例演示如何使用此新功能。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wrapping with a pipe at the beginning of a line (no backtick required)</span></span><br><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> CPU | <span class="built_in">Where-Object</span> Path</span><br><span class="line">    | <span class="built_in">Get-Item</span> | <span class="built_in">Where-Object</span> FullName <span class="operator">-match</span> <span class="string">&quot;AppData&quot;</span></span><br><span class="line">    | <span class="built_in">Sort-Object</span> FullName <span class="literal">-Unique</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wrapping with a pipe on a line by itself</span></span><br><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> CPU | <span class="built_in">Where-Object</span> Path</span><br><span class="line">    |</span><br><span class="line">    <span class="built_in">Get-Item</span> | <span class="built_in">Where-Object</span> FullName <span class="operator">-match</span> <span class="string">&quot;AppData&quot;</span></span><br><span class="line">    |</span><br><span class="line">    <span class="built_in">Sort-Object</span> FullName <span class="literal">-Unique</span></span><br></pre></td></tr></table></figure>

<p> 重要</p>
<p>在 shell 中以交互方式工作时，仅当使用Ctrl + V粘贴时，才将代码粘贴到行的开头。 右键单击 “粘贴操作”，一次插入一个行。 因为行不以管道字符结尾，所以 PowerShell 会将输入视为已完成，并按输入执行该行。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220716-ranger插件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/16/20220716-ranger%E6%8F%92%E4%BB%B6/"
    >20220716-ranger插件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/16/20220716-ranger%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2022-07-16T07:13:42.000Z" itemprop="datePublished">2022-07-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>http%3A&#x2F;&#x2F;ranger.github.io&#x2F;</p>
<p>ranger 是一个终端文件管理器，通过ranger 可以实现和windows 中类似的资源管理器的展示功能</p>
<p>ranger 分为三个部分</p>
<p>左边为上级目录结构</p>
<p>中间为当前可以操作的目录</p>
<p>右边为当前目录下面所有的文件</p>
<p>最底端的状态栏显示的是当前选中文件的一些文件信息，比如执行权限和上次修改的时间</p>
<p>安装 sudo apt-get install ranger</p>
<p>进入之后就可以使用 vim 的相关命令了，比如 hjkl 上下左右的操作 、:q 推出 等。</p>
<p>常用命令组合</p>
<p>除了最基本的 vim 操作的常用快捷键不在进行介绍之后，以下为常用的快捷键介绍。</p>
<p>S 使用终端定位到当前所在目录<br>H 后退<br>cw 重命名</p>
<p>on&#x2F;ob 根据文件名进行排序，<br>oc 根据改变时间进行排序<br>os 根据文件大小进行排序<br>ot 根据后缀名进行排序<br>oa 根据访问时间进行排序<br>om 根据修改进行排序</p>
<p>utf-8 支持</p>
<p>多栏显示<br>所选文件 目录的预览</p>
<p>常用文件操作票</p>
<p>类似vim 的控制台和热键</p>
<p>一次重命名多个文件<br>自动确定文件类型并使用正确的程序运行它们<br>退出 ranger 后更改 shell 目录<br>标签、书签、鼠标支持<br>真彩色图像预览 [如何启用]<br>视频缩略图 [如何启用]<br>依赖项<br>Python（测试版本为 2.7、3.1、3.2、3.3、3.4），支持 ncurses 和（可选）宽 unicode。<br>寻呼机（默认为less ）<br>可选的：</p>
<p>用于确定文件类型的文件<br>python 模块chardet，以防编码检测问题<br>“sudo”以使用“以 root 身份运行”功能<br>w3m用于以“真彩色”预览图像。<br>可选，用于增强文件预览（使用“scope.sh”）：</p>
<p>img2txt（来自caca-utils）用于预览ASCII-art中的图像<br>highlight用于代码的语法高亮<br>用于预览档案的工具<br>lynx、w3m或elinks用于预览 html 页面<br>pdftotext 用于 pdf 预览<br>传输显示查看比特种子信息<br>mediainfo或 exiftool 用于查看有关媒体文件的信息</p>
<p>ranger wiki <a target="_blank" rel="noopener" href="https://github.com/ranger/ranger/wiki">https://github.com/ranger/ranger/wiki</a></p>
<p>配置文件<br>将默认配置文件复制到该文件~&#x2F;.config&#x2F;range<br>$ ranger –copy-config&#x3D;all<br>1<br>ranger 使用4个主要配置文件：<br>文件名 描述<br>commands.py 包含以Python编写的各种函数的实现，用于修改ranger’s行为<br>rc.conf 用于设置各种选项并将按键绑定到功能<br>rifle.conf  决定使用哪个程序打开哪个文件<br>scope.sh  是一个shell脚本，用于生成各种文件类型的预览<br>宏指令<br>宏指令可以用在 command 命令中达到缩写命令的目的。</p>
<p>宏指令 功能<br>%f  高亮显示的文件<br>%d  当前文件夹的路径<br>%s  当前文件夹选择的文件<br>%t  当前文件夹所有标记的文件<br>%c  当前复制&#x2F;剪切文件的完整路径<br>%p  选择文件的完整路径<br>宏指令 %f、%d、%p 和 %s 有大写的变体，%F、%D、%P 和 %S，指下一个标记。为了表示一个特定的标记，可以在 % 和 字母 中间加一个数字，比如 %7s 指当前文件夹中第七个所选择的文件。<br>  %c 是唯一一个作用于当前文件夹以外的宏指令，所以你可以通过复制功能达到其他的目的。比如比较在两个在不同文件夹里的文件的不同：复制文件 A（键入 yy），然后切换到文件 B 的目录，并标记文件 B（键入 SPACE），最后键入 @，输入 shell: diff %c %s。对于文件路径的宏命令（%d、%c 和 %p）通常是转义了的，所以可以直接在 shell command 命令中使用。<br>  此外，如果你创建了使用 Key 的按键绑定，那么宏命令 %Key（或者 %Key0、%Key1、……)在 shell command 中就代表按下 Key 键几次。</p>
<p>文件选择<br>标记&#x2F;取消标记：space<br>反选：v<br>视觉模式开启&#x2F;关闭：V，在视觉模式下，移动光标即可选择条目。也可以按 uV或者 ESC 退出。<br>取消当前目录的全部标记：uv</p>
<p>黄色的 Mrk 符号位于终端右下角，表示此文件夹里有标记的文件。黄色的 Mrk 并不会因为切换目录而消失。</p>
<p>文件操作<br>复制：yy<br>剪切：dd<br>粘贴：pp<br>删除：dD</p>
<p>将不同目录的文件加入操作列表：ya<br>重命名：cw<br>在当前名称基础上重命名：A<br>类似A, 但是光标会跳到起始位置：I<br>向下翻一页：Ctrl+f或PAGEDOWN<br>向上翻一页：Ctrl+b或PAGEUP<br>向上翻半页：Ctrl+u或者K<br>向下翻半页：Ctrl+d或者 J<br>后退到上一个历史记录：H<br>前进到下一个历史记录：L</p>
<p>目录跳转<br>父目录上移：[<br>父目录下移：]<br>如果当前选中高亮的是是链接目录，直接跳到原目录内：g L<br>如果当前目录是链接目录内，直接跳到原目录：g l<br>跳转目录：g+其他</p>
<p>查看与编辑文件<br>操作  说明<br>i 或者 F3 调用 Pager 查看文件 与在终端中输入 pager + 文件名 一样。<br>E 或者 F4 调用默认编辑器编辑文件 可在终端中输入 select-editor 选择默认编辑器。<br>书签<br>新建书签：m<br>打开书签：&#96;<br>删除书签：um</p>
<p>标签<br>多标签即多窗口工作。可以在每个窗口来回切换。</p>
<p>新建标签：</p>
<p>g n<br>Ctrl+n<br>切换标签：</p>
<p>g t或g T<br>Tab 或 Shift+Tab<br>Alt+标签名<br>关闭标签：g c 或 Ctrl+w</p>
<p>链接<br>粘贴绝对路径的链接：pl<br>粘贴相对路径的链接：pL<br>硬链接：phl</p>
<p>排序<br>排序：o</p>
<p>名词  描述<br>atime access time，访问时间<br>basename  基于文件名<br>ctime change time，改变时间，文件的权限组别和文件自身数据被修改的时间<br>extension 扩展名<br>mtime modified time，修改时间<br>任务管理<br>在执行某些操作(比如复制一个大文件)时不能立即完成, 这在 ranger 中就是一个任务. 你可以停止, 启动某个任务, 也可以对某个任务设置优先级.</p>
<p>打开&#x2F;关闭任务视图：w<br>在打开的任务视图中：<br>终止一个任务：dd<br>降低当前任务的优先级：J<br>提升当前任务的优先级：K<br>预览<br>默认情况下，只能预览文本文件，但是你可以通过设定配置 use_preview_script 和 preview_files 为 true 来增加可以预览的文件类型。默认的预览脚本是 ~&#x2F;.config&#x2F;ranger&#x2F;scope.sh，安装如下工具（每种类型只需要一个）就预览对应的文件类型，scope.sh 会自动调用它们：</p>
<p>工具  预览文件类型  安装<br>lynx<br>elinks<br>w3m 网页  sudo apt install lynx<br>sudo apt install elinks<br>sudo apt install w3m<br>highlight<br>pygmentize  高亮代码  sudo apt install highlight<br>pip install pygmentize<br>img2txt 图片  sudo apt install caca-utils<br>atool<br>bsdtar<br>unrar<br>7z  压缩包 sudo apt install atool<br>sudo apt install libarchive-tools<br>sudo apt install unrar<br>sudo apt install p7zip<br>pdftotext<br>mutool  PDF sudo apt install poppler-utils<br>sudo apt install mupdf-tools<br>mediainfo<br>exiftool  媒体  sudo apt install mediainfo<br>sudo apt install libimage-exiftool-perl<br>ffmpegthumbnailer 视频缩略图 sudo apt install ffmpegthumbnailer<br>fontimage 字体  sudo apt install fontforge<br>transmission-show 种子  sudo apt install transmission-cli<br>独立于 preview script，有一个通过将图像用字符画的形式直接绘制到终端中的预览功能。要启用此功能，将 preview_images 选项设置为 true 并将 preview_images_method 选项设置为一种图像预览模式（需要安装这些工具）：</p>
<p>预览模式  是否适用于 ssh 注意  设置 preview_images_method 为<br>w3m 否 与 tmux 不兼容（尽管它可以工作）。  w3m<br>iTerm2  是 iTerm2 编译时必须添加 image preview support 选项。  iterm2<br>urxvt 否 urxvt 编译时必须添加 pixbuf support 选项。此模式本质上是将图像暂时设置为终端背景，这样它将破坏以前设置的任何图像背景。  urxvt<br>urxvt-full  否 与 urxvt 相同，但使用整个终端窗口预览图片。 urxvt-full<br>获取帮助<br>按下?时获取帮助，再使用按键选择帮助类型：</p>
<p>m: opens the man page for ranger（打开官方man手册）<br>k: opens a list of keybindings（打开按键绑定列表）<br>c: opens a list of available commands and descriptions（打开命令列表）<br>s: opens a list of settings and their current values（打开设置列表）<br>官方man手册网站：<a target="_blank" rel="noopener" href="https://ranger.github.io/ranger.1.html">https://ranger.github.io/ranger.1.html</a></p>
<p>其他<br>查找：f<br>搜索：&#x2F;<br>修改设置：z<br>显示隐藏文件：zh<br>打开&#x2F;关闭文件预览功能：zp<br>打开目录预览功能：zP<br>过滤器(如过滤pdf文件, zf+pdf,回车)：zf<br>在当前目录打开终端：S<br>目录展平：:flag (level)<br>批量重命名：标记选中后，输入:bulkrename</p>
<p>参考<br>官方用户指南<br><a target="_blank" rel="noopener" href="http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html">http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html</a><br>博客链接【推荐】<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xkfz008/article/details/7339530">https://blog.csdn.net/xkfz008/article/details/7339530</a></p>
<p>安装插件<br>ranger也有很多预览时用的插件 :</p>
<p>sudo apt-get install caca-utils # img2txt 图片<br>sudo apt-get install highlight  # 代码高亮<br>sudo apt-get install atool　    # 存档预览<br>sudo apt-get install w3m        # html页面预览<br>sudo apt-get install mediainfo  # 多媒体文件预览<br>1<br>2<br>3<br>4<br>5<br>当然还有其他文件格式的预览</p>
<p>sudo apt-get install catdoc     # doc预览<br>sudo apt-get install docx2txt   # docx预览<br>sudo apt-get install xlsx2csv   # xlsx预览<br>1<br>2<br>3<br>其他 :<br>zh&#x2F;退回键    显示隐藏文件</p>
<p>zp        打开&#x2F;关闭文件预览功能<br>zP        打开目录预览功能<br>1<br>2<br>3<br>4<br>当然ranger也是直接支持终端的基本命令的, 比如可以直接使用cd.</p>
<p>其次也支持其他方便操作的快捷方式. 如 : g可以快速的通过按键进入指定的目录中. 还有d等操作</p>
<p>最后, ranger还是直接支持鼠标点击.</p>
<p>参考 :<br>Ranger<br><a target="_blank" rel="noopener" href="http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html">http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220713-电子书管理工作流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/13/20220713-%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81/"
    >20220713-电子书管理工作流</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/13/20220713-%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81/" class="article-date">
  <time datetime="2022-07-12T23:58:42.000Z" itemprop="datePublished">2022-07-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>基于zotero+zotfile+syncthing+ReadEra，实现电脑+手机两端同步的电子书管理流程</p>
<p>视频大纲：<a target="_blank" rel="noopener" href="https://logseq.fishyer.com/#/page/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81">https://logseq.fishyer.com/#/page/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81</a></p>
<p>更多工具推荐，欢迎查看 <a target="_blank" rel="noopener" href="https://logseq.fishyer.com/">https://logseq.fishyer.com</a></p>
<p>public:true<br>1-用Zlibrary下载书，或者是其他网络渠道，比如百度网盘、阿里网盘、淘宝<br>2-导入到Zotero里面<br>安装Zotfile插件，配置附件路径为Dropbox网盘下的路径<br>3-配置Syncthing，同步书籍文件夹到Android手机上<br>电脑-Windows<br>C:\Users\Administrator\Dropbox\MyObsidian\MyAttachment\MyZotoreFile<br>手机-Android<br>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;MyObsidian<br>主要就是同步MyObsidian文件夹，下面的子文件夹自然就同步了<br>其实Mac电脑也支持，不过ios手机的话就稍稍麻烦一点<br>4-阅读方式<br>PDF就在电脑上用Zotero本身看<br>很方便截图标注<br>epub等其他格式，就直接在Android手机上ReadEra看<br>其实也可以用Calibre将其他类型转换为PDF，但是我现在的主力阅读器是手机，所以就不转PDF了<br>作用<br>Zotero-书架，添加标签和添加分类等<br>ReadEra-阅读器，方便随时随地看书</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220713-计算机定时启动程序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/13/20220713-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/"
    >20220713-计算机定时启动程序</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/13/20220713-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/" class="article-date">
  <time datetime="2022-07-12T23:56:32.000Z" itemprop="datePublished">2022-07-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>首先，shutdown.exe 的参数 -h 是睡眠。其次，在windows10的控制面板-管理工具-任务计划程序（当然，你从其他路径进去也一样）</p>
<ol>
<li><p>打开任务计划程序，在操作里选择创建基本任务。</p>
</li>
<li><p>第一步页面是让你写个你的任务名称，这个随意。</p>
</li>
<li><p>点下一步后会来到触发器页面，在这里你选每天。</p>
</li>
<li><p>继续下一步会来到每日页面，在这里设置一个开始的时间，然后间隔是一天。</p>
</li>
<li><p>再下一步会来到操作页面，选择启动程序。</p>
</li>
<li><p>再再下一步会来到完成页面，程序填shutdown.exe，然后添加参数（可选）里填 -h </p>
</li>
<li><p>完成。</p>
</li>
</ol>
<p>到时间电脑就会睡眠了，然后再开机后你会发现电脑之前打开的页面都还原封不动在。你可以先测试下。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220609-python-yield-use"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/09/20220609-python-yield-use/"
    >python中的yield用法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/09/20220609-python-yield-use/" class="article-date">
  <time datetime="2022-06-09T10:51:32.000Z" itemprop="datePublished">2022-06-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>yield 关键字做了什么</p>
<p>可以先把yield 当作return 的同胞兄弟来看</p>
<p>有return的函数直接返回所有结果，程序终止不再运行，并销毁局部变量</p>
<p>而有yield 的函数则返回一个可迭代的generator 生成器对象，你可以使用for 循环或者调用next 方法遍历生成器对象来提取结果</p>
<p>在python中，使用了yield 的函数被称为生成器，有点套娃的感觉</p>
<p>调用一个yield ，就会返回一个生成器对象</p>
<p>在调用生成器函数的过程中，每次遇到yield 时函数会暂停并保存当前所有的运行信息，保留局部变量，返回yield 的值，并在下一次执行next 方法时从当前位置继续运行，直到生成器全部遍历完</p>
<p>可以看到，simple——generator 函数返回一个生成器，调用next 方法后，函数开始运行，遇到第一个yield 关键字，返回生成的值 1 ，程序暂停</p>
<p>带yield 的函数是一个生成器，这个生成器有一个方法就是next next 就相当于 下一步 生成那个数，这一次的next 开始的地方是接着上一次的next 停止的地方执行的</p>
<p>所以调用next 的时候，生成器并不会从函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield 后，return 出要生成的数，此步就结束</p>
<p>生成器有哪些作用，如果想具体化数据的形式，他唱会将数据存储在一个列表中，但这样做，列表的内容将占用有形内存，列表越大，占用的内存资源就越多</p>
<p>但是，如果数据集有某种逻辑，就不必存储在一个列表中，只需编写一个生成器，它将在需要时生成这些值，基本不占用内存</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/13/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/15/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> TeX_baitu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="TeX_baitu blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>