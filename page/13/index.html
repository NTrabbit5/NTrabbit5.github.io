<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> TeX_baitu blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      


<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-20221216-C语言中typedef的使用方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/16/20221216-C%E8%AF%AD%E8%A8%80%E4%B8%ADtypedef%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"
    >20221216-C语言中typedef的使用方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/16/20221216-C%E8%AF%AD%E8%A8%80%E4%B8%ADtypedef%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2022-12-16T06:05:15.000Z" itemprop="datePublished">2022-12-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/298.html">http://c.biancheng.net/view/298.html</a></p>
<p>C语言用户使用typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型，数组类型名称，指针类型名称与用户自定义的结构型名称，共用型名称，枚举型名称等，一旦用户在程序中定义了自己的数据类型名称，就可以在该程序中用自己的数据类型名称来定义变量的类型，数组的类型，指针变量的类型与函数的类型等</p>
<p>C99 之前并未提供布尔类型，但我们可以使用typedef 关键字来定义一个简单的布尔类型，如下面的代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> BOOL;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line">BOOL bflag=TRUE;</span><br></pre></td></tr></table></figure>

<p>C99 标准中新增了布尔类型，自定义布尔变量的方式有两种，一种是使用<code> _BOOL</code>，另一种是使用<code>&lt;stdbool.h&gt;</code>头文件中定义好的 bool 类型，感兴趣的小伙伴请猛击这里了解详情。 </p>
<h2 id="typedef-的四种用法"><a href="#typedef-的四种用法" class="headerlink" title="typedef 的四种用法"></a>typedef 的四种用法</h2><p>在实际使用中，typedef 的应用主要有如下4种</p>
<p>为基本数据类型定义新的类型名</p>
<p>也就是说，系统默认的所有基本类型都可以利用typedef 关键字来重新定义类型名，示例代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> COUNT;</span><br></pre></td></tr></table></figure>

<p>而且我们还可以使用这种方法来定义与平台无关的类型，比如，要定义一个REAL 的浮点类型，在目标平台上，让它表示最高精度的类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>
<p>在不支持 long double 的平台二上，改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>
<p>甚至还可以在连 double 都不支持的平台三上，改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> REAL;</span><br></pre></td></tr></table></figure>

<p>这样，当跨平台移植程序时，我们只需要修改一个typedef 的定义即可，而不用对其他源代码做任何修改，其实，标准库中广泛地使用了这个技巧，比如 size_t 在 VC++2010 的 crtdefs.h 文件中的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SIZE_T_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int64    <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> _W64 <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SIZE_T_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为自定义数据类型 定义简洁的类名名称</p>
<p>以结构体为例，下面我们定义一个名为point的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在调用这个结构体时，我们必须像下面的代码这样来调用这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">oPoint1</span>=</span>&#123;<span class="number">100</span>，<span class="number">100</span>，<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">oPoint2</span>;</span></span><br></pre></td></tr></table></figure>
<p>这里，结构体 struct Point 为新的数据类型，在定义变量的时候均要向上面的调用方法一样有保留字struct ，而不能像int 和double 那样直接使用Point 来定义变量，现在，我们利用typedef 定义这个结构体，如下面的代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，实际上完成了两个操作<br>定义了一个新的结构类型，代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>其中，struct 关键字和tagPoint 一起构成了这个结构类型，无论是否存在typedef 关键字，这个结构都存在</p>
<p>使用typedef 为这个新的结构起了一个别名，叫Point 即</p>
<p>typedef struct tagPoint Point</p>
<p>因此，现在你就可以像int 和double 那样直接使用Point 定义变量，如下面的代码所示</p>
<p>Point oPoint1&#x3D;{100，100，0};<br>Point oPoint2;</p>
<p>为了加深对typedef 的理解，我们再来看一个结构体例子，如下面的代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *pItem;</span><br><span class="line">    pNode pNext;</span><br><span class="line">&#125; *pNode;</span><br></pre></td></tr></table></figure>

<p>从表面上看，上面的示例代码与前面的定义方法相同，所以应该没有什么问题，但是编译器却报了一个错误，</p>
<p>其实问题并非在于struct 定义的本身，大家应该都知道，C 语言是允许在结构中包含指向它自己的指针的，我们可以在建立链表等数据结构的实现上看到很多这类例子，那问题在哪里呢  ？其实，根本问题还是在于typedef 的应用 </p>
<p>在上面的代码中，新结构建立的过程中遇到了pNext 声明，其类型是pNode 这里要特别注意的是，pNode 表示的是该结构体的新别名。于是问题出现了，在结构体类型本身还没有建立完成的时候，编译器根本就不认识pNode 因为这个结构体类型的新别名还不存在，所以自然就会报错，因此，我们要做一些适当的调整，比如将结构体中的pNext 声明修改成如下方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *pItem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNext</span>;</span></span><br><span class="line">&#125; *pNode;</span><br></pre></td></tr></table></figure>

<p>或者将struct 与typedef 分开定义，如下面的代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *pItem;</span><br><span class="line">    pNode pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们同样使用typedef 给一个还未完全声明的类型tagNode 起了一个新别名，</p>
<p>不过，虽然C 语言编译器完全支持这种做法，但不推荐这样做，建议还是使用如下规范定义方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *pItem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNode</span>;</span></span><br></pre></td></tr></table></figure>

<p>为数组定义简洁的类型名称</p>
<p>它的定义方法很简单，与为基本数据类型定义新的别名方法一样，示例代码如下所示，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT_ARRAY_100[<span class="number">100</span>];</span><br><span class="line">INT_ARRAY_100 arr;</span><br></pre></td></tr></table></figure>

<p>为指针定义简洁的名称</p>
<p>对于 指针，我们同样可以使用下面的方式来定义一个新的别名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line">PCHAR pa;</span><br></pre></td></tr></table></figure>

<p>对于下面这种简单的变量声明，使用typedef 来定义一个新的别名或许会感觉意义不大，但在比较复杂的变量声明中，typedef 的优势马上就体现出来了，如下面的示例代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *(*a[<span class="number">5</span>])(<span class="type">int</span>,<span class="type">char</span>*);</span><br></pre></td></tr></table></figure>

<p>对于上面变量的声明，如果我们使用typedef 来给它定义一个别名，这会非常有意义，如下面的代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PFun是我们创建的一个类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *(*PFun)(<span class="type">int</span>,<span class="type">char</span>*);</span><br><span class="line"><span class="comment">// 使用定义的新类型来声明对象，等价于int*(*a[5])(int,char*);</span></span><br><span class="line">PFun a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h2 id="小心使用typedef-带来的陷阱"><a href="#小心使用typedef-带来的陷阱" class="headerlink" title="小心使用typedef 带来的陷阱"></a>小心使用typedef 带来的陷阱</h2><p>接下来看一个简单的typedef 使用示例，如下面的代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> PCHAR,<span class="type">const</span> PCHAR)</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>const PCHAR</code> 使用相当于const char* 呢</p>
<p>答案是否定的，原因很简单，typedef 是用来定义一种类型的新别名的，它不同于宏，不是简单的字符串替换，因此，const PCHAR 中的const 给予了整个指针本身常量性，也就是形成了常量指针，<code>char *const</code> 一个指向char 的常量指针。即它实际上相当于“char<em>const”，而不是“const char</em>（指向常量 char 的指针）”。当然，要想让 const PCHAR 相当于 const char* 也很容易，如下面的代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* PCHAR;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(PCHAR， PCHAR)</span>;</span><br></pre></td></tr></table></figure>

<p>其实，无论什么时候，只要为指针声明 typedef ，那么就应该在最终的typedef 名称中加一个const 以使得指针本身是常量</p>
<p>还需要特别注意的是，虽然typedef 并不真正影响对象的存储特性，但在语法上它还是一个存储类的关键字，就像auto extern static 和register 等关键字一样，因此，像下面这种声明是不可行的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">static</span> <span class="type">int</span> INT_STATIC;</span><br></pre></td></tr></table></figure>

<p>不可行的原因是不能声明多个存储类关键字，由于 typedef 已经占据了存储类关键字的位置，因此，在 typedef 声明中就不能够再使用 static 或任何其他存储类关键字了。当然，编译器也会报错，如在 VC++2010 中的报错信息为“无法指定多个存储类”。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221216-python3简单的串口通信实现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/16/20221216-python3%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/"
    >20221216-python3简单的串口通信实现</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/16/20221216-python3%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2022-12-16T04:45:11.000Z" itemprop="datePublished">2022-12-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>串口通信就是计算机和外设之间，通过数据信号线，底线、控制线等，按位进行传输数据的一种通讯方式，这种通讯方式使用的数据线少</p>
<p>串口是一种接口标准，它规定了接口的电气标准，没有规定接口插件电缆及使用的协议</p>
<p>python</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221216-导电斑马条"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/16/20221216-%E5%AF%BC%E7%94%B5%E6%96%91%E9%A9%AC%E6%9D%A1/"
    >20221216-导电斑马条</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/16/20221216-%E5%AF%BC%E7%94%B5%E6%96%91%E9%A9%AC%E6%9D%A1/" class="article-date">
  <time datetime="2022-12-16T04:43:22.000Z" itemprop="datePublished">2022-12-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>我们液晶连接中往往为节约空间会选择使用斑马条来进行连接，那么什么是斑马条的，下面给大家做个简单的介绍。导电橡胶连接器俗称为斑马条，由导电硅胶和绝缘硅胶交替分层叠加后硫化成型。导电橡胶连接器性能稳定可靠，生产装配简便且效率高。广泛用于游戏机、电话、电子表、计算器、仪表等产品的液晶显示器与电路板的连接。</p>
<p>如何确定斑马条大小呢：</p>
<p>1.长度设计：玻璃的长度-0.5mm ( 20 mm 以下依照原 LCD 玻璃长度 )</p>
<p>2.高度设计：LCD至PCB之间高度x(1.08<del>1.12)  —-压缩比8%</del>12%</p>
<p>3. 宽度设计: LCD边缘宽度×(0.9 ~ 0.95)</p>
<p>4. 导电层宽度的选择: (Connector上的W’的尺寸)</p>
<p>5. Pitch之选择：以LCD或PCB上的Pitch ( 宽度) 上有2 ~ 3条Connector在上面为原则,越多条导电性越佳</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221216-单片机的烧写原理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/16/20221216-%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%83%A7%E5%86%99%E5%8E%9F%E7%90%86/"
    >20221216-单片机的烧写原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/16/20221216-%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%83%A7%E5%86%99%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2022-12-16T04:29:08.000Z" itemprop="datePublished">2022-12-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>单片机烧写，又称为单片机程序下载，烧录等，本质上是单片机和pc 机按照芯片厂家规定的编程协议，通过芯片厂家规定的接口，把已编译好的程序传输到单片机上，单片机把数据存储到自身存储器中的过程，在嵌入式系统中，常需要将代码或数据烧写至MCU内flash 或片外的norFlash 等<br>下面介绍几种芯片烧写方法</p>
<h2 id="编程器烧写"><a href="#编程器烧写" class="headerlink" title="编程器烧写"></a>编程器烧写</h2><p>使用专用编程器加上对应的适配座完成flash 烧写操作，要求芯片先烧写完成再焊接在目标板上，这种方式是最常用的，速度快，易上手是它的最大特点，</p>
<p>由于各种芯片不同封装，需要不同的适配座，这是客户需要考虑的投入</p>
<h2 id="ISP-烧写"><a href="#ISP-烧写" class="headerlink" title="ISP 烧写"></a>ISP 烧写</h2><p>在系统编程（In-System Programming），通过MCU片内BootROM完成在板Flash烧写操作。要求芯片出厂时带有ISP固件，一般通过串行方式烧写，这种方式烧写速度很慢，不适用烧写容量大的代码场合。比如：LPC1700系列芯片，通过串口接口，使用上位机软件FlashMagic即可烧写，由于串行烧写速度慢，不适用于量产烧写的场合。</p>
<h2 id="IAP-烧写"><a href="#IAP-烧写" class="headerlink" title="IAP 烧写"></a>IAP 烧写</h2><p>在应用编程中，IAP 支持用户程序运行时烧写flash 但要求部分用户程序已经烧写至mcu 片内 flash</p>
<h2 id="调试接口烧写"><a href="#调试接口烧写" class="headerlink" title="调试接口烧写"></a>调试接口烧写</h2><p>由于Arm®内核的芯片越来越普及，借助仿真器通过MCU的调试接口(如JTAG&#x2F;SWD等)控制MCU完成片内Flash甚至外扩的Flash烧写。这种方式芯片先焊接在板上再烧写，适用于产品维修升级，不需要多次焊接芯片，特别对于管脚数较大的芯片，多次焊接容易导致损坏；同样适用于封装怪异的MCU，如QFP144&#x2F;QFN&#x2F;HVQFN&#x2F;BGA等。</p>
<p>通常我们把第一种称为离线烧写或者裸片烧写，另外的isp 烧写  iap 烧写，调试接口 烧写称为在线烧写，就是芯片已经安装至电路板的情况下，不需要将芯片从电路板取下即可完成flash 的烧写操作</p>
<p>理解这个原理需要知道几个知识点</p>
<p>单片机内部是由程序的，是出厂时固化在硬件中，用户无法修改的，这些程序可以调用各种通信接口，内部存储器等</p>
<p>可以下载的通信接口 ：JTAG,SPI,UART，usb等；（还有很多可以扩展485、以太网等）</p>
<p>编程协议  一般大厂都会公开，在芯片的专用技术手册中会有</p>
<p>存储器：有很多种，掩膜，EPROM，EEROM，flash等寿命不一样，掩膜只能一次，而且要工厂做，flash擦写次数10000+；</p>
<p>可以这样比喻性的理解：单片机就是电脑的主板，我们写的程序就是操作系统，主板里面装入引导操作系统的基本程序，下载程序就是给电脑装系统！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221215-使用wttr-in在你的终端中显示天气预报"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/15/20221215-%E4%BD%BF%E7%94%A8wttr-in%E5%9C%A8%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%98%BE%E7%A4%BA%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/"
    >20221215-使用wttr.in在你的终端中显示天气预报</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/15/20221215-%E4%BD%BF%E7%94%A8wttr-in%E5%9C%A8%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%98%BE%E7%A4%BA%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/" class="article-date">
  <time datetime="2022-12-15T02:04:16.000Z" itemprop="datePublished">2022-12-15</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>wttr.in 是一个功能丰富的天气预报服务，它支持在命令行显示天气，它可以 根据你的ip 地址<br>自动检测你的位置，也支持指定位置或搜索地理位置，如城市，山区等，另外，你不需要安装它，你只需要使用curl 或wget </p>
<p>wttr.in 功能包括</p>
<p>显示当前天气以及3天内的天气预报，分为早晨，中午、傍晚和夜晚 包括温度范围、风速和风向 可见度，降水量 和概率</p>
<p>可以显示月相</p>
<p>基于你的ip地址自动检测位置</p>
<p>允许指定城市名称，3字母的机场代码，区域代码，GPS坐标，IP 地址或域名，你还可以指定地理位置，如湖泊 山脉，地标等</p>
<p>支持多语言位置名称  查询字符串必须以unicode 指定</p>
<p>支持指定天气预报显示的语言  它支持超过50种语言</p>
<p>来自美国的查询使用uscs 单位用于，世界其他地方使用公制系统，但你可以通过附加?u 使用uscs 附加?m 使用公制系统</p>
<p>3种输出格式，终端的ansi 浏览器的html 和png </p>
<p>或者你可以安装wego 这是一个使用wtter.in 的终端气候应用，虽然wego 要求注册一个api 密钥来安装</p>
<p><a target="_blank" rel="noopener" href="http://wttr.in/">http://wttr.in</a> 命令行示例<br>获取你所在位置的天气（<a target="_blank" rel="noopener" href="http://wttr.in/">http://wttr.in</a> 会根据你的 IP 地址猜测你的位置）：</p>
<p>curl wttr.in<br>通过在 curl 之后添加 -4，强制 cURL 将名称解析为 IPv4 地址（如果你用 IPv6 访问 wttr.in 有问题）：</p>
<p>curl -4 wttr.in<br>如果你想检索天气预报保存为 png，还可以使用 Wget（而不是 cURL），或者你想这样使用它：</p>
<p>wget -O- -q wttr.in<br>如果相对 cURL 你更喜欢 Wget ，可以在下面的所有命令中用 wget -O- -q 替换 curl。</p>
<p>指定位置：</p>
<p>curl wttr.in&#x2F;Dublin<br>显示地标的天气信息（本例中为艾菲尔铁塔）：</p>
<p>curl wttr.in&#x2F;~Eiffel+Tower<br>获取 IP 地址位置的天气信息（以下 IP 属于 GitHub）：</p>
<p>curl wttr.in&#x2F;@192.30.253.113<br>使用 USCS 单位检索天气：</p>
<p>curl wttr.in&#x2F;Paris?u<br>如果你在美国，强制 <a target="_blank" rel="noopener" href="http://wttr.in/">http://wttr.in</a> 使用公制系统（SI）：</p>
<p>curl wttr.in&#x2F;New+York?m<br>使用 Wget 将当前天气和 3 天预报下载为 PNG 图像：</p>
<p>wget wttr.in&#x2F;Istanbul.png<br>你可以指定 PNG 的透明度，这在你要使用一个脚本自动添加天气信息到某些图片（比如墙纸）上有用。</p>
<p>对于其他示例，请查看wttr.in 项目页面或在终端中输入 </p>
<p>curl wttr.in&#x2F;:help</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221214-通过Content-Type和文件头判断文件类型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-%E9%80%9A%E8%BF%87Content-Type%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"
    >20221214-通过Content-Type和文件头判断文件类型</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-%E9%80%9A%E8%BF%87Content-Type%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2022-12-14T12:43:46.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="通过Content-Type和文件头判断文件类型"><a href="#通过Content-Type和文件头判断文件类型" class="headerlink" title="通过Content-Type和文件头判断文件类型"></a>通过Content-Type和文件头判断文件类型</h1><h2 id="关于MIME"><a href="#关于MIME" class="headerlink" title="关于MIME"></a>关于MIME</h2><p><strong>MIME</strong>的全称是Multipurpose Internet Mail Extensions，即多用途互联网邮件扩展，尽管读起来有些拗口，但大多数人可能都知道，<br>这是HTTP协议中用来定义文档性质及格式的标准。<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6838">IETF RFC 6838</a>，对HTTP传输内容类型进行了全面定义。<br>而<strong>IANA</strong>(互联网号码分配机构)是负责管理所有标准MIME类型的官方机构。可以<a target="_blank" rel="noopener" href="https://www.iana.org/assignments/media-types/media-types.xhtml">在这里</a>)找到所有的标准MIME</p>
<p><strong>服务器通过MIME告知响应内容类型，而浏览器则通过MIME类型来确定如何处理文档；</strong><br><strong>因此为传输内容(文档、图片等)设置正确的MIME非常重要</strong>。</p>
<p>通常Server会在HTTP响应中设置<strong>Content-Type</strong>，如下面的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeHTTP/1.1 200 OKServer: Golfe2    Content-Length: 233Content-Type: application/htmlDate: Sun, 28 Dec 2018 02:55:19 GMT12345</span><br></pre></td></tr></table></figure>

<p>这表示服务端将返回html格式的文档，而同样客户端也可以在HTTP请求中设置<strong>Content-Type</strong>以告知服务器当前所发送内容的格式。<br>如下面的请求体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodePOST / HTTP/1.1Host: localhost:8000User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Connection: keep-aliveContent-Type: application/jsonContent-Length: 4651234567</span><br></pre></td></tr></table></figure>

<p>这表示客户端会发送application&#x2F;json格式的数据到服务端，同时应该注意到<strong>Accept</strong>请求头，这个选项用于告知服务器应该返回什么样的数据格式(由客户端接收并完成解析)。</p>
<p><strong>MIME的格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Codetype/subtype1</span><br></pre></td></tr></table></figure>

<p>这是一个两级的分类，比较容易理解，第一级分类通常包含：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>普通文本</td>
</tr>
<tr>
<td>image</td>
<td>某种图像</td>
</tr>
<tr>
<td>audio</td>
<td>某种音频文件</td>
</tr>
<tr>
<td>video</td>
<td>某种视频文件</td>
</tr>
<tr>
<td>application</td>
<td>应用数据</td>
</tr>
<tr>
<td>multi-part</td>
<td>复合内容</td>
</tr>
</tbody></table>
<p>而二级类型则非常多，以下是一些常用的MIME：</p>
<table>
<thead>
<tr>
<th>MIME</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>audio&#x2F;wav</td>
<td>wave音频流媒体文件</td>
</tr>
<tr>
<td>audio&#x2F;webm</td>
<td>webm 音频文件格式</td>
</tr>
<tr>
<td>audio&#x2F;ogg</td>
<td>ogg多媒体文件格式的音频文件</td>
</tr>
<tr>
<td>audio&#x2F;mpeg</td>
<td>mpeg多媒体文件格式的音频文件</td>
</tr>
<tr>
<td>image&#x2F;gif</td>
<td>gif图片</td>
</tr>
<tr>
<td>image&#x2F;jpeg</td>
<td>jpeg图片</td>
</tr>
<tr>
<td>image&#x2F;png</td>
<td>png图片</td>
</tr>
<tr>
<td>image&#x2F;svg+xml</td>
<td>svg矢量图片</td>
</tr>
<tr>
<td>application&#x2F;json</td>
<td>json格式</td>
</tr>
<tr>
<td>application&#x2F;xml</td>
<td>xml格式</td>
</tr>
<tr>
<td>application&#x2F;xhtml+xml</td>
<td>扩展html格式</td>
</tr>
<tr>
<td>application&#x2F;x-www-form-urlencoded</td>
<td>表单url内容编码</td>
</tr>
<tr>
<td>application&#x2F;octet-stream</td>
<td>二进制格式</td>
</tr>
<tr>
<td>application&#x2F;pdf</td>
<td>pdf文档</td>
</tr>
<tr>
<td>application&#x2F;atom+xml</td>
<td>atom订阅feed流</td>
</tr>
<tr>
<td>multipart&#x2F;form-data</td>
<td>多文档格式</td>
</tr>
<tr>
<td>text&#x2F;plain</td>
<td>普通文本</td>
</tr>
<tr>
<td>text&#x2F;html</td>
<td>html文档</td>
</tr>
<tr>
<td>text&#x2F;css</td>
<td>css文件</td>
</tr>
<tr>
<td>text&#x2F;javascript</td>
<td>javascript文件</td>
</tr>
<tr>
<td>text&#x2F;markdown</td>
<td>markdown文档</td>
</tr>
<tr>
<td>video&#x2F;mpeg</td>
<td>mpeg多媒体视频文件</td>
</tr>
<tr>
<td>video&#x2F;quicktime</td>
<td>mov多媒体视频文件</td>
</tr>
</tbody></table>
<h4 id="MIME-Type-与-Content-Type-的关系"><a href="#MIME-Type-与-Content-Type-的关系" class="headerlink" title="MIME Type 与 Content-Type 的关系"></a>MIME Type 与 Content-Type 的关系</h4><p>首先看看tomcat服务器中默认的web.xml中的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code&lt;!-- ===================== Default MIME Type Mappings =================== --&gt;&lt;!-- When serving static resources, Tomcat will automatically generate    --&gt;&lt;!-- a &quot;Content-Type&quot; header based on the resource&#x27;s filename extension, --&gt;&lt;!-- based on these mappings. Additional mappings can be added here (to --&gt;&lt;!-- apply to all web applications), or in your own application&#x27;s web.xml --&gt;&lt;!-- deployment descriptor.   --&gt;123456</span><br></pre></td></tr></table></figure>

<p>再看看apache服务器中mime.types的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeThis file controls what Internet media types are sent to the client forgiven file extension(s). Sending the correct media type to the clientis important so they know how to handle the content of the file.Extra types can either be added here or by using an AddType directivein your config files. For more information about Internet media types,please read RFC 2045, 2046, 2047, 2048, and 2077. The Internet media type registry is at http://www.iana.org/assignments/media-types/.123456</span><br></pre></td></tr></table></figure>

<p><strong>当web服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的MIME配置文件中找到对应的MIME Type，再根据MIME Type设置HTTP Response的Content-Type，然后浏览器根据Content-Type的值处理文件。</strong></p>
<p>也就是说, <strong>文件扩展名&#x3D;&gt;MIME Type&#x3D;&gt;Content-Type</strong></p>
<h2 id="通过文件头识别文件"><a href="#通过文件头识别文件" class="headerlink" title="通过文件头识别文件"></a>通过文件头识别文件</h2><p>不同的文件类型有不同的文件头, 而文件头部的几个字节被称为Magic Number, 通常用十六进制表示, 可用来判断文件类型.</p>
<p>比如png文件的文件头Magic Number是0x89504E开始的, java class文件Magic Number为Oxcafebabe</p>
<p>我们可以通过判断文件的文件头信息来判断文件的类型, 而且<strong>即使改变文件扩展名文件头信息也是不改变的</strong>.</p>
<p>通过java代码判断文件类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Javapublic class FileType &#123;    //默认判断文件头前三个字节内容    public static int CHECK_BYTES_NUMBER = 3;    public final static Map&lt;String, String&gt; FILE_TYPE_MAP = new HashMap&lt;String, String&gt;();    private FileType()&#123;&#125;    static&#123;        getAllFileType(); //初始化文件类型信息    &#125;    /**     * Discription:[getAllFileType,常见文件头信息]     */    private static void getAllFileType()    &#123;        FILE_TYPE_MAP.put(&quot;ffd8ffe000104a464946&quot;, &quot;jpg&quot;); //JPEG (jpg)        FILE_TYPE_MAP.put(&quot;89504e470d0a1a0a0000&quot;, &quot;png&quot;); //PNG (png)        FILE_TYPE_MAP.put(&quot;47494638396126026f01&quot;, &quot;gif&quot;); //GIF (gif)        FILE_TYPE_MAP.put(&quot;49492a00227105008037&quot;, &quot;tif&quot;); //TIFF (tif)        FILE_TYPE_MAP.put(&quot;424d228c010000000000&quot;, &quot;bmp&quot;); //16色位图(bmp)        FILE_TYPE_MAP.put(&quot;424d8240090000000000&quot;, &quot;bmp&quot;); //24位位图(bmp)        FILE_TYPE_MAP.put(&quot;424d8e1b030000000000&quot;, &quot;bmp&quot;); //256色位图(bmp)        FILE_TYPE_MAP.put(&quot;41433130313500000000&quot;, &quot;dwg&quot;); //CAD (dwg)        FILE_TYPE_MAP.put(&quot;3c21444f435459504520&quot;, &quot;html&quot;); //HTML (html)        FILE_TYPE_MAP.put(&quot;3c21646f637479706520&quot;, &quot;htm&quot;); //HTM (htm)        FILE_TYPE_MAP.put(&quot;48544d4c207b0d0a0942&quot;, &quot;css&quot;); //css        FILE_TYPE_MAP.put(&quot;696b2e71623d696b2e71&quot;, &quot;js&quot;); //js        FILE_TYPE_MAP.put(&quot;7b5c727466315c616e73&quot;, &quot;rtf&quot;); //Rich Text Format (rtf)        FILE_TYPE_MAP.put(&quot;38425053000100000000&quot;, &quot;psd&quot;); //Photoshop (psd)        FILE_TYPE_MAP.put(&quot;46726f6d3a203d3f6762&quot;, &quot;eml&quot;); //Email [Outlook Express 6] (eml)        FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;doc&quot;); //MS Excel 注意：word、msi 和 excel的文件头一样        FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;vsd&quot;); //Visio 绘图        FILE_TYPE_MAP.put(&quot;5374616E64617264204A&quot;, &quot;mdb&quot;); //MS Access (mdb)        FILE_TYPE_MAP.put(&quot;252150532D41646F6265&quot;, &quot;ps&quot;);        FILE_TYPE_MAP.put(&quot;255044462d312e350d0a&quot;, &quot;pdf&quot;); //Adobe Acrobat (pdf)        FILE_TYPE_MAP.put(&quot;2e524d46000000120001&quot;, &quot;rmvb&quot;); //rmvb/rm相同        FILE_TYPE_MAP.put(&quot;464c5601050000000900&quot;, &quot;flv&quot;); //flv与f4v相同        FILE_TYPE_MAP.put(&quot;00000020667479706d70&quot;, &quot;mp4&quot;);        FILE_TYPE_MAP.put(&quot;49443303000000002176&quot;, &quot;mp3&quot;);        FILE_TYPE_MAP.put(&quot;000001ba210001000180&quot;, &quot;mpg&quot;); //        FILE_TYPE_MAP.put(&quot;3026b2758e66cf11a6d9&quot;, &quot;wmv&quot;); //wmv与asf相同        FILE_TYPE_MAP.put(&quot;52494646e27807005741&quot;, &quot;wav&quot;); //Wave (wav)        FILE_TYPE_MAP.put(&quot;52494646d07d60074156&quot;, &quot;avi&quot;);        FILE_TYPE_MAP.put(&quot;4d546864000000060001&quot;, &quot;mid&quot;); //MIDI (mid)        FILE_TYPE_MAP.put(&quot;504b0304140000000800&quot;, &quot;zip&quot;);        FILE_TYPE_MAP.put(&quot;526172211a0700cf9073&quot;, &quot;rar&quot;);        FILE_TYPE_MAP.put(&quot;235468697320636f6e66&quot;, &quot;ini&quot;);        FILE_TYPE_MAP.put(&quot;504b03040a0000000000&quot;, &quot;jar&quot;);        FILE_TYPE_MAP.put(&quot;4d5a9000030000000400&quot;, &quot;exe&quot;);//可执行文件        FILE_TYPE_MAP.put(&quot;3c25402070616765206c&quot;, &quot;jsp&quot;);//jsp文件        FILE_TYPE_MAP.put(&quot;4d616e69666573742d56&quot;, &quot;mf&quot;);//MF文件        FILE_TYPE_MAP.put(&quot;3c3f786d6c2076657273&quot;, &quot;xml&quot;);//xml文件        FILE_TYPE_MAP.put(&quot;494e5345525420494e54&quot;, &quot;sql&quot;);//xml文件        FILE_TYPE_MAP.put(&quot;7061636b616765207765&quot;, &quot;java&quot;);//java文件        FILE_TYPE_MAP.put(&quot;406563686f206f66660d&quot;, &quot;bat&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;1f8b0800000000000000&quot;, &quot;gz&quot;);//gz文件        FILE_TYPE_MAP.put(&quot;6c6f67346a2e726f6f74&quot;, &quot;properties&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;cafebabe0000002e0041&quot;, &quot;class&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;49545346030000006000&quot;, &quot;chm&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;04000000010000001300&quot;, &quot;mxp&quot;);//bat文件        FILE_TYPE_MAP.put(&quot;504b0304140006000800&quot;, &quot;docx&quot;);//docx文件        FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;wps&quot;);//WPS文字wps、表格et、演示dps都是一样的        FILE_TYPE_MAP.put(&quot;6431303a637265617465&quot;, &quot;torrent&quot;);        FILE_TYPE_MAP.put(&quot;6D6F6F76&quot;, &quot;mov&quot;); //Quicktime (mov)        FILE_TYPE_MAP.put(&quot;FF575043&quot;, &quot;wpd&quot;); //WordPerfect (wpd)        FILE_TYPE_MAP.put(&quot;CFAD12FEC5FD746F&quot;, &quot;dbx&quot;); //Outlook Express (dbx)        FILE_TYPE_MAP.put(&quot;2142444E&quot;, &quot;pst&quot;); //Outlook (pst)        FILE_TYPE_MAP.put(&quot;AC9EBD8F&quot;, &quot;qdf&quot;); //Quicken (qdf)        FILE_TYPE_MAP.put(&quot;E3828596&quot;, &quot;pwl&quot;); //Windows Password (pwl)        FILE_TYPE_MAP.put(&quot;2E7261FD&quot;, &quot;ram&quot;); //Real Audio (ram)    &#125;    /**     * 根据制定文件的文件头判断其文件类型     * @param filePaht     * @return     */    public static String getFileType(String filePaht)&#123;        String res = null;        try &#123;            FileInputStream is = new FileInputStream(filePaht);            getFileType(is);        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;        return res;    &#125;    public static String getFileType(InputStream in)&#123;        String res = null;        try &#123;            byte[] b = new byte[CHECK_BYTES_NUMBER];            in.read(b, 0, b.length);            String fileCode = bytesToHexString(b);//            System.out.println(fileCode);            //这种方法在字典的头代码不够位数的时候可以用但是速度相对慢一点            Iterator&lt;String&gt; keyIter = FILE_TYPE_MAP.keySet().iterator();            while(keyIter.hasNext())&#123;                String key = keyIter.next();                if(key.toLowerCase().startsWith(fileCode.toLowerCase()) || fileCode.toLowerCase().startsWith(key.toLowerCase()))&#123;                    res = FILE_TYPE_MAP.get(key);                    break;                &#125;            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return res;    &#125;    /**     * 得到上传文件的文件头     * @param src     * @return     */    public static String bytesToHexString(byte[] src) &#123;        StringBuilder stringBuilder = new StringBuilder();        if (src == null || src.length &lt;= 0) &#123;            return null;        &#125;        for (int i = 0; i &lt; src.length; i++) &#123;            int v = src[i] &amp; 0xFF;            String hv = Integer.toHexString(v);            if (hv.length() &lt; 2) &#123;                stringBuilder.append(0);            &#125;            stringBuilder.append(hv);        &#125;        return stringBuilder.toString();    &#125;    public static int getCheckBytesNumber() &#123;        return CHECK_BYTES_NUMBER;    &#125;    public static void setCheckBytesNumber(int checkBytesNumber) &#123;        CHECK_BYTES_NUMBER = checkBytesNumber;    &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150</span><br></pre></td></tr></table></figure>

<p>常见文件头表示如下:</p>
<p>255044PDF<br>526563 EML<br>D0CF11 PPT<br>4D5AEE COM<br>E93B03 COM<br>4D5A90 EXE<br>424D3E BMP<br>49492A TIF<br>384250 PSD<br>C5D0D3 EPS<br>0A0501 PCS<br>89504E PNG<br>060500 RAW<br>000002 TGA<br>60EA27 ARJ<br>526172 RAR<br>504B03 ZIP<br>495363 CAB<br>1F9D8C Z<br>524946 WAV<br>435753 SWF<br>3026B2 WMV<br>3026B2 WMA<br>2E524D RM<br>00000F MOV<br>000077 MOV<br>000001 MPA<br>FFFB50 MP3<br>234558 m3u<br>3C2144 HTM<br>FFFE3C XSL<br>3C3F78 XML<br>3C3F78 MSC<br>4C0000 LNK<br>495453 CHM<br>805343 scm<br>D0CF11 XLS<br>31BE00 WRI<br>00FFFF MDF<br>4D4544 MDS<br>5B436C CCD<br>00FFFF IMG<br>FFFFFF SUB<br>17A150 PCB<br>2A5052 ECO<br>526563 PPC<br>000100 DDB<br>42494C LDB<br>2A7665 SCH<br>2A2420 LIB<br>434841 FNT<br>7B5C72 RTF<br>7B5072 GTD<br>234445 PRG<br>000007 PJT<br>202020 BAS<br>000002 TAG<br>4D5A90 dll<br>4D5A90 OCX<br>4D5A50 DPL<br>3F5F03 HLP<br>4D5A90 OLB<br>4D5A90 IMM<br>4D5A90 IME<br>3F5F03 LHP<br>C22020 NLS<br>5B5769 CPX<br>4D5A16 DRV<br>5B4144 PBK<br>24536F PLL<br>4E4553 NES<br>87F53E GBC<br>00FFFF SMD<br>584245 XBE<br>005001 XMV<br>000100 TTF<br>484802 PDG<br>000100 TST<br>414331 dwg<br>D0CF11 max</p>
<p>另外还有一些重要的文件，<strong>没有固定的文件头</strong>，如下：</p>
<p><strong>TXT 没固定文件头定义</strong><br>TMP 没固定文件头定义<br>INI 没固定文件头定义<br>BIN 没固定文件头定义<br>DBF 没固定文件头定义<br>C 没没固定文件头定义<br>CPP 没固定文件头定义<br>H 没固定文件头定义<br>BAT 没固定文件头定义</p>
<p>还有一些不同的文件有相同的文件头，最典型的就是下面：</p>
<p>4D5A90 EXE<br>4D5A90 dll<br>4D5A90 OCX<br>4D5A90 OLB<br>4D5A90 IMM<br>4D5A90 IME</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>当我们需要实现上传文件的时候, 为了安全起见, 我们需要判断上传文件的格式, 防止将病毒木马等有害的文件上传到服务器上.</p>
<p>判断文件类型的三种方式</p>
<ul>
<li><p>通过文件后缀名</p>
<p>这个方法只要修改后缀名就可以了</p>
</li>
<li><p>通过Content-Type判断</p>
<p>但是Content-Type取决于文件类型, 文件类型取决于文件扩展名, 所以改变了文件扩展名就改变了Content-Type</p>
</li>
<li><p>通过文件头判断文件, 即使文件扩展名改变了文件头也不会改变</p>
</li>
</ul>
<p>文件上传的思路: 先判断Content-Type, Content-Type符合条件的再判断文件头信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java<span class="meta">@ResponseBody</span>    <span class="meta">@GetMapping(&quot;validate&quot;)</span>    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">validate</span><span class="params">(<span class="meta">@Validated(&#123;AllFiled.class&#125;)</span> UserInfo userInfo, BindingResult result)</span>&#123;<span class="comment">//        SpringValidatorAdapter adapter = (SpringValidatorAdapter)result;        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        if (result.hasErrors()) &#123;            List&lt;ObjectError&gt; list  = result.getAllErrors();            for (ObjectError error :                    list) &#123;                FieldError fieldError = (FieldError)error;                String defaultMessage = fieldError.getDefaultMessage();                String field = fieldError.getField();                map.put(field, defaultMessage);            &#125;        &#125;        return map;    &#125;//    consumes = &#123;//        MediaType.MULTIPART_FORM_DATA_VALUE &#125;, produces = MediaType.TEXT_PLAIN_VALUE    @PostMapping(value = &quot;file&quot;)    @ResponseBody    public String file(@RequestParam(&quot;username&quot;) String name, MultipartFile file) throws IOException &#123;        //获取文件名        String fileName = file.getOriginalFilename();        //获取表单提交文件使用的字段        String partName = file.getName();        //判断文件是否为空        boolean empty = file.isEmpty();        //获取ContentType        String contentType = file.getContentType();        //获取文件直接数        Long size = file.getSize();        //获取文件所有字节        byte[] bytes = file.getBytes();        //获取InputStream        InputStream in = file.getInputStream();        //根据文件头获取文件类型        String type = FileType.getFileType(in);                //业务.....        StringBuilder builder = new StringBuilder();        //存储文件        File root = new File(&quot;D:/temp&quot;);        if (!root.isDirectory()) &#123;            root.mkdirs();        &#125;        try &#123;            file.transferTo(new File(root, name));            return String.format(&quot;Upload to %s&quot;, fileName);        &#125; catch (IllegalStateException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return &quot;Upload Failed&quot;;    &#125;</span></span><br></pre></td></tr></table></figure>


 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221214-二维码版本与容量"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%89%88%E6%9C%AC%E4%B8%8E%E5%AE%B9%E9%87%8F/"
    >20221214-二维码版本与容量</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%89%88%E6%9C%AC%E4%B8%8E%E5%AE%B9%E9%87%8F/" class="article-date">
  <time datetime="2022-12-14T12:07:19.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>二维码 QR - 版本与容量</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>矩阵大小</th>
<th>纠错等级</th>
<th>八位字节</th>
<th>数字</th>
<th>字母数字</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>21</td>
<td>L</td>
<td>17</td>
<td>41</td>
<td>25</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>14</td>
<td>34</td>
<td>20</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>11</td>
<td>27</td>
<td>16</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>7</td>
<td>17</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>25</td>
<td>L</td>
<td>32</td>
<td>77</td>
<td>47</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>26</td>
<td>63</td>
<td>38</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>20</td>
<td>48</td>
<td>29</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>14</td>
<td>34</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>29</td>
<td>L</td>
<td>53</td>
<td>127</td>
<td>77</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>42</td>
<td>101</td>
<td>61</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>32</td>
<td>77</td>
<td>47</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>24</td>
<td>58</td>
<td>35</td>
</tr>
<tr>
<td>4</td>
<td>33</td>
<td>L</td>
<td>78</td>
<td>187</td>
<td>114</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>62</td>
<td>149</td>
<td>90</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>46</td>
<td>111</td>
<td>67</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>34</td>
<td>82</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td>37</td>
<td>L</td>
<td>106</td>
<td>255</td>
<td>154</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>84</td>
<td>202</td>
<td>122</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>60</td>
<td>144</td>
<td>87</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>44</td>
<td>106</td>
<td>64</td>
</tr>
<tr>
<td>6</td>
<td>41</td>
<td>L</td>
<td>134</td>
<td>322</td>
<td>195</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>106</td>
<td>255</td>
<td>154</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>74</td>
<td>178</td>
<td>108</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>58</td>
<td>139</td>
<td>84</td>
</tr>
<tr>
<td>7</td>
<td>45</td>
<td>L</td>
<td>154</td>
<td>370</td>
<td>224</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>122</td>
<td>293</td>
<td>178</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>86</td>
<td>207</td>
<td>125</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>64</td>
<td>154</td>
<td>93</td>
</tr>
<tr>
<td>8</td>
<td>49</td>
<td>L</td>
<td>192</td>
<td>461</td>
<td>279</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>152</td>
<td>365</td>
<td>221</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>108</td>
<td>259</td>
<td>157</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>84</td>
<td>202</td>
<td>122</td>
</tr>
<tr>
<td>9</td>
<td>53</td>
<td>L</td>
<td>230</td>
<td>552</td>
<td>335</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>180</td>
<td>432</td>
<td>262</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>130</td>
<td>312</td>
<td>189</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>98</td>
<td>235</td>
<td>143</td>
</tr>
<tr>
<td>10</td>
<td>57</td>
<td>L</td>
<td>271</td>
<td>652</td>
<td>395</td>
</tr>
<tr>
<td></td>
<td></td>
<td>M</td>
<td>213</td>
<td>513</td>
<td>311</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td>151</td>
<td>364</td>
<td>221</td>
</tr>
<tr>
<td></td>
<td></td>
<td>H</td>
<td>119</td>
<td>288</td>
<td>174</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221214-PDF文本的基本结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-PDF%E6%96%87%E6%9C%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"
    >20221214-PDF文本的基本结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-PDF%E6%96%87%E6%9C%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2022-12-14T06:11:47.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>PDF 文件是可以有效随机存取和增量更新的，根据基本规则，一个PDF 文件由四部分组成</p>
<ol>
<li>header部分：占一行，标识PDF规范的版本；</li>
<li>body部分：包含PDF文件中的所有obj对象；</li>
<li>cross-reference table 部分：交叉引用表，包含文件中间接对象的信息；</li>
<li>trailer部分：包含交叉引用表和文件正文中某些特殊对象的位置；</li>
</ol>
<p>按照惯例，PDF 文件中的标记按行排列，每行的终止标记可以是回车、换行、或两者兼有，包含二进制数据的PDF 文件可以有任意长的行</p>
<p>为了提高PDF 文件的兼容性，不属于流对象的数据行限制为不超过255个字符，但有一个例外，签名字典的内容字符串不受行长度限制</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221214-PNG格式详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/20221214-PNG%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"
    >20221214-PNG格式详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/20221214-PNG%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-12-14T03:35:43.000Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>png 是20世纪90年代开始开发的图像文件存储格式，其目的是替代gif 和tiff 文件格式，同时增加一些gif 文件格式所不具备的特性，流式网络图形格式名称来源于非官方的  是一种位图文件存储格式，读成ping 。png 用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的alpha 通道，png 使用从LZ77 派生的无损数据压缩算法</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>使用调色板技术可支持256种颜色的彩色图像  必须的</p>
<p>流式读 写性，图像文件格式允许连续读出和写入图像数据 因此适于网络传播</p>
<p>逐次逼近显示，这种特性可使在通信链路上传输图像文件的同时就在终端上显示图像，把整个轮廓显示出来之后逐步显示图像的细节，也就是先用低分辨率显示图像，然后逐步提高它的分辨率  类似马赛克逐渐消除的过程</p>
<p>透明性，这个性能可使图像中某些部分不显示出来，用来创建一些有特色的图像</p>
<p>辅助信息，这个特性可用来在图像文件中存储一些文本注释信息  就是可以说一些废话</p>
<p>独立于计算机硬件环境</p>
<p>使用无损压缩</p>
<p>可在一个文件中存储多幅图像</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>png 图像格式文件由文件署名和数据块 组成</p>
<p>文件署名域</p>
<p>8字节的png 文件署名域用来识别该文件是不是png 文件，该域的值是 </p>
<p>十进制数  十六进制数<br>137 89<br>80  50<br>78  4e<br>71  47<br>13  0d<br>10  0a<br>26  1a<br>10  0a<br>这个文件署名就是在《利用文件头标志判断文件类型》中提到的文件头标志了，很简单。</p>
<p>数据块</p>
<p>这里有两种类型的数据块，一种是称为关键数据块，就是必须要有的块，另一种叫做辅助数据块</p>
<p>每个数据块都由下表所示的4个域组成</p>
<p>名称  字节数 说明<br>Length(长度)  4字节 指定数据块中数据域的长度，其长度不超过(231−1)(231−1)字节<br>Chunk Type Code(数据块类型码) 4字节 数据块类型码由ASCII字母(A-Z和a-z)组成<br>Chunk Data(数据块实际内容  可变长度  存储按照Chunk Type Code指定的数据<br>CRC(循环冗余检测  4字节 存储用来检测是否有错误的循环冗余码</p>
<p>其中CRC 域中的值是对chunk type code 域和chunk data 域中的数据进行计算得到的，可以看作一种校验码</p>
<p>关键数据块</p>
<p>关键数据块中的4个标准数据块是</p>
<p>文件头数据块 IHDR</p>
<p>它包含有png 文件中存储的图像数据的基本信息，并要作为第一个数据块出现在png 数据流中，而且一个png 数据流中只能有一个文件头数据块</p>
<p>文件头数据块由13字节，组成结构如下</p>
<table>
<thead>
<tr>
<th>域的名称</th>
<th>字节数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Width</td>
<td>4 bytes</td>
<td>图像宽度，以像素为单位</td>
</tr>
<tr>
<td>Height</td>
<td>4 bytes</td>
<td>图像高度，以像素为单位</td>
</tr>
<tr>
<td>Bit depth</td>
<td>1 byte</td>
<td>图像深度：索引彩色图像：1，2，4或8 ;灰度图像：1，2，4，8或16 ;真彩色图像：8或16</td>
</tr>
<tr>
<td>ColorType</td>
<td>1 byte</td>
<td>颜色类型：0：灰度图像, 1，2，4，8或16;2：真彩色图像，8或16;3：索引彩色图像，1，2，4或84：带α通道数据的灰度图像，8或16;6：带α通道数据的真彩色图像，8或16</td>
</tr>
<tr>
<td>Compression method</td>
<td>1 byte</td>
<td>压缩方法(LZ77派生算法)</td>
</tr>
<tr>
<td>Filter method</td>
<td>1 byte</td>
<td>滤波器方法</td>
</tr>
<tr>
<td>Interlace method</td>
<td>1 byte</td>
<td>隔行扫描方法：0：非隔行扫描;1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td>
</tr>
</tbody></table>
<p>调色板数据块PLTE</p>
<p>它包含有与索引彩色图像相关的彩色变换数据，它仅与索引彩色图像有关，而且要放在图像数据块之前，真彩色的png 数据流也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像，结构如下</p>
<p>|颜色|字节|意义|<br>|Red|1 byte | 0 &#x3D; 黑色, 255 &#x3D; 红|<br>|Green|1 byte | 0 &#x3D; 黑色, 255 &#x3D; 绿色|<br>|Blue|1 byte | 0 &#x3D; 黑色, 255 &#x3D; 蓝色|</p>
<p>PLTE 数据块是定义图像的调色板信息，PLTE 可以包含1-256 个调色板信息，每个调色板信息由3个字节组成，因此调色板数据块所包含的最大字节数为768 调色板的长度应该是3的倍数，否则，这将使一个非法的调色板</p>
<p>对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是 1 2 调色板的颜色数不能超过色深中规定的颜色数，否则，这将导致png 图像不合法</p>
<p>图像数据块 IDAT </p>
<p>它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块<br>IDAT 存放着图像真正的数据信息，因此，如果能够了解IDAT 的结构，我们就可以很方便的生成PNG 图像</p>
<p>图像结束数据IEND </p>
<p>它用来标记png 文件或者数据流已经结束，并且必须要放在文件的尾部</p>
<p>如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：</p>
<p>00 00 00 00 49 45 4E 44 AE 42 60 82</p>
<p>不难明白，由于数据块结构的定义，IEND 数据块的长度总是0 0000000除非认为加入信息，数据标识总是iend 因此，CRC码也总是AE 42 60 82</p>
<p>最后，除了表示数据块开始IHDR 必须放在最前面，表示png 文件结束的iend 数据块放在最后面，其他数据块的存放顺序没有限制</p>
<p>辅助数据块</p>
<p>比较杂 ，不需要全部了解透</p>
<p>PNG 文件格式规范指定的10个辅助数据块是</p>
<p>背景颜色数据块 bKGD</p>
<p>基色和白色度数块cHRM 所谓白色度是指当 R G B 最大值时在显示器上产生的白色度</p>
<p>图像gamma 数据块 gAMA</p>
<p>图像直方图数据块hIST<br>物理像素尺寸数据块 pHYs</p>
<p>样本有效位数据块 sBIT</p>
<p>文本信息数据块 tEXt<br>图像最后修改时间数据块 tIME<br>图像透明数据块 tRNS </p>
<p>压缩文本数据块 zTXt</p>
<h2 id="数据块摘要"><a href="#数据块摘要" class="headerlink" title="数据块摘要"></a>数据块摘要</h2><p>关键数据块，辅助数据块和专用公共数据块 综合下表中</p>
<table>
<thead>
<tr>
<th>数据块符号</th>
<th>数据块名称</th>
<th>多数据块</th>
<th>可选否</th>
<th>位置限制</th>
</tr>
</thead>
<tbody><tr>
<td>IHDR</td>
<td>文件头数据块</td>
<td>否</td>
<td>否</td>
<td>第一块</td>
</tr>
<tr>
<td>cHRM</td>
<td>基色和白色点数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE和IDAT之前</td>
</tr>
<tr>
<td>gAMA</td>
<td>图像γ数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE和IDAT之前</td>
</tr>
<tr>
<td>sBIT</td>
<td>样本有效位数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE和IDAT之前</td>
</tr>
<tr>
<td>PLTE</td>
<td>调色板数据块</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>bKGD</td>
<td>背景颜色数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE之后IDAT之前</td>
</tr>
<tr>
<td>hIST</td>
<td>图像直方图数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE之后IDAT之前</td>
</tr>
<tr>
<td>tRNS</td>
<td>图像透明数据块</td>
<td>否</td>
<td>是</td>
<td>在PLTE之后IDAT之前</td>
</tr>
<tr>
<td>oFFs</td>
<td>(专用公共数据块)</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>pHYs</td>
<td>物理像素尺寸数据块</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>sCAL</td>
<td>(专用公共数据块)</td>
<td>否</td>
<td>是</td>
<td>在IDAT之前</td>
</tr>
<tr>
<td>IDAT</td>
<td>图像数据块</td>
<td>是</td>
<td>否</td>
<td>与其他IDAT连续</td>
</tr>
<tr>
<td>tIME</td>
<td>图像最后修改时间数据块</td>
<td>否</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>tEXt</td>
<td>文本信息数据块</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>zTXt</td>
<td>压缩文本数据块</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>fRAc</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>gIFg</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>gIFt</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>gIFx</td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr>
<td>IEND</td>
<td>图像结束数据</td>
<td>否</td>
<td>否</td>
<td>最后一个数据块</td>
</tr>
</tbody></table>
<p>tEXt和zTXt数据块中的标准关键字：</p>
<p>关键字 说明<br>Title 图像名称或者标题<br>Author  图像作者名<br>Description 图像说明<br>Copyright 版权声明<br>CreationTime  原图创作时间<br>Software  创作图像使用的软件<br>Disclaimer  弃权<br>Warning 图像内容警告<br>Source  创作图像使用的设备<br>Comment 各种注释<br>一个例子</p>
<!-- http://qr61.cn/o8bjsz/qEp8BlI --> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20221213-BMP格式结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/20221213-BMP%E6%A0%BC%E5%BC%8F%E7%BB%93%E6%9E%84/"
    >20221213-BMP格式结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/20221213-BMP%E6%A0%BC%E5%BC%8F%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2022-12-13T11:26:33.000Z" itemprop="datePublished">2022-12-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>docs.microsoft.com&#x2F;zh-cn&#x2F;windows&#x2F;win32&#x2F;gdibitmap-storage</p>
<p>简介</p>
<p>bmp 图形文件是windows 采用的图形文件格式，在windows 环境下运行的所有图像处理软件都支持BMP 图像文件格式，windows 系统内部各图像绘制操作都是以BMP 为基础的</p>
<p>因此把这种BMP 图像文件格式称为设备相关位图 DDB 文件格式，<br>目的是为了人windows 能够在任何类型的显示设备上显示所存储的图像</p>
<p>bmp 位图文件默认的文件扩展名是bmp</p>
<p>BMP 格式结构</p>
<p>BMP 文件的数据按照从文件头开始的先后顺序分为四个部分</p>
<p>位图文件头，提供文件的格式 大小等信息</p>
<p>位图信息头 提供图像数据的尺寸，位平面数，压缩方式，颜色索引等信息</p>
<p>调色板 可选，如使用索引来表示图像，调色板就是索引与其对饮的颜色的映射表</p>
<p>位图数据 图像数据区</p>
<p>BMP图片文件数据表如下：</p>
<p>数据段名称<br>大小（byte）<br>开始地址<br>结束地址<br>位图文件头(bitmap-file header)<br>14<br>0000h<br>000Dh<br>位图信息头(bitmap-information header)<br>40<br>000Eh<br>0035h<br>调色板(color table)<br>由biBitCount决定<br>0036h<br>未知<br>图片点阵数据(bitmap data)<br>由图片大小和颜色定<br>未知<br>未知</p>
<p>三、BMP 文件头</p>
<p>BMP文件头结构体定义如下：<br>typedef struct tagBITMAPFILEHEADER<br>{<br>UINT16 bfType;        &#x2F;&#x2F;2Bytes，必须为”BM”，即0x424D 才是Windows位图文件<br>DWORD bfSize;         &#x2F;&#x2F;4Bytes，整个BMP文件的大小<br>UINT16 bfReserved1;  &#x2F;&#x2F;2Bytes，保留，为0<br>UINT16 bfReserved2;  &#x2F;&#x2F;2Bytes，保留，为0<br>DWORD bfOffBits;     &#x2F;&#x2F;4Bytes，文件起始位置到图像像素数据的字节偏移量<br>} BITMAPFILEHEADER;</p>
<p>BMP文件头数据表如下：</p>
<p>变量名<br>地址偏移<br>大小<br>作用说明<br>bfType<br>0000h<br>2Bytes<br>文件标识符，必须为”BM”，即0x424D 才是Windows位图文件<br>‘BM’：Windows 3.1x, 95, NT,…　　‘BA’：OS&#x2F;2 Bitmap Array　　‘CI’：OS&#x2F;2 Color Icon 　　<br>‘CP’：OS&#x2F;2 Color Pointer 　　‘IC’：OS&#x2F;2 Icon 　　<br>‘PT’：OS&#x2F;2 Pointer<br>因为OS&#x2F;2系统并没有被普及开，所以在编程时，你只需判断第一个标识“BM”就行<br>bfSize<br>0002h<br>4Bytes<br>整个BMP文件的大小（以位B为单位）<br>bfReserved1<br>0006h<br>2Bytes<br>保留，必须设置为0<br>bfReserved2<br>0008h<br>2Bytes<br>保留，必须设置为0<br>bfOffBits<br>000Ah<br>4Bytes<br>说明从文件头0000h开始到图像像素数据的字节偏移量（以字节Bytes为单位），以为位图的调色板长度根据位图格式不同而变化，可以用这个偏移量快速从文件中读取图像数据</p>
<p>四、BMP 信息头</p>
<p>BMP信息头结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tagBMP_INFOHEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD  biSize;    <span class="comment">//4Bytes，INFOHEADER结构体大小，存在其他版本I NFOHEADER，用作区分</span></span><br><span class="line">LONG   biWidth;    <span class="comment">//4Bytes，图像宽度（以像素为单位）</span></span><br><span class="line">LONG   biHeight;    <span class="comment">//4Bytes，图像高度，+：图像存储顺序为Bottom2Top，-：Top2Bottom</span></span><br><span class="line">WORD   biPlanes;    <span class="comment">//2Bytes，图像数据平面，BMP存储RGB数据，因此总为1</span></span><br><span class="line">WORD   biBitCount;         <span class="comment">//2Bytes，图像像素位数</span></span><br><span class="line">DWORD  biCompression;     <span class="comment">//4Bytes，0：不压缩，1：RLE8，2：RLE4</span></span><br><span class="line">DWORD  biSizeImage;       <span class="comment">//4Bytes，4字节对齐的图像数据大小</span></span><br><span class="line">LONG   biXPelsPerMeter;   <span class="comment">//4 Bytes，用象素/米表示的水平分辨率</span></span><br><span class="line">LONG   biYPelsPerMeter;   <span class="comment">//4 Bytes，用象素/米表示的垂直分辨率</span></span><br><span class="line">DWORD  biClrUsed;          <span class="comment">//4 Bytes，实际使用的调色板索引数，0：使用所有的调色板索引</span></span><br><span class="line">DWORD biClrImportant;     <span class="comment">//4 Bytes，重要的调色板索引数，0：所有的调色板索引都重要</span></span><br><span class="line">&#125;BMP_INFOHEADER;</span><br></pre></td></tr></table></figure>

<p>变量名<br>地址偏移<br>大小<br>作用说明<br>biSize<br>000Eh<br>4Bytes<br>BNP信息头即BMP_INFOHEADER结构体所需要的字节数（以字节为单位）<br>biWidth<br>0012h<br>4Bytes<br>说明图像的宽度（以像素为单位）<br>biHeight<br>0016h<br>4Bytes<br>说明图像的高度（以像素为单位）。这个值还有一个用处，指明图像是正向的位图还是倒向的位图，该值是正数说明图像是倒向的即图像存储是由下到上；该值是负数说明图像是倒向的即图像存储是由上到下。大多数BMP位图是倒向的位图，所以此值是正值。<br>biPlanes<br>001Ah<br>2Bytes<br>为目标设备说明位面数，其值总设置为1<br>biBitCount<br>001Ch<br>2Bytes<br>说明一个像素点占几位（以比特位&#x2F;像素位单位），其值可为1,4,8,16,24或32<br>biCompression<br>001Eh<br>4Bytes<br>说明图像数据的压缩类型，取值范围为：<br>0         BI_RGB 不压缩（最常用）<br>1         BI_RLE8 8比特游程编码（BLE），只用于8位位图<br>2         BI_RLE4 4比特游程编码（BLE），只用于4位位图<br>3         BI_BITFIELDS比特域（BLE），只用于16&#x2F;32位位图<br>4<br>biSizeImage<br>0022h<br>4Bytes<br>说明图像的大小，以字节为单位。当用BI_RGB格式时，总设置为0<br>biXPelsPerMeter<br>0026h<br>4Bytes<br>说明水平分辨率，用像素&#x2F;米表示，有符号整数<br>biYPelsPerMeter<br>002Ah<br>4Bytes<br>说明垂直分辨率，用像素&#x2F;米表示，有符号整数<br>biClrUsed<br>002Eh<br>4Bytes<br>说明位图实际使用的调色板索引数，0：使用所有的调色板索引<br>biClrImportant<br>0032h<br>4Bytes<br>说明对图像显示有重要影响的颜色索引的数目，如果是0，表示都重要。</p>
<p>BMP 调色板</p>
<p>BMP调色板结构体定义如下：<br>typedef struct _tagRGBQUAD<br>{<br>BYTE  rgbBlue;       &#x2F;&#x2F;指定蓝色强度<br>BYTE  rgbGreen;      &#x2F;&#x2F;指定绿色强度<br>BYTE  rgbRed;        &#x2F;&#x2F;指定红色强度<br> BYTE  rgbReserved;  &#x2F;&#x2F;保留，设置为0<br>} RGBQUAD;</p>
<p>1，4，8位图像才会使用调色板数据，16,24,32位图像不需要调色板数据，即调色板最多只需要256项（索引0 - 255）。<br>颜色表的大小根据所使用的颜色模式而定：2色图像为8字节；16色图像位64字节；256色图像为1024字节。其中，每4字节表示一种颜色，并以B（蓝色）、G（绿色）、R（红色）、alpha（32位位图的透明度值，一般不需要）。即首先4字节表示颜色号1的颜色，接下来表示颜色号2的颜色，依此类推。<br>颜色表中RGBQUAD结构数据的个数有biBitCount来确定，当biBitCount&#x3D;1,4,8时，分别有2,16,256个表项。<br>当biBitCount&#x3D;1时，为2色图像，BMP位图中有2个数据结构RGBQUAD，一个调色板占用4字节数据，所以2色图像的调色板长度为2<em>4为8字节。<br>当biBitCount&#x3D;4时，为16色图像，BMP位图中有16个数据结构RGBQUAD，一个调色板占用4字节数据，所以16像的调色板长度为16</em>4为64字节。<br>当biBitCount&#x3D;8时，为256色图像，BMP位图中有256个数据结构RGBQUAD，一个调色板占用4字节数据，所以256色图像的调色板长度为256*4为1024字节。<br>当biBitCount&#x3D;16，24或32时，没有颜色表。</p>
<p>BMP 图像数据区</p>
<p>位图数据记录了位图的每一个像素值，记录顺序是在扫描行内是从左到右,扫描行之间是从下到上。位图的一个像素值所占的字节数:<br>当biBitCount&#x3D;1时，8个像素占1个字节;<br>当biBitCount&#x3D;4时，2个像素占1个字节;<br>当biBitCount&#x3D;8时，1个像素占1个字节;<br>当biBitCount&#x3D;24时,1个像素占3个字节;<br>Windows规定一个扫描行所占的字节数必须是4的倍数(即以long为单位),不足的以0填充，<br>一个扫描行所占的字节数计算方法:</p>
<p>235.125<br>264 * 8  &#x3D; 2112  个像素<br>33 + 31<br>57 + 31</p>
<p>DataSizePerLine&#x3D; (biWidth* biBitCount+31)&#x2F;8;<br>&#x2F;&#x2F; 一个扫描行所占的字节数<br>DataSizePerLine&#x3D; DataSizePerLine&#x2F;4<em>4; &#x2F;&#x2F; 字节数必须是4的倍数<br>位图数据的大小(不压缩情况下):<br>DataSize&#x3D; DataSizePerLine</em> biHeight;</p>
<p>颜色表接下来位为位图文件的图像数据区，在此部分记录着每点像素对应的颜色号，其记录方式也随颜色模式而定，既2色图像每点占1位（8位为1字节）；16色图像每点占4位（半字节）；256色图像每点占8位（1字节）；真彩色图像每点占24位（3字节）。所以，整个数据区的大小也会随之变化。究其规律而言，可的出如下计算公式：图像数据信息大小&#x3D;（图像宽度<em>图像高度</em>记录像素的位数）&#x2F;8。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/14/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> TeX_baitu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="TeX_baitu blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>