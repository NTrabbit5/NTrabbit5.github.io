<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> TeX_baitu blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      


<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-20220722-PowerShell管道使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/22/20220722-PowerShell%E7%AE%A1%E9%81%93%E4%BD%BF%E7%94%A8/"
    >20220722-PowerShell管道使用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/22/20220722-PowerShell%E7%AE%A1%E9%81%93%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2022-07-22T03:42:57.000Z" itemprop="datePublished">2022-07-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/powershell/module/microsoft.powershell.core/about/about_pipelines?view=powershell-7.2">https://docs.microsoft.com/zh-CN/powershell/module/microsoft.powershell.core/about/about_pipelines?view=powershell-7.2</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lavender000/p/6941393.html">https://www.cnblogs.com/lavender000/p/6941393.html</a></p>
<p>简短说明</p>
<p>在powershell 中将命令合并到管道中</p>
<p>长说明</p>
<p>管道是一系列由管道运算符连接的命令 |</p>
<p>可以发送第一个命令的输出，作为第二个命令的输入进行处理。 还可以将输出发送到另一个命令。 结果是一个复杂的命令链或 管道 ，由一系列简单的命令组成。</p>
<p>例如，</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command-1 | Command-2 | Command-3</span><br></pre></td></tr></table></figure>
<p>在此示例中，发出的对象 Command-1 将发送到 Command-2 。 Command-2 处理对象并将其发送到 Command-3 。 Command-3 处理对象并将其沿管道向下发送。 由于管道中没有更多命令，因此结果将显示在控制台上。</p>
<p>在管道中，按从左到右的顺序处理命令。 处理将作为单个操作进行处理，并在生成时显示输出。</p>
<p>下面是一个简单的示例。 以下命令将获取记事本进程，然后将其停止。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Process notepad | Stop-Process</span><br></pre></td></tr></table></figure>

<p>此管道示例获取当前目录中的文本文件，只选择长度超过10000个字节的文件，按长度对它们进行排序，并在表中显示每个文件的名称和长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get-ChildItem -Path *.txt |</span><br><span class="line">  Where-Object &#123;$_.length -gt 10000&#125; |</span><br><span class="line">    Sort-Object -Property length |</span><br><span class="line">      Format-Table -Property name, length</span><br></pre></td></tr></table></figure>

<p>此管道按指定顺序包含四个命令。 下图显示了每个命令的输出，因为它将传递到管道中的下一个命令。</p>
<p>使用管道</p>
<p>大多数powershell cmdlet 都设计为支持管道，在大多数情况下，你可以通过管道将Get cmdlet 的结果传递给相同名词的另一个cmdlet</p>
<p>例如，可以通过管道将 cmdlet 的输出 Get-Service 传递给 Start-Service 或 Stop-Service cmdlet。</p>
<p>此示例管道在计算机上启动 WMI 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Service wmi | Start-Service</span><br></pre></td></tr></table></figure>

<p>再例如，你可以通过管道将 PowerShell 注册表提供程序的输出 Get-Item Get-ChildItem 传递给 New-ItemProperty cmdlet。 此示例将值为 8124 的新注册表项 NoOfEmployees 添加到 MyCompany 注册表项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get-Item -Path HKLM:\Software\MyCompany |</span><br><span class="line">  New-ItemProperty -Name NoOfEmployees -Value 8124</span><br></pre></td></tr></table></figure>

<p>许多实用工具 cmdlet Get-Member （如、 Group-Object Where-Object Sort-Object 、、和 Measure-Object ）几乎只是在管道中使用。 可以通过管道将任何对象类型传递给这些 cmdlet。 此示例显示了如何按每个进程中打开的句柄数对计算机上的所有进程进行排序。</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Process | Sort-Object -Property handles</span><br></pre></td></tr></table></figure>
<p>可以通过管道将对象传递给格式设置、导出和输出 cmdlet，例如 Format-List 、 Format-Table Export-Clixml Export-CSV 、、和。 Out-File</p>
<p>此示例演示如何使用 Format-List cmdlet 显示进程对象的属性列表。</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Process winlogon | Format-List -Property *</span><br></pre></td></tr></table></figure>
<p>还可以通过管道将本机命令的输出传递给 PowerShell cmdlet。 例如：</p>
<p>PowerShell</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS&gt; ipconfig.exe | Select-String -Pattern &#x27;IPv4&#x27;</span><br><span class="line"></span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 172.24.80.1</span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 192.168.1.45</span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 100.64.108.37</span><br></pre></td></tr></table></figure>
<p> 重要</p>
<p>成功 和 错误 流类似于其他 shell 的 stdin 和 stderr 流。 但 stdin 未连接到 PowerShell 管道进行输入。 有关详细信息，请参阅 about_Redirection。</p>
<p>使用几个实践，你会发现将简单命令合并到管道可节省时间和键入内容，并使你的脚本更有效。</p>
<h2 id="管道的工作方式"><a href="#管道的工作方式" class="headerlink" title="管道的工作方式"></a>管道的工作方式</h2><p>本部分介绍如何将输入对象绑定到 cmdlet 参数并在管道执行期间进行处理。</p>
<h3 id="接受管道输入"><a href="#接受管道输入" class="headerlink" title="接受管道输入"></a>接受管道输入</h3><p>若要支持流水线，接收 cmdlet 必须具有接受管道输入的参数。 <code>Get-Help</code>使用带有 <strong>Full</strong> 或 <strong>Parameter</strong> 选项的命令来确定 cmdlet 接受管道输入的参数。</p>
<p>例如，若要确定 cmdlet 的哪些参数 <code>Start-Service</code> 接受管道输入，请键入：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> <span class="built_in">Start-Service</span> <span class="literal">-Full</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> <span class="built_in">Start-Service</span> <span class="literal">-Parameter</span> *</span><br></pre></td></tr></table></figure>

<p>Cmdlet 的帮助 <code>Start-Service</code> 显示：只有 <strong>InputObject</strong> 和 <strong>Name</strong> 参数接受管道输入。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-InputObject &lt;ServiceController[]&gt;</span><br><span class="line">Specifies ServiceController objects representing the services to be started.</span><br><span class="line">Enter a variable that contains the objects, or type a command or expression</span><br><span class="line">that gets the objects.</span><br><span class="line"></span><br><span class="line">Required?                    true</span><br><span class="line">Position?                    0</span><br><span class="line">Default value                None</span><br><span class="line">Accept pipeline input?       True (ByValue)</span><br><span class="line">Accept wildcard characters?  false</span><br><span class="line"></span><br><span class="line">-Name &lt;String[]&gt;</span><br><span class="line">Specifies the service names for the service to be started.</span><br><span class="line"></span><br><span class="line">The parameter name is optional. You can use Name or its alias, ServiceName,</span><br><span class="line">or you can omit the parameter name.</span><br><span class="line"></span><br><span class="line">Required?                    true</span><br><span class="line">Position?                    0</span><br><span class="line">Default value                None</span><br><span class="line">Accept pipeline input?       True (ByPropertyName, ByValue)</span><br><span class="line">Accept wildcard characters?  false</span><br></pre></td></tr></table></figure>

<p>当你通过管道将对象发送到 <code>Start-Service</code> 时，PowerShell 会尝试将对象与 <strong>InputObject</strong> 和 <strong>Name</strong> 参数相关联。</p>
<h3 id="接受管道输入的方法"><a href="#接受管道输入的方法" class="headerlink" title="接受管道输入的方法"></a>接受管道输入的方法</h3><p>Cmdlet 参数可采用以下两种不同方式之一接受管道输入：</p>
<ul>
<li><p><strong>ByValue</strong>：参数接受与所需的 .net 类型匹配或可转换为该类型的值。</p>
<p>例如，的 <strong>Name</strong> 参数 <code>Start-Service</code> 接受按值的管道输入。 它可以接受可以转换为字符串的字符串对象或对象。</p>
</li>
<li><p><strong>ByPropertyName</strong>：仅当输入对象具有与参数名称相同的属性时，此参数才接受输入。</p>
<p>例如，的 <code>Start-Service</code> name 参数可以接受具有 <strong>Name</strong> 属性的对象。 若要列出某个对象的属性，请将其传递到 <code>Get-Member</code> 。</p>
</li>
</ul>
<p>一些参数可以通过值或属性名称接受对象，使从管道中获取输入变得更加容易。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>当你通过管道将对象从一个命令传递给另一个命令时，PowerShell 会尝试将管道对象与接收 cmdlet 的参数相关联。</p>
<p>PowerShell 的参数绑定组件根据以下条件将输入对象与 cmdlet 参数关联：</p>
<ul>
<li>参数必须接受来自管道的输入。</li>
<li>参数必须接受要发送的对象的类型或可转换为预期类型的类型。</li>
<li>命令中未使用参数。</li>
</ul>
<p>例如， <code>Start-Service</code> cmdlet 具有多个参数，但其中只有两个参数、 <strong>名称</strong> 和 <strong>InputObject</strong> 接受管道输入。 <strong>Name</strong> 参数使用字符串， <strong>InputObject</strong> 参数使用服务对象。 因此，可以通过管道字符串、服务对象和具有可转换为字符串或服务对象的属性的对象。</p>
<p>PowerShell 会尽可能有效地管理参数绑定。 不能建议或强制 PowerShell 绑定到特定参数。 如果 PowerShell 无法绑定管道对象，则该命令将失败。</p>
<p>有关排除绑定错误的详细信息，请参阅本文后面的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/powershell/module/microsoft.powershell.core/about/about_pipelines?view=powershell-7.2#investigating-pipeline-errors">调查管道错误</a> 。</p>
<h3 id="一次一次性处理"><a href="#一次一次性处理" class="headerlink" title="一次一次性处理"></a>一次一次性处理</h3><p>通过管道将对象传递给命令与使用命令的参数来提交对象非常类似。 让我们看一看管道示例。 在此示例中，我们使用管道来显示服务对象表。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Service</span> | <span class="built_in">Format-Table</span> <span class="literal">-Property</span> Name, DependentServices</span><br></pre></td></tr></table></figure>

<p>在功能上，这与使用的 <strong>InputObject</strong> 参数 <code>Format-Table</code> 来提交对象集合类似。</p>
<p>例如，我们可以将服务集合保存到使用 <strong>InputObject</strong> 参数传递的变量。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$services</span> = <span class="built_in">Get-Service</span></span><br><span class="line"><span class="built_in">Format-Table</span> <span class="literal">-InputObject</span> <span class="variable">$services</span> <span class="literal">-Property</span> Name, DependentServices</span><br></pre></td></tr></table></figure>

<p>或者，可以将该命令嵌入到 <strong>InputObject</strong> 参数中。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Format-Table</span> <span class="literal">-InputObject</span> (<span class="built_in">Get-Service</span>) <span class="literal">-Property</span> Name, DependentServices</span><br></pre></td></tr></table></figure>

<p>但有一个重要的差异。 通过管道将多个对象传递给命令时，PowerShell 会一次将对象发送到命令。 使用命令参数时，对象将作为单个数组对象发送。 这种次要差别会产生重大后果。</p>
<p>执行管道时，PowerShell 会自动枚举任何实现 <code>IEnumerable</code> 接口的类型，并一次通过管道发送成员。 异常是 <code>[hashtable]</code> ，这需要调用 <code>GetEnumerator()</code> 方法。</p>
<p>在下面的示例中，将向 <code>Measure-Object</code> cmdlet 传递一个数组和一个哈希表，以计算从管道接收的对象数。 该数组具有多个成员，并且哈希表具有多个键值对。 一次只枚举一个数组。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">@</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) | <span class="built_in">Measure-Object</span></span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Count    : 3</span><br><span class="line">Average  :</span><br><span class="line">Sum      :</span><br><span class="line">Maximum  :</span><br><span class="line">Minimum  :</span><br><span class="line">Property :</span><br></pre></td></tr></table></figure>

<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">@</span>&#123;<span class="string">&quot;One&quot;</span>=<span class="number">1</span>;<span class="string">&quot;Two&quot;</span>=<span class="number">2</span>&#125; | <span class="built_in">Measure-Object</span></span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Count    : 1</span><br><span class="line">Average  :</span><br><span class="line">Sum      :</span><br><span class="line">Maximum  :</span><br><span class="line">Minimum  :</span><br><span class="line">Property :</span><br></pre></td></tr></table></figure>

<p>同样，如果你通过 <code>Get-Process</code> 管道将多个进程对象传递给 <code>Get-Member</code> cmdlet，则 PowerShell 会将每个进程对象一次发送到 <code>Get-Member</code> 。 <code>Get-Member</code> 显示 (类型的 .NET 类) 进程对象及其属性和方法。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Get-Member</span></span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TypeName: System.Diagnostics.Process</span><br><span class="line"></span><br><span class="line">Name      MemberType     Definition</span><br><span class="line">----      ----------     ----------</span><br><span class="line">Handles   AliasProperty  Handles = Handlecount</span><br><span class="line">Name      AliasProperty  Name = ProcessName</span><br><span class="line">NPM       AliasProperty  NPM = NonpagedSystemMemorySize</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p> 备注</p>
<p><code>Get-Member</code> 消除重复项，因此，如果所有对象都属于同一类型，则它只显示一种对象类型。</p>
<p>但是，如果使用的 <strong>InputObject</strong> 参数 <code>Get-Member</code> ，则 <code>Get-Member</code> 会将 <strong>system.object</strong> 对象的数组作为单个单元接收。 它显示对象数组的属性。 (记下 array 符号 (<code>[]</code> 在 <strong>system.object</strong> 类型名称后面) 。 )</p>
<p>例如，</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Member</span> <span class="literal">-InputObject</span> (<span class="built_in">Get-Process</span>)</span><br></pre></td></tr></table></figure>

<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TypeName: System.Object[]</span><br><span class="line"></span><br><span class="line">Name               MemberType    Definition</span><br><span class="line">----               ----------    ----------</span><br><span class="line">Count              AliasProperty Count = Length</span><br><span class="line">Address            Method        System.Object&amp; Address(Int32 )</span><br><span class="line">Clone              Method        System.Object Clone()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此结果可能不是你所期望的结果。 但在理解后，就可以使用它了。 例如，所有数组对象都具有 <strong>Count</strong> 属性。 可以使用它来计算计算机上运行的进程数。</p>
<p>例如，</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Get-Process</span>).count</span><br></pre></td></tr></table></figure>

<p>请务必记住，在管道中发送的对象每次传递一次。</p>
<h2 id="在管道中使用本机命令"><a href="#在管道中使用本机命令" class="headerlink" title="在管道中使用本机命令"></a>在管道中使用本机命令</h2><p>PowerShell 允许在管道中包含本机外部命令。 但是，请务必注意，PowerShell 的管道是面向对象的，不支持原始字节数据。</p>
<p>从输出原始字节数据的本机程序对输出进行管道或重定向会将输出转换为 .NET 字符串。 这种转换可能会导致原始数据输出损坏。</p>
<p>作为一种解决方法，使用 <code>cmd.exe /c</code> 或 <code>sh -c</code> 调用本机命令，并使用 <code>|</code> 本机 shell 提供的和 <code>&gt;</code> 运算符。</p>
<h2 id="调查管道错误"><a href="#调查管道错误" class="headerlink" title="调查管道错误"></a>调查管道错误</h2><p>当 PowerShell 无法将管道对象与接收 cmdlet 的参数关联时，该命令将失败。</p>
<p>在下面的示例中，我们尝试将注册表项从一个注册表项移到另一个注册表项。 该 <code>Get-Item</code> cmdlet 将获取目标路径，然后将该路径传递给 <code>Move-ItemProperty</code> cmdlet。 <code>Move-ItemProperty</code>命令指定要移动的注册表项的当前路径和名称。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\sales |</span><br><span class="line"><span class="built_in">Move-ItemProperty</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\design <span class="literal">-Name</span> product</span><br></pre></td></tr></table></figure>

<p>命令失败，PowerShell 将显示以下错误消息：</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Move-ItemProperty : The input object can&#x27;t be bound to any parameters for</span><br><span class="line">the command either because the command doesn&#x27;t take pipeline input or the</span><br><span class="line">input and its properties do not match any of the parameters that take</span><br><span class="line">pipeline input.</span><br><span class="line">At line:1 char:23</span><br><span class="line">+ $a | Move-ItemProperty &lt;&lt;&lt;&lt;  -Path HKLM:\Software\MyCompany\design -Name p</span><br></pre></td></tr></table></figure>

<p>若要进行调查，请使用 <code>Trace-Command</code> cmdlet 跟踪 PowerShell 的参数绑定组件。 下面的示例跟踪管道的执行过程中的参数绑定。 <strong>PSHost</strong> 参数将跟踪结果显示在控制台中， <strong>FilePath</strong> 参数会将跟踪结果发送到 <code>debug.txt</code> 文件，供以后参考。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Trace-Command</span> <span class="literal">-Name</span> ParameterBinding <span class="literal">-PSHost</span> <span class="literal">-FilePath</span> debug.txt <span class="literal">-Expression</span> &#123;</span><br><span class="line">  <span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\sales |</span><br><span class="line">    <span class="built_in">Move-ItemProperty</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\design <span class="literal">-Name</span> product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪的结果很长，但会显示绑定到 <code>Get-Item</code> cmdlet 的值，然后显示绑定到 <code>Move-ItemProperty</code> cmdlet 的命名值。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">BIND NAMED cmd line args [`Move-ItemProperty`]</span><br><span class="line">BIND arg [HKLM:\Software\MyCompany\design] to parameter [Path]</span><br><span class="line">...</span><br><span class="line">BIND arg [product] to parameter [Name]</span><br><span class="line">...</span><br><span class="line">BIND POSITIONAL cmd line args [`Move-ItemProperty`]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，它显示尝试将路径绑定到的 <code>Move-ItemProperty</code> <strong>目标</strong> 参数失败。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">BIND PIPELINE object to parameters: [`Move-ItemProperty`]</span><br><span class="line">PIPELINE object TYPE = [Microsoft.Win32.RegistryKey]</span><br><span class="line">RESTORING pipeline parameter&#x27;s original values</span><br><span class="line">Parameter [Destination] PIPELINE INPUT ValueFromPipelineByPropertyName NO</span><br><span class="line">COERCION</span><br><span class="line">Parameter [Credential] PIPELINE INPUT ValueFromPipelineByPropertyName NO</span><br><span class="line">COERCION</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>Get-Help</code>使用 cmdlet 查看 <strong>目标</strong> 参数的属性。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Get-Help Move-ItemProperty -Parameter Destination</span><br><span class="line"></span><br><span class="line">-Destination &lt;String&gt;</span><br><span class="line">    Specifies the path to the destination location.</span><br><span class="line"></span><br><span class="line">    Required?                    true</span><br><span class="line">    Position?                    1</span><br><span class="line">    Default value                None</span><br><span class="line">    Accept pipeline input?       True (ByPropertyName)</span><br><span class="line">    Accept wildcard characters?  false</span><br></pre></td></tr></table></figure>

<p>结果显示 <strong>目标</strong> 仅按属性名称获取管道输入。 因此，管道对象必须具有一个名为 “ <strong>Destination</strong>“ 的属性。</p>
<p>使用 <code>Get-Member</code> 可查看来自的对象 <code>Get-Item</code> 的属性。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\sales | <span class="built_in">Get-Member</span></span><br></pre></td></tr></table></figure>

<p>输出显示该项目是没有 <strong>目标</strong> 属性的 <strong>Microsoft. Win32</strong> 对象。 这说明了命令失败的原因。</p>
<p><strong>Path</strong> 参数按名称或值接受管道输入。</p>
<p>Output复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Get-Help Move-ItemProperty -Parameter Path</span><br><span class="line"></span><br><span class="line">-Path &lt;String[]&gt;</span><br><span class="line">    Specifies the path to the current location of the property. Wildcard</span><br><span class="line">    characters are permitted.</span><br><span class="line"></span><br><span class="line">    Required?                    true</span><br><span class="line">    Position?                    0</span><br><span class="line">    Default value                None</span><br><span class="line">    Accept pipeline input?       True (ByPropertyName, ByValue)</span><br><span class="line">    Accept wildcard characters?  true</span><br></pre></td></tr></table></figure>

<p>若要修复此命令，必须在 cmdlet 中 <code>Move-ItemProperty</code> 指定目标，并使用 <code>Get-Item</code> 获取要移动的项的 <strong>路径</strong> 。</p>
<p>例如，</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Item</span> <span class="literal">-Path</span> HKLM:\Software\MyCompany\design |</span><br><span class="line"><span class="built_in">Move-ItemProperty</span> <span class="literal">-Destination</span> HKLM:\Software\MyCompany\sales <span class="literal">-Name</span> product</span><br></pre></td></tr></table></figure>

<h2 id="内部续行符"><a href="#内部续行符" class="headerlink" title="内部续行符"></a>内部续行符</h2><p>正如前面所讨论的，管道是一系列由管道运算符连接的命令 (<code>|</code>) ，通常在一行上写入。 但是，为了提高可读性，PowerShell 允许跨多个行拆分管道。 当管道运算符是行上的最后一个标记时，PowerShell 分析器会将下一行连接到当前命令以继续构造管道。</p>
<p>例如，以下单行管道：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command<span class="literal">-1</span> | Command<span class="literal">-2</span> | Command<span class="literal">-3</span></span><br></pre></td></tr></table></figure>

<p>可以编写为：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Command<span class="literal">-1</span> |</span><br><span class="line">  Command<span class="literal">-2</span> |</span><br><span class="line">    Command<span class="literal">-3</span></span><br></pre></td></tr></table></figure>

<p>后续行中的前导空格并不重要。 缩进增强了可读性。</p>
<p>PowerShell 7 增加了对管道的延续的支持，并在行的开头提供管道字符。 下面的示例演示如何使用此新功能。</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wrapping with a pipe at the beginning of a line (no backtick required)</span></span><br><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> CPU | <span class="built_in">Where-Object</span> Path</span><br><span class="line">    | <span class="built_in">Get-Item</span> | <span class="built_in">Where-Object</span> FullName <span class="operator">-match</span> <span class="string">&quot;AppData&quot;</span></span><br><span class="line">    | <span class="built_in">Sort-Object</span> FullName <span class="literal">-Unique</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wrapping with a pipe on a line by itself</span></span><br><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> CPU | <span class="built_in">Where-Object</span> Path</span><br><span class="line">    |</span><br><span class="line">    <span class="built_in">Get-Item</span> | <span class="built_in">Where-Object</span> FullName <span class="operator">-match</span> <span class="string">&quot;AppData&quot;</span></span><br><span class="line">    |</span><br><span class="line">    <span class="built_in">Sort-Object</span> FullName <span class="literal">-Unique</span></span><br></pre></td></tr></table></figure>

<p> 重要</p>
<p>在 shell 中以交互方式工作时，仅当使用Ctrl + V粘贴时，才将代码粘贴到行的开头。 右键单击 “粘贴操作”，一次插入一个行。 因为行不以管道字符结尾，所以 PowerShell 会将输入视为已完成，并按输入执行该行。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220716-ranger插件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/16/20220716-ranger%E6%8F%92%E4%BB%B6/"
    >20220716-ranger插件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/16/20220716-ranger%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2022-07-16T07:13:42.000Z" itemprop="datePublished">2022-07-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>http%3A&#x2F;&#x2F;ranger.github.io&#x2F;</p>
<p>ranger 是一个终端文件管理器，通过ranger 可以实现和windows 中类似的资源管理器的展示功能</p>
<p>ranger 分为三个部分</p>
<p>左边为上级目录结构</p>
<p>中间为当前可以操作的目录</p>
<p>右边为当前目录下面所有的文件</p>
<p>最底端的状态栏显示的是当前选中文件的一些文件信息，比如执行权限和上次修改的时间</p>
<p>安装 sudo apt-get install ranger</p>
<p>进入之后就可以使用 vim 的相关命令了，比如 hjkl 上下左右的操作 、:q 推出 等。</p>
<p>常用命令组合</p>
<p>除了最基本的 vim 操作的常用快捷键不在进行介绍之后，以下为常用的快捷键介绍。</p>
<p>S 使用终端定位到当前所在目录<br>H 后退<br>cw 重命名</p>
<p>on&#x2F;ob 根据文件名进行排序，<br>oc 根据改变时间进行排序<br>os 根据文件大小进行排序<br>ot 根据后缀名进行排序<br>oa 根据访问时间进行排序<br>om 根据修改进行排序</p>
<p>utf-8 支持</p>
<p>多栏显示<br>所选文件 目录的预览</p>
<p>常用文件操作票</p>
<p>类似vim 的控制台和热键</p>
<p>一次重命名多个文件<br>自动确定文件类型并使用正确的程序运行它们<br>退出 ranger 后更改 shell 目录<br>标签、书签、鼠标支持<br>真彩色图像预览 [如何启用]<br>视频缩略图 [如何启用]<br>依赖项<br>Python（测试版本为 2.7、3.1、3.2、3.3、3.4），支持 ncurses 和（可选）宽 unicode。<br>寻呼机（默认为less ）<br>可选的：</p>
<p>用于确定文件类型的文件<br>python 模块chardet，以防编码检测问题<br>“sudo”以使用“以 root 身份运行”功能<br>w3m用于以“真彩色”预览图像。<br>可选，用于增强文件预览（使用“scope.sh”）：</p>
<p>img2txt（来自caca-utils）用于预览ASCII-art中的图像<br>highlight用于代码的语法高亮<br>用于预览档案的工具<br>lynx、w3m或elinks用于预览 html 页面<br>pdftotext 用于 pdf 预览<br>传输显示查看比特种子信息<br>mediainfo或 exiftool 用于查看有关媒体文件的信息</p>
<p>ranger wiki <a target="_blank" rel="noopener" href="https://github.com/ranger/ranger/wiki">https://github.com/ranger/ranger/wiki</a></p>
<p>配置文件<br>将默认配置文件复制到该文件~&#x2F;.config&#x2F;range<br>$ ranger –copy-config&#x3D;all<br>1<br>ranger 使用4个主要配置文件：<br>文件名 描述<br>commands.py 包含以Python编写的各种函数的实现，用于修改ranger’s行为<br>rc.conf 用于设置各种选项并将按键绑定到功能<br>rifle.conf  决定使用哪个程序打开哪个文件<br>scope.sh  是一个shell脚本，用于生成各种文件类型的预览<br>宏指令<br>宏指令可以用在 command 命令中达到缩写命令的目的。</p>
<p>宏指令 功能<br>%f  高亮显示的文件<br>%d  当前文件夹的路径<br>%s  当前文件夹选择的文件<br>%t  当前文件夹所有标记的文件<br>%c  当前复制&#x2F;剪切文件的完整路径<br>%p  选择文件的完整路径<br>宏指令 %f、%d、%p 和 %s 有大写的变体，%F、%D、%P 和 %S，指下一个标记。为了表示一个特定的标记，可以在 % 和 字母 中间加一个数字，比如 %7s 指当前文件夹中第七个所选择的文件。<br>  %c 是唯一一个作用于当前文件夹以外的宏指令，所以你可以通过复制功能达到其他的目的。比如比较在两个在不同文件夹里的文件的不同：复制文件 A（键入 yy），然后切换到文件 B 的目录，并标记文件 B（键入 SPACE），最后键入 @，输入 shell: diff %c %s。对于文件路径的宏命令（%d、%c 和 %p）通常是转义了的，所以可以直接在 shell command 命令中使用。<br>  此外，如果你创建了使用 Key 的按键绑定，那么宏命令 %Key（或者 %Key0、%Key1、……)在 shell command 中就代表按下 Key 键几次。</p>
<p>文件选择<br>标记&#x2F;取消标记：space<br>反选：v<br>视觉模式开启&#x2F;关闭：V，在视觉模式下，移动光标即可选择条目。也可以按 uV或者 ESC 退出。<br>取消当前目录的全部标记：uv</p>
<p>黄色的 Mrk 符号位于终端右下角，表示此文件夹里有标记的文件。黄色的 Mrk 并不会因为切换目录而消失。</p>
<p>文件操作<br>复制：yy<br>剪切：dd<br>粘贴：pp<br>删除：dD</p>
<p>将不同目录的文件加入操作列表：ya<br>重命名：cw<br>在当前名称基础上重命名：A<br>类似A, 但是光标会跳到起始位置：I<br>向下翻一页：Ctrl+f或PAGEDOWN<br>向上翻一页：Ctrl+b或PAGEUP<br>向上翻半页：Ctrl+u或者K<br>向下翻半页：Ctrl+d或者 J<br>后退到上一个历史记录：H<br>前进到下一个历史记录：L</p>
<p>目录跳转<br>父目录上移：[<br>父目录下移：]<br>如果当前选中高亮的是是链接目录，直接跳到原目录内：g L<br>如果当前目录是链接目录内，直接跳到原目录：g l<br>跳转目录：g+其他</p>
<p>查看与编辑文件<br>操作  说明<br>i 或者 F3 调用 Pager 查看文件 与在终端中输入 pager + 文件名 一样。<br>E 或者 F4 调用默认编辑器编辑文件 可在终端中输入 select-editor 选择默认编辑器。<br>书签<br>新建书签：m<br>打开书签：&#96;<br>删除书签：um</p>
<p>标签<br>多标签即多窗口工作。可以在每个窗口来回切换。</p>
<p>新建标签：</p>
<p>g n<br>Ctrl+n<br>切换标签：</p>
<p>g t或g T<br>Tab 或 Shift+Tab<br>Alt+标签名<br>关闭标签：g c 或 Ctrl+w</p>
<p>链接<br>粘贴绝对路径的链接：pl<br>粘贴相对路径的链接：pL<br>硬链接：phl</p>
<p>排序<br>排序：o</p>
<p>名词  描述<br>atime access time，访问时间<br>basename  基于文件名<br>ctime change time，改变时间，文件的权限组别和文件自身数据被修改的时间<br>extension 扩展名<br>mtime modified time，修改时间<br>任务管理<br>在执行某些操作(比如复制一个大文件)时不能立即完成, 这在 ranger 中就是一个任务. 你可以停止, 启动某个任务, 也可以对某个任务设置优先级.</p>
<p>打开&#x2F;关闭任务视图：w<br>在打开的任务视图中：<br>终止一个任务：dd<br>降低当前任务的优先级：J<br>提升当前任务的优先级：K<br>预览<br>默认情况下，只能预览文本文件，但是你可以通过设定配置 use_preview_script 和 preview_files 为 true 来增加可以预览的文件类型。默认的预览脚本是 ~&#x2F;.config&#x2F;ranger&#x2F;scope.sh，安装如下工具（每种类型只需要一个）就预览对应的文件类型，scope.sh 会自动调用它们：</p>
<p>工具  预览文件类型  安装<br>lynx<br>elinks<br>w3m 网页  sudo apt install lynx<br>sudo apt install elinks<br>sudo apt install w3m<br>highlight<br>pygmentize  高亮代码  sudo apt install highlight<br>pip install pygmentize<br>img2txt 图片  sudo apt install caca-utils<br>atool<br>bsdtar<br>unrar<br>7z  压缩包 sudo apt install atool<br>sudo apt install libarchive-tools<br>sudo apt install unrar<br>sudo apt install p7zip<br>pdftotext<br>mutool  PDF sudo apt install poppler-utils<br>sudo apt install mupdf-tools<br>mediainfo<br>exiftool  媒体  sudo apt install mediainfo<br>sudo apt install libimage-exiftool-perl<br>ffmpegthumbnailer 视频缩略图 sudo apt install ffmpegthumbnailer<br>fontimage 字体  sudo apt install fontforge<br>transmission-show 种子  sudo apt install transmission-cli<br>独立于 preview script，有一个通过将图像用字符画的形式直接绘制到终端中的预览功能。要启用此功能，将 preview_images 选项设置为 true 并将 preview_images_method 选项设置为一种图像预览模式（需要安装这些工具）：</p>
<p>预览模式  是否适用于 ssh 注意  设置 preview_images_method 为<br>w3m 否 与 tmux 不兼容（尽管它可以工作）。  w3m<br>iTerm2  是 iTerm2 编译时必须添加 image preview support 选项。  iterm2<br>urxvt 否 urxvt 编译时必须添加 pixbuf support 选项。此模式本质上是将图像暂时设置为终端背景，这样它将破坏以前设置的任何图像背景。  urxvt<br>urxvt-full  否 与 urxvt 相同，但使用整个终端窗口预览图片。 urxvt-full<br>获取帮助<br>按下?时获取帮助，再使用按键选择帮助类型：</p>
<p>m: opens the man page for ranger（打开官方man手册）<br>k: opens a list of keybindings（打开按键绑定列表）<br>c: opens a list of available commands and descriptions（打开命令列表）<br>s: opens a list of settings and their current values（打开设置列表）<br>官方man手册网站：<a target="_blank" rel="noopener" href="https://ranger.github.io/ranger.1.html">https://ranger.github.io/ranger.1.html</a></p>
<p>其他<br>查找：f<br>搜索：&#x2F;<br>修改设置：z<br>显示隐藏文件：zh<br>打开&#x2F;关闭文件预览功能：zp<br>打开目录预览功能：zP<br>过滤器(如过滤pdf文件, zf+pdf,回车)：zf<br>在当前目录打开终端：S<br>目录展平：:flag (level)<br>批量重命名：标记选中后，输入:bulkrename</p>
<p>参考<br>官方用户指南<br><a target="_blank" rel="noopener" href="http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html">http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html</a><br>博客链接【推荐】<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xkfz008/article/details/7339530">https://blog.csdn.net/xkfz008/article/details/7339530</a></p>
<p>安装插件<br>ranger也有很多预览时用的插件 :</p>
<p>sudo apt-get install caca-utils # img2txt 图片<br>sudo apt-get install highlight  # 代码高亮<br>sudo apt-get install atool　    # 存档预览<br>sudo apt-get install w3m        # html页面预览<br>sudo apt-get install mediainfo  # 多媒体文件预览<br>1<br>2<br>3<br>4<br>5<br>当然还有其他文件格式的预览</p>
<p>sudo apt-get install catdoc     # doc预览<br>sudo apt-get install docx2txt   # docx预览<br>sudo apt-get install xlsx2csv   # xlsx预览<br>1<br>2<br>3<br>其他 :<br>zh&#x2F;退回键    显示隐藏文件</p>
<p>zp        打开&#x2F;关闭文件预览功能<br>zP        打开目录预览功能<br>1<br>2<br>3<br>4<br>当然ranger也是直接支持终端的基本命令的, 比如可以直接使用cd.</p>
<p>其次也支持其他方便操作的快捷方式. 如 : g可以快速的通过按键进入指定的目录中. 还有d等操作</p>
<p>最后, ranger还是直接支持鼠标点击.</p>
<p>参考 :<br>Ranger<br><a target="_blank" rel="noopener" href="http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html">http://www.mikewootc.com/wiki/linux/usage/ranger_file_manager.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220713-电子书管理工作流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/13/20220713-%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81/"
    >20220713-电子书管理工作流</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/13/20220713-%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81/" class="article-date">
  <time datetime="2022-07-12T23:58:42.000Z" itemprop="datePublished">2022-07-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>基于zotero+zotfile+syncthing+ReadEra，实现电脑+手机两端同步的电子书管理流程</p>
<p>视频大纲：<a target="_blank" rel="noopener" href="https://logseq.fishyer.com/#/page/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81">https://logseq.fishyer.com/#/page/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81</a></p>
<p>更多工具推荐，欢迎查看 <a target="_blank" rel="noopener" href="https://logseq.fishyer.com/">https://logseq.fishyer.com</a></p>
<p>public:true<br>1-用Zlibrary下载书，或者是其他网络渠道，比如百度网盘、阿里网盘、淘宝<br>2-导入到Zotero里面<br>安装Zotfile插件，配置附件路径为Dropbox网盘下的路径<br>3-配置Syncthing，同步书籍文件夹到Android手机上<br>电脑-Windows<br>C:\Users\Administrator\Dropbox\MyObsidian\MyAttachment\MyZotoreFile<br>手机-Android<br>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;MyObsidian<br>主要就是同步MyObsidian文件夹，下面的子文件夹自然就同步了<br>其实Mac电脑也支持，不过ios手机的话就稍稍麻烦一点<br>4-阅读方式<br>PDF就在电脑上用Zotero本身看<br>很方便截图标注<br>epub等其他格式，就直接在Android手机上ReadEra看<br>其实也可以用Calibre将其他类型转换为PDF，但是我现在的主力阅读器是手机，所以就不转PDF了<br>作用<br>Zotero-书架，添加标签和添加分类等<br>ReadEra-阅读器，方便随时随地看书</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220713-计算机定时启动程序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/13/20220713-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/"
    >20220713-计算机定时启动程序</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/13/20220713-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/" class="article-date">
  <time datetime="2022-07-12T23:56:32.000Z" itemprop="datePublished">2022-07-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>首先，shutdown.exe 的参数 -h 是睡眠。其次，在windows10的控制面板-管理工具-任务计划程序（当然，你从其他路径进去也一样）</p>
<ol>
<li><p>打开任务计划程序，在操作里选择创建基本任务。</p>
</li>
<li><p>第一步页面是让你写个你的任务名称，这个随意。</p>
</li>
<li><p>点下一步后会来到触发器页面，在这里你选每天。</p>
</li>
<li><p>继续下一步会来到每日页面，在这里设置一个开始的时间，然后间隔是一天。</p>
</li>
<li><p>再下一步会来到操作页面，选择启动程序。</p>
</li>
<li><p>再再下一步会来到完成页面，程序填shutdown.exe，然后添加参数（可选）里填 -h </p>
</li>
<li><p>完成。</p>
</li>
</ol>
<p>到时间电脑就会睡眠了，然后再开机后你会发现电脑之前打开的页面都还原封不动在。你可以先测试下。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220609-python-yield-use"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/09/20220609-python-yield-use/"
    >python中的yield用法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/09/20220609-python-yield-use/" class="article-date">
  <time datetime="2022-06-09T10:51:32.000Z" itemprop="datePublished">2022-06-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>yield 关键字做了什么</p>
<p>可以先把yield 当作return 的同胞兄弟来看</p>
<p>有return的函数直接返回所有结果，程序终止不再运行，并销毁局部变量</p>
<p>而有yield 的函数则返回一个可迭代的generator 生成器对象，你可以使用for 循环或者调用next 方法遍历生成器对象来提取结果</p>
<p>在python中，使用了yield 的函数被称为生成器，有点套娃的感觉</p>
<p>调用一个yield ，就会返回一个生成器对象</p>
<p>在调用生成器函数的过程中，每次遇到yield 时函数会暂停并保存当前所有的运行信息，保留局部变量，返回yield 的值，并在下一次执行next 方法时从当前位置继续运行，直到生成器全部遍历完</p>
<p>可以看到，simple——generator 函数返回一个生成器，调用next 方法后，函数开始运行，遇到第一个yield 关键字，返回生成的值 1 ，程序暂停</p>
<p>带yield 的函数是一个生成器，这个生成器有一个方法就是next next 就相当于 下一步 生成那个数，这一次的next 开始的地方是接着上一次的next 停止的地方执行的</p>
<p>所以调用next 的时候，生成器并不会从函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield 后，return 出要生成的数，此步就结束</p>
<p>生成器有哪些作用，如果想具体化数据的形式，他唱会将数据存储在一个列表中，但这样做，列表的内容将占用有形内存，列表越大，占用的内存资源就越多</p>
<p>但是，如果数据集有某种逻辑，就不必存储在一个列表中，只需编写一个生成器，它将在需要时生成这些值，基本不占用内存</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220519-sublime修改光标颜色"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/19/20220519-sublime%E4%BF%AE%E6%94%B9%E5%85%89%E6%A0%87%E9%A2%9C%E8%89%B2/"
    >20220519-sublime修改光标颜色</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/19/20220519-sublime%E4%BF%AE%E6%94%B9%E5%85%89%E6%A0%87%E9%A2%9C%E8%89%B2/" class="article-date">
  <time datetime="2022-05-19T07:52:40.000Z" itemprop="datePublished">2022-05-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Boxy Ocean.tmTheme</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;#F07178&lt;/string&gt;</span><br><span class="line">&lt;key&gt;foreground&lt;/key&gt;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220512-工业软件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/12/20220512-%E5%B7%A5%E4%B8%9A%E8%BD%AF%E4%BB%B6/"
    >工业软件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/12/20220512-%E5%B7%A5%E4%B8%9A%E8%BD%AF%E4%BB%B6/" class="article-date">
  <time datetime="2022-05-12T13:49:03.000Z" itemprop="datePublished">2022-05-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/medialist/play/196986312?from=space&amp;business=space&amp;sort_field=play&amp;spm_id_from=333.999.0.0">https://www.bilibili.com/medialist/play/196986312?from=space&amp;business=space&amp;sort_field=play&amp;spm_id_from=333.999.0.0</a></p>
<p>[TOC]</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220512-chorme插件安装"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/12/20220512-chorme%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
    >chorme插件安装</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/12/20220512-chorme%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2022-05-12T13:29:10.000Z" itemprop="datePublished">2022-05-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>chrome一直是老Y使用的浏览器，它简洁、扩展插件丰富，用户体验应该是目前最好的浏览器了。</p>
<p>但由于众所周知的原因，国内上不了google，所以虽然chrome插件丰富，但获取一直是一个比较麻烦的事情。</p>
<p>目前国内也有许多网站，他们都是通过爬取谷歌官方插件提供给国内用户直接下载。</p>
<p>今天老Y就总结了下5大网站，可以方便快捷的获取chrome的插件：</p>
<ol>
<li>gugeapps</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www.gugeapps.net/">http://www.gugeapps.net</a></p>
<p>这个网站，老Y在以前的文章中推荐过，种类很全，更新快速，几乎就是谷歌商店的国内版。</p>
<ol start="2">
<li>扩展迷</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://extfans.com/">http://extfans.com</a></p>
<p>资源丰富，同时还提供了日榜单、周榜单、月榜单和总榜单等数据排行，帮助大家发现最新有趣的插件。另外，注意截图中红色部分，看我发现了什么？</p>
<ol start="3">
<li>Chrome插件网</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://chromecj.com/">http://chromecj.com</a></p>
<p>更新速度非常快，而且还提供了许多非常有用的教程文章，比如：五种百度云盘下载速度慢解决方法……</p>
<ol start="4">
<li>插件网</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www.cnplugins.com/">http://www.cnplugins.com</a></p>
<p>老牌的chrome插件搬运网站，提供了插件分类、插件推荐、插件百科、插件排行等四大板块，里面也有许多非常有意思的总结性文章，比如：chrome比价插件哪个更好用？亲自测试使用总结 Chrome插件。</p>
<ol start="5">
<li>我爱chrome插件网</li>
</ol>
<p>有是一个非常棒的chrome插件下载网站，提供64位离线版下载服务，直接点击即可下载！</p>
<p>另外，老Y将自己收集了多年的网站（大概有几千个），如下图所示做成了书签。下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://ilaoygzs.lanzoux.com/iznOcirahkh">https://ilaoygzs.lanzoux.com/iznOcirahkh</a> 密码:eri3</p>
<h2 id="插件安装方法"><a href="#插件安装方法" class="headerlink" title="插件安装方法"></a>插件安装方法</h2><p>后缀改为zip 解压</p>
<p>之后加载即可</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220509-《有人》"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/09/20220509-%E3%80%8A%E6%9C%89%E4%BA%BA%E3%80%8B/"
    >《有人》</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/09/20220509-%E3%80%8A%E6%9C%89%E4%BA%BA%E3%80%8B/" class="article-date">
  <time datetime="2022-05-09T10:37:18.000Z" itemprop="datePublished">2022-05-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>《有人》是由赵钶、武宇龙作词，赵钶作曲并演唱的一首歌曲，发行于2018年8月5日。</p>
<p>填词：赵钶，武宇龙 </p>
<p>编曲：赵钶 </p>
<p>制作人：关天天</p>
<p>有人浪迹江湖，有人寒窗苦读。</p>
<p>有人阿谀奉承，有人早已麻木。</p>
<p>有人嫌贫爱富，有人唯利是图。</p>
<p>有人精打细算，有人满不在乎。</p>
<p>他们，竖起了耳朵猜喜怒，咧开了笑脸躲城府。</p>
<p>不过想在平凡世界里找宝物，才会哭着笑着装糊涂。</p>
<p>有人家财万贯却还失声痛哭。</p>
<p>有人身无分文却也活的舒服。</p>
<p>有人入不敷出半杯酒便再无贪图。</p>
<p>有人换了张脸企图脱颖而出。</p>
<p>有人躲躲藏藏不想引人注目。</p>
<p>有人狰狞面目却还装得衣冠楚楚。</p>
<p>有人爱的盲目，有人有眼无珠。</p>
<p>有人付之全部，有人一文不出。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-20220430-转移支付"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/30/20220430-%E8%BD%AC%E7%A7%BB%E6%94%AF%E4%BB%98/"
    >转移支付</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/30/20220430-%E8%BD%AC%E7%A7%BB%E6%94%AF%E4%BB%98/" class="article-date">
  <time datetime="2022-04-30T14:45:12.000Z" itemprop="datePublished">2022-04-30</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> TeX_baitu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="TeX_baitu blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>